mutate(stand = LETTERS[row_number()]),
# dataset with "no forest" or "warning" stands (if there are any, if not i´ll just not bind them)
inter.area.df%>%
filter(CCS_r_m  == 17.84) %>%
mutate(area_m2 = as.numeric(area_m2)) %>%
left_join(., stand.df, by = c("plot_ID", "e_ID")) %>%
filter(stand %in% c("no forest", "warning")) %>%
mutate(stand = as.character(stand))
) %>%
# make stand.df joinable by only leaving plot_ID, e_ID, no matter the diameter of the CCS
select(- c(CCS_r_m, inter_stat, area_m2))
stand.df <- stand.df %>%
mutate(plot_ID = as.numeric(plot_ID),
e_ID = as.numeric(e_ID),
inv_year = as.numeric(inv_year))
# join in stand info based on area of the edge segment
inter.area.df <- inter.area.df %>% left_join(., stand.df,
by = c("plot_ID", "e_ID", "inv_year"))
# save datacframe per plot in list
outer.edges.list.two.edges.nogeo[[i]] <- inter.area.df
# create list with those plot ID where the two edges intersect within the radius of 17.84m
intersection.between.edges.17 <- sf::st_intersection(
sf::st_intersection(my.poly.1, circle.17), # intersection poly 1 and cirlce 17
sf::st_intersection(my.poly.2, circle.17)) # intersection poly 2 and cirlce 17
intersection.warning.edges <- ifelse(nrow(intersection.between.edges.17) == 0, NA, intersection.between.edges.17$plot_ID)
outer.intersection.warning.edges.list.nogeo[[i]] <- as.data.frame(cbind("plot_ID" = c(intersection.warning.edges)))
## save intersection polygones in list
# poly.1
outer.inter.poly.1.list.nogeo[[i]] <- if(nrow(inter.poly.17.1)!= 0){c(inter.poly.17.1)}else{c(my.poly.1)}
# poly.2
outer.inter.poly.2.list.nogeo[[i]] <- if(nrow(inter.poly.17.2)!= 0){c(inter.poly.17.2)}else{c( my.poly.2)}
## save the reimaingf circle polygones in a list
remaining.circle.17.1.and.2.poly$plot_ID <- my.plot.id
remaining.circle.17.1.and.2.poly$e_ID <- 0
remaining.circle.17.1.and.2.poly$inv_year <- my.inv.year
remaining.circle.17.1.and.2.poly$e_form <- 0
remaining.circle.17.1.and.2.poly$geometry <- remaining.circle.17.1.and.2.poly$geometry
# create list wit polygones of the remaining cirlce when it´s only one polygone
outer.rem.circle.poly.2.edges.list.nogeo[[i]] <- if(st_geometry_type(remaining.circle.17.1.and.2.poly)== "POLYGON"){c(remaining.circle.17.1.and.2.poly)}else{}
# create list wit polygones of the remaining cirlce when it´s a multipoligone
outer.rem.circle.multipoly.2.edges.list.nogeo[[i]] <- if(st_geometry_type(remaining.circle.17.1.and.2.poly)== "MULTIPOLYGON"){c(remaining.circle.17.1.and.2.poly)}else{}
}
as.data.frame(cbind(
"plot_ID" = my.plot.id,
"e_ID" = c(my.poly.1$e_ID, my.poly.2$e_ID, 0),
"stand"= c(ifelse(length(my.poly.1$stand) == 0, NA, my.poly.2$stand),
ifelse(length(my.poly.2$stand) == 0, NA, my.poly.2$stand),
ifelse(length(remaining.circle.17.1.and.2.poly$stand) == 0, NA, remaining.circle.17.1.and.2.poly$stand) ))) %>%
mutate(plot_ID = as.numeric(plot_ID),
e_ID = as.numeric(e_ID))
my.plot.id
my.poly.1
my.poly.2
stand.df
my.poly.1$stand
my.poly.2$stand
ifelse(length(my.poly.2$stand) == 0, NA, my.poly.2$stand)
ifelse(length(remaining.circle.17.1.and.2.poly$stand) == 0, NA, remaining.circle.17.1.and.2.poly$stand)
stand.df <- as.data.frame(cbind(
"plot_ID" = my.plot.id,
"e_ID" = c(my.poly.1$e_ID, my.poly.2$e_ID, 0),
"stand"= c(ifelse(length(my.poly.1$stand) == 0, NA, my.poly.2$stand),
ifelse(length(my.poly.2$stand) == 0, NA, my.poly.2$stand),
ifelse(length(remaining.circle.17.1.and.2.poly$stand) == 0, NA, remaining.circle.17.1.and.2.poly$stand) ))) %>%
mutate(plot_ID = as.numeric(plot_ID),
e_ID = as.numeric(e_ID))
my.plot.id
cbind(
"plot_ID" = my.plot.id,
"e_ID" = c(my.poly.1$e_ID, my.poly.2$e_ID, 0),
"stand"= c(ifelse(length(my.poly.1$stand) == 0, NA, my.poly.2$stand),
ifelse(length(my.poly.2$stand) == 0, NA, my.poly.2$stand),
ifelse(length(remaining.circle.17.1.and.2.poly$stand) == 0, NA, remaining.circle.17.1.and.2.poly$stand) ))) %>%
mutate(plot_ID = as.numeric(plot_ID),
e_ID = as.numeric(e_ID))
cbind(
"plot_ID" = my.plot.id,
"e_ID" = c(my.poly.1$e_ID, my.poly.2$e_ID, 0),
"stand"= c(ifelse(length(my.poly.1$stand) == 0, NA, my.poly.2$stand),
ifelse(length(my.poly.2$stand) == 0, NA, my.poly.2$stand),
ifelse(length(remaining.circle.17.1.and.2.poly$stand) == 0, NA, remaining.circle.17.1.and.2.poly$stand) )))
cbind(
"plot_ID" = my.plot.id,
"e_ID" = c(my.poly.1$e_ID, my.poly.2$e_ID, 0),
"stand"= c(ifelse(length(my.poly.1$stand) == 0, NA, my.poly.2$stand),
ifelse(length(my.poly.2$stand) == 0, NA, my.poly.2$stand),
ifelse(length(remaining.circle.17.1.and.2.poly$stand) == 0, NA, remaining.circle.17.1.and.2.poly$stand) ))
cbind(
"plot_ID" = c(my.plot.id, my.plot.id, my.plot.id)
"e_ID" = c(my.poly.1$e_ID, my.poly.2$e_ID, 0),
"stand"= c(ifelse(length(my.poly.1$stand) == 0, NA, my.poly.2$stand),
ifelse(length(my.poly.2$stand) == 0, NA, my.poly.2$stand),
ifelse(length(remaining.circle.17.1.and.2.poly$stand) == 0, NA, remaining.circle.17.1.and.2.poly$stand)
cbind(
"plot_ID" = c(my.plot.id, my.plot.id, my.plot.id),
"e_ID" = c(my.poly.1$e_ID, my.poly.2$e_ID, 0),
"stand"= c(ifelse(length(my.poly.1$stand) == 0, NA, my.poly.2$stand),
ifelse(length(my.poly.2$stand) == 0, NA, my.poly.2$stand),
ifelse(length(remaining.circle.17.1.and.2.poly$stand) == 0, NA, remaining.circle.17.1.and.2.poly$stand) ))
cbind(
"plot_ID" = c(my.plot.id, my.plot.id, my.plot.id),
"e_ID" = c(my.poly.1$e_ID, my.poly.2$e_ID, 0),
"stand"= c(ifelse(length(my.poly.1$stand) == 0, NA, my.poly.2$stand),
ifelse(length(my.poly.2$stand) == 0, NA, my.poly.2$stand),
ifelse(length(remaining.circle.17.1.and.2.poly$stand) == 0, NA, remaining.circle.17.1.and.2.poly$stand) ))
length(remaining.circle.17.1.and.2.poly$stand) == 0
length(my.poly.2$stand) == 0
length(my.poly.1$stand) == 0
stand.df <- as.data.frame(cbind(
"plot_ID" = c(my.plot.id, my.plot.id, my.plot.id),
"e_ID" = c(my.poly.1$e_ID, my.poly.2$e_ID, 0),
"stand"= c(ifelse(length(my.poly.1$stand) == 0, NA, my.poly.1$stand),
ifelse(length(my.poly.2$stand) == 0, NA, my.poly.2$stand),
ifelse(length(remaining.circle.17.1.and.2.poly$stand) == 0, NA, remaining.circle.17.1.and.2.poly$stand) ))) %>%
mutate(plot_ID = as.numeric(plot_ID),
e_ID = as.numeric(e_ID))
stand.df <- as.data.frame(cbind(
"plot_ID" = my.plot.id,
"e_ID" = c(my.poly.1$e_ID, my.poly.2$e_ID, 0),
"stand"= c(ifelse(length(my.poly.1$stand) == 0, NA, my.poly.1$stand),
ifelse(length(my.poly.2$stand) == 0, NA, my.poly.2$stand),
ifelse(length(remaining.circle.17.1.and.2.poly$stand) == 0, NA, remaining.circle.17.1.and.2.poly$stand) ))) %>%
mutate(plot_ID = as.numeric(plot_ID),
e_ID = as.numeric(e_ID))
stand.df <-
rbind(
inter.area.df%>%
filter(CCS_r_m  == 17.84) %>%
mutate(area_m2 = as.numeric(area_m2)) %>%
left_join(., stand.df, by = c("plot_ID", "e_ID")) %>%
group_by(plot_ID, inv_year) %>%
arrange(desc(area_m2)) %>%
filter(!(stand %in% c("no forest", "warning"))) %>%
# assing stand according to row number by selecting the letter of the alphabet with the respective number e.g. row == 1 --> A:
# https://www.geeksforgeeks.org/sequence-of-alphabetical-character-letters-from-a-z-in-r/
# lowest area receives stand ID C, then B, then A
mutate(stand = LETTERS[row_number()]),
# dataset with "no forest" or "warning" stands (if there are any, if not i´ll just not bind them)
inter.area.df%>%
filter(CCS_r_m  == 17.84) %>%
mutate(area_m2 = as.numeric(area_m2)) %>%
left_join(., stand.df, by = c("plot_ID", "e_ID")) %>%
filter(stand %in% c("no forest", "warning")) %>%
mutate(stand = as.character(stand))
) %>%
# make stand.df joinable by only leaving plot_ID, e_ID, no matter the diameter of the CCS
select(- c(CCS_r_m, inter_stat, area_m2))
stand.df <- stand.df %>%
mutate(plot_ID = as.numeric(plot_ID),
e_ID = as.numeric(e_ID),
inv_year = as.numeric(inv_year))
# join in stand info based on area of the edge segment
inter.area.df <- inter.area.df %>% left_join(., stand.df,
by = c("plot_ID", "e_ID", "inv_year"))
inter.area.df
for (i in 1:length(unique(forest_edges.man.sub.2.outer.edges.nogeo$plot_ID))){
#i = 2
# i = which(grepl(50009, unique(forest_edges.man.sub.2.outer.edges.nogeo$plot_ID)))
# select plot ID of the respective circle
my.plot.id <- unique(forest_edges.man.sub.2.outer.edges.nogeo$plot_ID)[i]
my.inv.year <- unique(forest_edges.man.sub.2.outer.edges.nogeo[i, c("plot_ID", "inv_year")])[, "inv_year"]
## select the UTM coordiantes of the center of the cirlce corresponding with the plot ID
# my.center.easting <- geo_loc[geo_loc$plot_ID == my.plot.id, "RW_MED"]
# my.center.northing <- geo_loc[geo_loc$plot_ID == my.plot.id, "HW_MED"]
## select crs
# my.utm.epsg <-  paste0("+proj=utm +zone=", pick_utm(my.center.easting)," ", "+datum=WGS84 +units=m +no_defs +type=crs")
#### build circle
# circle data
c.x0 = 0    # + my.center.easting
c.y0 = 0    # + my.center.northing
c.r3 = 17.84
c.r2 = 12.62
c.r1 = 5.64
# build polygon (circlular buffer) around center point
center.df<- as.data.frame(cbind("lon" = c.x0, "lat" = c.y0))
circle.pt <- sf::st_as_sf(center.df, coords = c("lon", "lat"))
## assing crs to cirlce corodiantes
# sf::st_crs(circle.pt) <- my.utm.epsg
circle.17 <- sf::st_buffer(circle.pt, c.r3)
circle.12 <- sf::st_buffer(circle.pt, c.r2)
circle.5 <- sf::st_buffer(circle.pt, c.r1)
# tree data to identify edge without trees
outer.trees.df <- trees_data[trees_data$plot_ID == my.plot.id, ]
my.tree.id <- outer.trees.df["tree_ID"]
# calcualte polar coordinates of trees
tree.coord.df <- outer.trees.df %>%
mutate(dist_tree = dist_cm/100,
x_tree = dist_tree*sin(azi_gon),
y_tree = dist_tree*cos(azi_gon),
lon = x_tree, #+ my.center.easting,
lat =  y_tree ) %>% # + my.center.northing)
select(plot_ID, tree_ID, inv_year, lon, lat) %>% distinct()
# create sf point object from dataframe
#https://stackoverflow.com/questions/52551016/creating-sf-points-from-multiple-lat-longs
tree.sf <-  sf::st_as_sf(tree.coord.df, coords = c("lon", "lat"), remove = FALSE)
## assing CRS to points
#sf::st_crs(tree.sf) <- my.utm.epsg
#### select the  polygones the circle is intersected by
# select the polygones with the same plot ID as the cirlce
my.plot.polys.df <- edge.poly.df.nogeo %>% filter(plot_ID == my.plot.id & inv_year == my.inv.year) %>% arrange(e_ID) %>%
left_join(., forest_edges.man %>% select(plot_ID, e_ID, e_type), by = c("plot_ID", "e_ID"))
#  this part is about whicht polgone to priotiise if there are two overlapping edges:
# usually we would select the polygone with edge_ID == 1 to be the priotiised one. now however, we will select the polygone with
# no trees to be the prioritized
## create the polygones of the edge geometries
# determine intersection status between poly and trees
# select the polygone with no trees and make it poly.1
# if the first polygone intersects with trees, but the second polygone doesn´t have intersections with trees while the edge type is 1 or 2,
# poly.1 is changes to poly.2
# if that is not the case everything remains as it is in the "normal" / "not outer  edges" way
# if edge 2 doesn´t have trees and the edge type 1 or two  edge ID 2 becomed poly.1 and edge ID 1 becomes poly.2
# poly.1 means that this is the polygone to be prioritized while
# --> this means the only way to prioritize the polygonn with the ID 2 is when it is an edge is an outer edge and it really doesnt have trees
# in any other case edge ID 1is prioritized
if(isTRUE(nrow(st_intersection(sf::st_as_sf(my.plot.polys.df[2,]), tree.sf)) == 0 && my.plot.polys.df$e_type[2] %in% c(1,2) &&
nrow(st_intersection(sf::st_as_sf(my.plot.polys.df[1,]), tree.sf)) != 0) && !(my.plot.polys.df$e_type[2] %in% c(1,2))){
my.poly.1 <- sf::st_as_sf(my.plot.polys.df[2,])
my.poly.2 <- sf::st_as_sf(my.plot.polys.df[1,])
}else {
# if edge ID 2 does have type 1 or 2 but intersects with trees, the poly with the ID 1 remains poly.1 if
# if edge ID 1 doesn´t have trees but has the edge type 1 or 2 edge 1 becomed poly.1 and edge 2 becomes poly.2
# if both edges have trees or both edges do not have trees no matter their edge type, the poly with edge ID 1 becomes poly.1 and the edge with ID 2 becomes poly.2
my.poly.1 <- sf::st_as_sf(my.plot.polys.df[1,])
my.poly.2 <- sf::st_as_sf(my.plot.polys.df[2,])
}
# select edge ID of edge polygones
my.e.id.1 <- my.poly.1$e_ID
my.e.id.2 <- my.poly.2$e_ID
# select edge form of the respective edge polygones
my.e.form.1 <- my.poly.1$e_form
my.e.form.2 <- my.poly.2$e_form
# print edges and circle
print(c(plot(circle.17$geometry),
plot(my.poly.1$geometry, col = "red", add = T),
plot(my.poly.2$geometry, col = "blue",  add = T),
plot(st_geometry(tree.sf), add = TRUE)))
#### intersections between polygones and circles
### 17m circle
my.circle = circle.17
## create poolygon of intersection for first polygon with circle
inter.poly.17.1  <- st_intersection(my.circle, my.poly.1)
inter.status.poly.17.1 <- ifelse(nrow(inter.poly.17.1) == 0, "no intersections",
ifelse(my.e.form.1 == 1 & inter.poly.17.1$geometry == my.circle$geometry,  "no intersections",
ifelse(my.e.form.1 == 2 & inter.poly.17.1$geometry == my.circle$geometry, "fully covering circle",
"partly intersecting")))
# if the first ednge covers all of the circle remaining its going to be set to 0 so we know there are no direct intersections and the circle is passed on to the next edge to calcualte the intersection
# https://www.statology.org/r-argument-is-of-length-zero/
inter.poly.17.1 <- if(isTRUE(inter.poly.17.1) && inter.poly.17.1$geometry == my.circle$geometry){inter.poly.17.1 <- data.frame()}else{inter.poly.17.1}
## create poolygon of remaining circle after first edge polygone is intersected
# create poly with remaining area: https://gis.stackexchange.com/questions/353633/r-spatial-erase-one-polygon-from-another-correct-use-of-st-difference
remaining.circle.17.1 <- if(nrow(inter.poly.17.1)==0){my.circle}else{sf::st_difference(my.circle, inter.poly.17.1)}
#print(plot(remaining.circle.17.1$geometry, main = paste0(my.plot.id, "-", my.e.form.1,  "-", c.r3)))
## create polygone of intersecting area of second polygone with remaining circle
inter.poly.17.2 <- st_intersection(my.poly.2, st_geometry(remaining.circle.17.1))
inter.status.poly.17.2 <- ifelse(nrow(inter.poly.17.2) == 0, "no intersections",
ifelse(my.e.form.2== 1 & inter.poly.17.2$geometry == remaining.circle.17.1$geometry,  "no intersections",
ifelse(my.e.form.2 == 2 & inter.poly.17.2$geometry == remaining.circle.17.1$geometry, "fully covering circle",
"partly intersecting")))
# if the second edge covers all of the circle remaining its going to be set to 0 so we know there are no direct intersections
# https://www.statology.org/r-argument-is-of-length-zero/
inter.poly.17.2 <- if(isTRUE(inter.poly.17.2) && inter.poly.17.2$geometry == remaining.circle.17.1$geometry){inter.poly.17.2 <- data.frame()}else{inter.poly.17.2}
## create polygone of the  remaining cricle after both intersects are decucted
# so the area of the frst remining circle minus the area of the second remaining circle
remaining.circle.17.1.and.2.poly <- if(nrow(inter.poly.17.2)==0){remaining.circle.17.1}else{sf::st_difference(remaining.circle.17.1, inter.poly.17.2)}
#print(plot(remaining.circle.17.1.and.2.poly$geometry, main = paste0(my.plot.id, "-", my.e.form.2,  "-", c.r3)))
### 12m circle
my.circle = circle.12
## create poolygon of intersection for first polygon with circle
inter.poly.12.1  <- st_intersection(my.circle, my.poly.1)
inter.status.poly.12.1 <- ifelse(nrow(inter.poly.12.1) == 0, "no intersections",
ifelse(my.e.form.1 == 1 & inter.poly.12.1$geometry == my.circle$geometry,  "no intersections",
ifelse(my.e.form.1 == 2 & inter.poly.12.1$geometry == my.circle$geometry, "fully covering circle",
"partly intersecting")))
# if the first ednge covers all of the circle remaining its going to be set to 0 so we know there are no direct intersections and the circle is passed on to the next edge to calcualte the intersection
# https://www.statology.org/r-argument-is-of-length-zero/
inter.poly.12.1 <- if(isTRUE(inter.poly.12.1) && inter.poly.12.1$geometry == my.circle$geometry){inter.poly.12.1 <- data.frame()}else{inter.poly.12.1}
## create poolygon of remaining circle after first edge polygone is intersected
# create poly with remaining area: https://gis.stackexchange.com/questions/353633/r-spatial-erase-one-polygon-from-another-correct-use-of-st-difference
remaining.circle.12.1 <- if(nrow(inter.poly.12.1)==0){my.circle}else{sf::st_difference(my.circle, inter.poly.12.1)}
# print(plot(remaining.circle.12.1$geometry, main = paste0(my.plot.id, "-",my.e.form.1,  "-", c.r2)))
## create polygone of intersecting area of second polygone with remaining circle
inter.poly.12.2 <- st_intersection(my.poly.2, st_geometry(remaining.circle.12.1))
inter.status.poly.12.2 <- ifelse(nrow(inter.poly.12.2) == 0, "no intersections",
ifelse(my.e.form.2== 1 & inter.poly.12.2$geometry == remaining.circle.12.1$geometry,  "no intersections",
ifelse(my.e.form.2 == 2 & inter.poly.12.2$geometry == remaining.circle.12.1$geometry, "fully covering circle",
"partly intersecting")))
# if the second edge covers all of the circle remaining its going to be set to 0 so we know there are no direct intersections
# https://www.statology.org/r-argument-is-of-length-zero/
inter.poly.12.2 <- if(isTRUE(inter.poly.12.2) && inter.poly.12.2$geometry == remaining.circle.12.1$geometry){inter.poly.12.2 <- data.frame()}else{inter.poly.12.2}
## create polygone of the  remaining cricle after both intersects are decucted
# so the area of the frst remining circle minus the area of the second remaining circle
remaining.circle.12.1.and.2.poly <- if(nrow(inter.poly.12.2)==0){remaining.circle.12.1}else{sf::st_difference(remaining.circle.12.1, inter.poly.12.2)}
#print(plot(remaining.circle.12.1.and.2.poly$geometry, main = paste0(my.plot.id, "-", my.e.form.2,  "-", c.r2)))
### 5m circle
my.circle = circle.5
## create poolygon of intersection for first polygon with circle
inter.poly.5.1  <- st_intersection(my.circle, my.poly.1)
inter.status.poly.5.1 <- ifelse(nrow(inter.poly.5.1) == 0, "no intersections",
ifelse(my.e.form.1 == 1 & inter.poly.5.1$geometry == my.circle$geometry,  "no intersections",
ifelse(my.e.form.1 == 2 & inter.poly.5.1$geometry == my.circle$geometry, "fully covering circle",
"partly intersecting")))
# if the first ednge covers all of the circle remaining its going to be set to 0 so we know there are no direct intersections and the circle is passed on to the next edge to calcualte the intersection
# https://www.statology.org/r-argument-is-of-length-zero/
inter.poly.5.1 <- if(isTRUE(inter.poly.5.1) && inter.poly.5.1$geometry == my.circle$geometry){inter.poly.5.1 <- data.frame()}else{inter.poly.5.1}
## create poolygon of remaining circle after first edge polygone is intersected
# create poly with remaining area: https://gis.stackexchange.com/questions/353633/r-spatial-erase-one-polygon-from-another-correct-use-of-st-difference
remaining.circle.5.1 <- if(nrow(inter.poly.5.1)==0){my.circle}else{sf::st_difference(my.circle, inter.poly.5.1)}
# print(plot(remaining.circle.5.1$geometry, main = paste0(my.plot.id, "-",my.e.form.1,  "-", c.r1)))
## create polygone of intersecting area of second polygone with remaining circle
inter.poly.5.2 <- st_intersection(my.poly.2, st_geometry(remaining.circle.5.1))
inter.status.poly.5.2 <- ifelse(nrow(inter.poly.5.2) == 0, "no intersections",
ifelse(my.e.form.2== 1 & inter.poly.5.2$geometry == remaining.circle.5.1$geometry,  "no intersections",
ifelse(my.e.form.2 == 2 & inter.poly.5.2$geometry == remaining.circle.5.1$geometry, "fully covering circle",
"partly intersecting")))
# if the second edge covers all of the circle remaining its going to be set to 0 so we know there are no direct intersections
# https://www.statology.org/r-argument-is-of-length-zero/
inter.poly.5.2 <- if(isTRUE(inter.poly.5.2) && inter.poly.5.2$geometry == remaining.circle.5.1$geometry){inter.poly.5.2 <- data.frame()}else{inter.poly.5.2}
## create polygone of the  remaining cricle after both intersects are decucted
# so the area of the frst remining circle minus the area of the second remaining circle
remaining.circle.5.1.and.2.poly <- if(nrow(inter.poly.5.2)==0){remaining.circle.5.1}else{sf::st_difference(remaining.circle.5.1, inter.poly.5.2)}
plot(remaining.circle.17.1.and.2.poly$geometry, main = paste0(my.plot.id, " - ", my.e.form.1, " - ", my.e.form.2))
plot(remaining.circle.12.1.and.2.poly$geometry, add = T)
plot(remaining.circle.5.1.and.2.poly$geometry, add = T)
plot(st_geometry(tree.sf), add = TRUE)
#### calculate the area
## 17m cricle
# area of the intersection 1
inter.17.1.area <- ifelse(nrow(inter.poly.17.1) == 0, 0, sf::st_area(inter.poly.17.1))
# area of the intersection polygone 2
inter.17.2.area <- ifelse(nrow(inter.poly.17.2) == 0, 0, sf::st_area(inter.poly.17.2))
#  area of the remaining circle, after both intersections are deducted
remaining.circle.area.17 <- sf::st_area(remaining.circle.17.1.and.2.poly)
# save area in dataframe
inter.area.df.17 <- as.data.frame(
cbind("plot_ID" = c(my.plot.id, my.plot.id, my.plot.id), "e_ID" = c(my.e.id.1, my.e.id.2, 0),
"inv_year" = c(my.inv.year, my.inv.year, my.inv.year),
#"e_form" = c(my.poly.1$e_form, my.poly.2$e_form, 0),"shape" = c("edge", "edge", "circle"),
"CCS_r_m" = c(c.r3, c.r3, c.r3),
"inter_stat" = c(inter.status.poly.17.1, inter.status.poly.17.2, 0),
"area_m2" = c(inter.17.1.area, inter.17.2.area, remaining.circle.area.17)
))
## 12m cricle
# area of the intersection 1
inter.12.1.area <- ifelse(nrow(inter.poly.12.1) == 0, 0, sf::st_area(inter.poly.12.1))
# area of the intersection polygone 2
inter.12.2.area <- ifelse(nrow(inter.poly.12.2) == 0, 0, sf::st_area(inter.poly.12.2))
#  area of the remaining circle, after both intersections are deducted
remaining.circle.area.12 <- sf::st_area(remaining.circle.12.1.and.2.poly)
# save area in dataframe
inter.area.df.12 <- as.data.frame(
cbind("plot_ID" = c(my.plot.id, my.plot.id, my.plot.id), "e_ID" = c(my.e.id.1, my.e.id.2, 0),
#"e_form" = c(my.poly.1$e_form, my.poly.2$e_form, 0),"shape" = c("edge", "edge", "circle"),
"inv_year" = c(my.inv.year, my.inv.year, my.inv.year),
"CCS_r_m" = c(c.r2, c.r2, c.r2),
"inter_stat" = c(inter.status.poly.12.1, inter.status.poly.12.2, 0),
"area_m2" = c(inter.12.1.area, inter.12.2.area, remaining.circle.area.12)
))
## 5m cricle
# area of the intersection 1
inter.5.1.area <- ifelse(nrow(inter.poly.5.1) == 0, 0, sf::st_area(inter.poly.5.1))
# area of the intersection polygone 2
inter.5.2.area <- ifelse(nrow(inter.poly.5.2) == 0, 0, sf::st_area(inter.poly.5.2))
#  area of the remaining circle, after both intersections are deducted
remaining.circle.area.5 <- sf::st_area(remaining.circle.5.1.and.2.poly)
# save area in dataframe
inter.area.df.5 <- as.data.frame(
cbind("plot_ID" = c(my.plot.id, my.plot.id, my.plot.id),
"e_ID" = c(my.e.id.1, my.e.id.2, 0),
#"e_form" = c(my.poly.1$e_form, my.poly.2$e_form, 0),"shape" = c("edge", "edge", "circle"),
"inv_year" = c(my.inv.year, my.inv.year, my.inv.year),
"CCS_r_m" = c(c.r1, c.r1, c.r1),
"inter_stat" = c(inter.status.poly.5.1, inter.status.poly.5.2, 0),
"area_m2" = c(inter.5.1.area, inter.5.2.area, remaining.circle.area.5)
))
# bind area datafames of all 3 circles together
inter.area.df <- rbind(inter.area.df.17, inter.area.df.12,inter.area.df.5 ) %>%
mutate(across(c("plot_ID", "e_ID", "inv_year", "CCS_r_m", "area_m2"), as.numeric))
# assing stand to the edges depedning on area and the stand with trees
# is there a polygone that does not incluce the middle of the plot, has the t<pe 1 or 2 (if its an edge) and doesn´t have trees
# then the poylgone is labelled with "no forest" and the remaining polygones are allocated into stands by area
# first "if": both edges are edge type 1 or 2 and do not have trees and do not have the middle of the plot
if(isTRUE((nrow(st_intersection(inter.poly.17.1, tree.sf))==0 &&
inter.poly.17.1$e_type %in% c(1,2) &&
nrow(st_intersection(inter.poly.17.1, circle.pt))==0) &&
nrow(st_intersection(inter.poly.17.2, tree.sf))==0 &&
inter.poly.17.2$e_type %in% c(1,2) &&
nrow(st_intersection(inter.poly.17.2, circle.pt))==0)){
my.poly.1$stand <- "no forest"
my.poly.2$stand <- "no forest"
# second "if": edge.1 has type 1 or 2, doesn´t have tres and doesnt have the middle of the plot so it´s labelled no forest
}else if(isTRUE(nrow(st_intersection(inter.poly.17.1, tree.sf))==0 &&
inter.poly.17.1$e_type %in% c(1,2) &&
nrow(st_intersection(inter.poly.17.1, circle.pt))==0 &&
# and the conditions are not true for the second polygone
isFALSE(nrow(st_intersection(inter.poly.17.2, tree.sf))==0 &&
inter.poly.17.2$e_type %in% c(1,2) &&
nrow(st_intersection(inter.poly.17.2, circle.pt))==0) == TRUE)){
# give poly.1 the stand "no forest"
my.poly.1$stand <- "no forest"
# third "if": edge.2 has type 1 or 2, doe´t ahve trees and does´nt have the middle of the plot so it´s labelled "no forest"
} else if(isTRUE(nrow(st_intersection(inter.poly.17.2, tree.sf))==0 &&
inter.poly.17.2$e_type %in% c(1,2) &&
nrow(st_intersection(inter.poly.17.2, circle.pt))==0 &&
# and the condition is not true for poly.1
isFALSE(nrow(st_intersection(inter.poly.17.1, tree.sf))==0 &&
inter.poly.17.1$e_type %in% c(1,2) &&
nrow(st_intersection(inter.poly.17.1, circle.pt))==0) == TRUE)){
# give th label "no forest"
my.poly.2$stand <- "no forest"
# fourth and fith "if": the edge is type 1 or 2 , it doesn´t hold the middle of the plot but it has trees --> warning
}else if (isTRUE(nrow(st_intersection(inter.poly.17.1, tree.sf))!=0 &&
inter.poly.17.1$e_type %in% c(1,2) &&
nrow(st_intersection(inter.poly.17.1, circle.pt))==0)){
my.poly.1$stand <- "warning"
}else if (isTRUE(nrow(st_intersection(inter.poly.17.2, tree.sf))!=0 &&
inter.poly.17.2$e_type %in% c(1,2) &&
nrow(st_intersection(inter.poly.17.2, circle.pt))==0)){
my.poly.2$stand <- "warning"
}else if(isTRUE(nrow(st_intersection(inter.poly.17.1, tree.sf))!=0 &&
inter.poly.17.1$e_type %in% c(1,2) &&
nrow(st_intersection(inter.poly.17.1, circle.pt))==0 &&
nrow(st_intersection(inter.poly.17.2, tree.sf))!=0 &&
inter.poly.17.2$e_type %in% c(1,2) &&
nrow(st_intersection(inter.poly.17.2, circle.pt))==0)){
my.poly.1$stand <- "warning"
my.poly.2$stand <- "warning"
# sixth "if": the remeining cirlce doesn´t have the middle of the plot (soits actually and edge) and doesnt have trees --> "no forest"
}else if(isTRUE(nrow(st_intersection(inter.poly.17.1, circle.pt))==0 &&
nrow(st_intersection(remaining.circle.17.1.and.2.poly, tree.sf))==0)){
remaining.circle.17.1.and.2.poly$stand <- "no forest"
}else{
}
stand.df <- as.data.frame(cbind(
"plot_ID" = my.plot.id,
"e_ID" = c(my.poly.1$e_ID, my.poly.2$e_ID, 0),
"stand"= c(ifelse(length(my.poly.1$stand) == 0, NA, my.poly.1$stand),
ifelse(length(my.poly.2$stand) == 0, NA, my.poly.2$stand),
ifelse(length(remaining.circle.17.1.and.2.poly$stand) == 0, NA, remaining.circle.17.1.and.2.poly$stand) ))) %>%
mutate(plot_ID = as.numeric(plot_ID),
e_ID = as.numeric(e_ID))
stand.df <-
rbind(
inter.area.df%>%
filter(CCS_r_m  == 17.84) %>%
mutate(area_m2 = as.numeric(area_m2)) %>%
left_join(., stand.df, by = c("plot_ID", "e_ID")) %>%
group_by(plot_ID, inv_year) %>%
arrange(desc(area_m2)) %>%
filter(!(stand %in% c("no forest", "warning"))) %>%
# assing stand according to row number by selecting the letter of the alphabet with the respective number e.g. row == 1 --> A:
# https://www.geeksforgeeks.org/sequence-of-alphabetical-character-letters-from-a-z-in-r/
# lowest area receives stand ID C, then B, then A
mutate(stand = LETTERS[row_number()]),
# dataset with "no forest" or "warning" stands (if there are any, if not i´ll just not bind them)
inter.area.df%>%
filter(CCS_r_m  == 17.84) %>%
mutate(area_m2 = as.numeric(area_m2)) %>%
left_join(., stand.df, by = c("plot_ID", "e_ID")) %>%
filter(stand %in% c("no forest", "warning")) %>%
mutate(stand = as.character(stand))
) %>%
# make stand.df joinable by only leaving plot_ID, e_ID, no matter the diameter of the CCS
select(- c(CCS_r_m, inter_stat, area_m2))
stand.df <- stand.df %>%
mutate(plot_ID = as.numeric(plot_ID),
e_ID = as.numeric(e_ID),
inv_year = as.numeric(inv_year))
# join in stand info based on area of the edge segment
inter.area.df <- inter.area.df %>% left_join(., stand.df,
by = c("plot_ID", "e_ID", "inv_year"))
# save datacframe per plot in list
outer.edges.list.two.edges.nogeo[[i]] <- inter.area.df
# create list with those plot ID where the two edges intersect within the radius of 17.84m
intersection.between.edges.17 <- sf::st_intersection(
sf::st_intersection(my.poly.1, circle.17), # intersection poly 1 and cirlce 17
sf::st_intersection(my.poly.2, circle.17)) # intersection poly 2 and cirlce 17
intersection.warning.edges <- ifelse(nrow(intersection.between.edges.17) == 0, NA, intersection.between.edges.17$plot_ID)
outer.intersection.warning.edges.list.nogeo[[i]] <- as.data.frame(cbind("plot_ID" = c(intersection.warning.edges)))
## save intersection polygones in list
# poly.1
outer.inter.poly.1.list.nogeo[[i]] <- if(nrow(inter.poly.17.1)!= 0){c(inter.poly.17.1)}else{c(my.poly.1)}
# poly.2
outer.inter.poly.2.list.nogeo[[i]] <- if(nrow(inter.poly.17.2)!= 0){c(inter.poly.17.2)}else{c( my.poly.2)}
## save the reimaingf circle polygones in a list
remaining.circle.17.1.and.2.poly$plot_ID <- my.plot.id
remaining.circle.17.1.and.2.poly$e_ID <- 0
remaining.circle.17.1.and.2.poly$inv_year <- my.inv.year
remaining.circle.17.1.and.2.poly$e_form <- 0
remaining.circle.17.1.and.2.poly$geometry <- remaining.circle.17.1.and.2.poly$geometry
# create list wit polygones of the remaining cirlce when it´s only one polygone
outer.rem.circle.poly.2.edges.list.nogeo[[i]] <- if(st_geometry_type(remaining.circle.17.1.and.2.poly)== "POLYGON"){c(remaining.circle.17.1.and.2.poly)}else{}
# create list wit polygones of the remaining cirlce when it´s a multipoligone
outer.rem.circle.multipoly.2.edges.list.nogeo[[i]] <- if(st_geometry_type(remaining.circle.17.1.and.2.poly)== "MULTIPOLYGON"){c(remaining.circle.17.1.and.2.poly)}else{}
}
# save areas into dataframe
outer.edges.area.two.edges.df.nogeo <- as.data.frame(rbindlist(edges.list.two.edges.nogeo))
outer.edges.area.two.edges.df.nogeo
# save areas into dataframe
outer.edges.area.two.edges.df.nogeo <- as.data.frame(rbindlist(outer.edges.list.two.edges.nogeo))
outer.edges.area.two.edges.df.nogeo
outer.edges.area.two.edges.df.nogeo %>% select(plot_ID) %>% distinct()
forest_edges.man.sub.2.outer.edges.nogeo %>% select(plot_ID) %>% distinct()
identical(outer.edges.area.two.edges.df.nogeo %>% select(plot_ID) %>% distinct(), forest_edges.man.sub.2.outer.edges.nogeo %>% select(plot_ID) %>% distinct())
outer.edges.area.two.edges.df.nogeo %>% select(plot_ID) %>% distinct()
anti_join(outer.edges.area.two.edges.df.nogeo %>% select(plot_ID) %>% distinct(),
forest_edges.man.sub.2.outer.edges.nogeo %>% select(plot_ID) %>% distinct())
anti_join(forest_edges.man.sub.2.outer.edges.nogeo %>% select(plot_ID) %>% distinct(),
outer.edges.area.two.edges.df.nogeo %>% select(plot_ID) %>% distinct()
)
identical(forest_edges.man.sub.2.outer.edges.nogeo %>% select(plot_ID) %>% distinct(),
outer.edges.area.two.edges.df.nogeo %>% select(plot_ID) %>% distinct()
)

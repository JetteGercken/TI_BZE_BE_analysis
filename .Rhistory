# here i create a dataset with DW plots that have status 2
# which only contains info we can catually give so the plot area , the plot ID and the stocks which are set to 0
DW_stat_2 <- DW_inv_info[DW_inv_info$CCS_DW_inv_status == 2, ]
DW_stat_2
# 2.4.4. creating empty plots for circuits labelled empty ------------------------------------------------------------------
# here i create a dataset with DW plots that have status 2
# which only contains info we can catually give so the plot area , the plot ID and the stocks which are set to 0
DW_stat_2 <- DW_inv_info[DW_inv_info$CCS_DW_inv_status == 2, ]
DW.data.stat.2.list <- vector("list")
for (i in 1:nrow(DW_stat_2)) {
# i = 1
my.plot.id <- DW_stat_2[, "plot_ID"][i]
my.plot.area <- DW_stat_2[, "plot_A_ha"][i]
my.inv.year <- DW_stat_2[, "inv_year"][i]
if(nrow(DW_stat_2) != 0){
DW.status.2.df <- as.data.frame(cbind(
plot_ID = c(my.plot.id),
plot_A_ha = c(my.plot.area),
inv_year = c(my.inv.year),
compartiment = c("ag", "bg", "total"),
B_t_ha = c(0, 0, 0),
C_t_ha = c(0, 0, 0),
N_t_ha = c(0, 0, 0)))
}else{
DW.status.2.df = as.data.frame(cbind(
plot_ID = NA,
plot_A_ha = NA,
inv_year = NA,
compartiment = NA,
B_t_ha = NA,
C_t_ha = NA,
N_t_ha = NA))
}
DW.data.stat.2.list[[i]] <- DW.status.2.df
}
DW_data_stat_2 <- as.data.frame(rbindlist(DW.data.stat.2.list))
DW_data
left_join(DW_CCS_to_exclude %>%
select(plot_ID, inv, inv_year, rem_reason),
DW_data,
by = c("plot_ID", "inv", "inv_year"))
left_join(DW_data,
DW_CCS_to_exclude %>%
select(plot_ID, inv, inv_year, rem_reason),
by = c("plot_ID", "inv", "inv_year"))
semi_join(DW_data,
DW_CCS_to_exclude %>%
select(plot_ID, inv, inv_year, rem_reason),
by = c("plot_ID", "inv", "inv_year"))
semi_join(
DW_CCS_to_exclude %>%
select(plot_ID, inv, inv_year, rem_reason),
DW_data,
by = c("plot_ID", "inv", "inv_year"))
DW_data %>%
semi_join(
DW_CCS_to_exclude %>%
select(plot_ID, inv, inv_year),
by = c("plot_ID", "inv", "inv_year")) %>%
left_join(DW_CCS_to_exclude %>%
select(plot_ID, inv, inv_year, rem_reason),
by = c("plot_ID", "inv", "inv_year"))
DW_data %>%
# select trees in CCS with status 3,  -9, -1 , 2, even though status 2 doesn´t count as being removed, we list it here, since status 2 CCS are not supposed to have DW items anyways
semi_join(., DW_inv_info %>%
filter(!(CCS_DW_inv_status %in% c(1, 4, 5))),
by = c("plot_ID", "inv", "inv_year")) %>%
mutate(rem_reason = "DW circle excluded during inventory status sorting")
# 2.4.5. prepare DW_data for export ---------------------------------------
DW_removed <-
plyr::rbind.fill(
# use DW_CCS_to remove, to "pull out" the trees from DW data that should be removed
# while keeping the reason for the removal at the same time
DW_data %>%
semi_join(
DW_CCS_to_exclude %>%
select(plot_ID, inv, inv_year),
by = c("plot_ID", "inv", "inv_year")) %>%
# join in reason for removal
left_join(DW_CCS_to_exclude %>%
select(plot_ID, inv, inv_year, rem_reason),
by = c("plot_ID", "inv", "inv_year")) ,
DW_data %>%
# select trees in CCS with status 3,  -9, -1 , 2, even though status 2 doesn´t count as being removed, we list it here, since status 2 CCS are not supposed to have DW items anyways
semi_join(., DW_inv_info %>%
filter(!(CCS_DW_inv_status %in% c(1, 4, 5))),
by = c("plot_ID", "inv", "inv_year")) %>%
mutate(rem_reason = "DW circle excluded during inventory status sorting")
)
DW_removed
# select only DW items in CCS with status 1, 4, 5 because status 2 CCSs we have in a separate dataset
DW_update_1 <- DW_data %>%
# remove trees in CCS with status 3
semi_join(., DW_inv_info %>% filter(CCS_DW_inv_status %in% c(1, 4, 5)),
by = c("plot_ID", "inv", "inv_year")) %>%
# join in the plot area for the deadwood
left_join(., DW_inv_info %>% select(plot_ID, inv, inv_year, plot_A_ha),
by = c("plot_ID", "inv", "inv_year"))
DW_CCS_to_exclude
LT_CCS_to_exclude
trees_removed
RG_removed
RG_CCS_to_exclude
tree_inv_info%>%
filter(!(CCS_LT_inv_status %in% c(1, 2)) |# CCS that were not inventorable
!(hbi_status %in% c(1,2)) |
inv == "warning") %>%      # plot was part of NFI not BSI
mutate(rem_reason = case_when(
!(CCS_LT_inv_status %in% c(1, 2)) ~ "LT circle excluded during inventory status sorting",
!(hbi_status %in% c(1,2)) | inv == "warning" ~ "all LT circles excluded during inventory status sorting",
TRUE ~ NA))
tree_inv_info%>%
filter(!(CCS_LT_inv_status %in% c(1, 2)) |# CCS that were not inventorable
!(hbi_status %in% c(1,2)) |
inv == "warning")
# Thuenen Institute - Bodenschutz und Waldzustand
# Analysis of the forest inventory accompanying the peat land soil inventory
# sorting the sampling circuits according to their inventory status
# HBI BZE2
# this script should sort every sampling circle, may it be a living trees plot,
# a regeneration plot or a deadwood plot accoridnt to it´s invenory status (Aufnahmemöglichkeit)
# the inventory status code displays the following information:
## ALL PLOTS & STAND COMPONENTS
# Punktstatus (x_plotstatus_bze)
# -9 Merkmal vergessen, nicht rekonstruierbar oder unbekannt
# -1 Merkmal nicht erhoben
# 0 BZE-Punkt wurde in allen Erhebungen beprobt
# 1 BZE-Punkt wurde bei BZE II und III, aber nicht BZE I beprobt
# 3 BZE-Punkt wurde bei BZE I und III, aber nicht BZE II beprobt
# -- Neuanlage bei der BZE III
# 11 Neuanlage: Erstaufforstung
# 12 Neuanlage: Wiederaufforstung
# 13 Neuanlage: Sukzession
# 14 Neuanlage: Rasterverschiebung
# 15 Neuanlage: Rasterumstellung
# 16 Neuanlage: BZE-Punkt wurde nicht gefunden / nicht beprobt
# 17 Neuanlage: Punkt wurde bisher nicht aufgenommen, obwohl zur Waldfläche gehörend
# 19 Neuanlage: Sonstiges
# -- Ausfall bei der BZE III
# 21 Ausfall: Umwandlung in Nichtwald oder Nichtholzboden
# 22 Ausfall: Punkt nicht gefunden und deswegen Neuanlage
# 23 Ausfall: Punkt nicht mehr erreichbar (z. B: Truppenübungsplatz, Moorrenaturierung)
# 24 Ausfall: keine Probenahmeerlaubnis
# 25 Ausfall: Rasterverschiebung
# 26 Ausfall: Rasterumstellung (Netzweite geändert)
# 27 Ausfall: Rasterüberprüfung (Punkt gehört nicht zum Rasternetz)
# 28 Ausfall: Eichenprozessionsspinner (EPS)
# 29 Ausfall: Gesundheitsgefahr (außer EPS)
# 30 Ausfall: Arbeitsschutz
# 39 Ausfall: sonstiges
# 40 Ausfall: Koordinaten oder Punktnummernfehler
# 50 Ausfall: WZE-Punkt aber kein BZE-Punkt
# 60 Ausfall: Level II-Punkt
# plots to exclude: everything with ID >=21
## LIVING TREES
# Status der Bestandsaufnahmeplots (x_hbi_status) --> reffers to whole assessment of trees
# -9 = Merkmal vergessen, nicht rekonstruierbar oder unbekannt - Status is unknown, was not assesed or canot be reconstructed
# -1 = Merkmal nicht erhoben  - status was not assessed
#  1 = Aufnahme erfolgte am HBI-Mittelpunkt  - the plot is at the same position as an HBI plot --> repetitive inventory
#  2 = Aufnahme erfolgte an neuem Bezugspunkt - plot in not at the same posticion as in the previous invenotry --> new inventory
#  3 = Aufnahme erfolgte an BWI-Punkt (nur BB/BY) - the plot is at the same position as an BWI plot --> repetitive inventory
## plot stati to exclude: 3 ????
## plot stati to change:
## only trees with have bestandesaufnahmeplotstatus of 2 can be used for growth calc
# status der Bestandesaufnahme --> reffers to the respective samping circle
# -9 Merkmal vergessen, nicht rekonstruierbar oder unbekannt
# -1 Merkmal nicht erhoben
# 1 Aufnahme wurde erfolgreich durchgeführt
# 2 Aufnahme war nicht möglich, keine Objekte vorhanden
# 3 Aufnahme war nicht möglich, sonst. Gründe (Störung etc.)
## plot stati to exclude: 3  --> find trees that match the CCS and remove them
## create "LT_CCS_to_exclude" dataset
## REGENERATION
# status der Verjüngungsaufnahme
# -9 Merkmal vergessen, nicht rekonstruierbar oder unbekannt
# -2 Merkmal nicht vorhanden
# -1 Merkmal nicht erhoben
#  1 Aufnahme wurde erfolgreich durchgeführt
#  2 Aufnahme war nicht möglich, keine Objekte vorhanden
#  3 Aufnahme war nicht möglich, sonst. Gründe (Störung etc.)
## plot stati to exclude: 3  --> find trees that match the CCS and remove them
## create "RT_CCS_to_exclude" dataset
## DEADWOOD
# status der Totholzaufnahme
# -9 Merkmal vergessen, nicht rekonstruierbar oder unbekannt
# -1 Merkmal nicht erhoben
# 1 Aufnahme wurde erfolgreich durchgeführt
# 2 Aufnahme war nicht möglich, keine Objekte vorhanden
# 3 Aufnahme war nicht möglich, sonst. Gründe (Störung etc.)
# 4 Aufnahme auf 0,5 der Probekreisfläche
# 5 Aufnahme auf 0,25 der Probekreisfläche
## plot stati to exclude: 3  --> find trees that match the CCS and remove them
## create "DW_CCS_to_exclude" dataset
# Thuenen Institute - Bodenschutz und Waldzustand
# Analysis of the forest inventory accompanying the peat land soil inventory
# Functions & require
# ----- 0.1. packages and functions --------------------------------------------
source(paste0(getwd(), "/scripts/01_00_functions_library.R"))
# ----- 0.2. working directory -------------------------------------------------
here::here()
out.path.BZE3 <- ("output/out_data/out_data_BZE/")
# ----- 0.4 importing data -----------------------------------------------------
## BZE 2
# this dataset contains the BZE file tit_1 which displays info about the BZE inventory in general
# so info that´s base of all sub inventories like trees, deadwood, regeneration
inv_info <- read.delim(file = here("data/input/BZE2_HBI/tit_1.csv"), sep = ",", dec = ".", stringsAsFactors=FALSE) %>% select(-c("re_form", "re_lage", "neigung", "exposition", "anmerkung"))
colnames(inv_info) <- c("plot_ID", "team", "date", "plot_inv_status")
# create column that just contains year of inventory: https://www.geeksforgeeks.org/how-to-extract-year-from-date-in-r/
inv_info$date <- as.Date(inv_info$date)
inv_info$inv_year <- as.numeric(format(inv_info$date, "%Y"))
# this line can be removed later
inv_info <- inv_info %>% mutate(inv = inv_name(inv_year))
## LIVING TREES
# this dataset contains information about the inventory of the respective individual sampling circuits as well as stand realted info like stand type & - structure
tree_inv_info <-  read.delim(file = here("data/input/BZE2_HBI/be.csv"), sep = ",", dec = ".", stringsAsFactors=FALSE) %>% # be
select(bund_nr, team,  datum,  beart, besttyp, struktur,  pk1_aufnahme,   pk2_aufnahme, pk3_aufnahme, hbi_status)
colnames(tree_inv_info) <- c("plot_ID", "team", "date", "stand_spec", "stand_type", "structure",
"CCS_5_inv_status",  "CCS_12_inv_status",  "CCS_17_inv_status" , "hbi_status")
tree_inv_info <- tree_inv_info %>% mutate(hbi_status = case_when(str_detect(plot_ID, '^9') ~ 3,
str_detect(plot_ID, '^11') ~ 3,
str_detect(plot_ID, '^12') ~ 3,
hbi_status == -9 ~ 1,
TRUE ~ hbi_status))
# create column that just contains year of inventory: https://www.geeksforgeeks.org/how-to-extract-year-from-date-in-r/
tree_inv_info$date <- as.Date(tree_inv_info$date)
tree_inv_info$inv_year <- as.numeric(format(tree_inv_info$date, "%Y"))
# this line can be removed later
tree_inv_info <- tree_inv_info %>% mutate(inv = inv_name(inv_year))
# HBI BE dataset: this dataset contains the inventory data of the tree inventory accompanying the second national soil inventory
trees_data <- read.delim(file = here("data/input/BZE2_HBI/beab.csv"), sep = ",", dec = ".")
# HBI trees
colnames(trees_data) <- c("plot_ID", "tree_ID", "tree_inventory_status", "multi_stem",  "SP_code", "age",
"age_meth", "D_mm", "DBH_h_cm", "H_dm", "C_h_dm", "azi_gon", "dist_cm", "Kraft",  "C_layer")
trees_data <- trees_data %>% dplyr::select(plot_ID,  tree_ID ,  tree_inventory_status ,  multi_stem , dist_cm ,  azi_gon ,
age ,  age_meth ,  SP_code ,  Kraft , C_layer , H_dm ,  C_h_dm , D_mm ,   DBH_h_cm )
# HBI forest edges
forest_edges <- read.delim(file = here("data/input/BZE2_HBI/be_waldraender.csv"), sep = ",", dec = ".")
colnames(forest_edges) <- c("plot_ID", "e_ID", "e_type", "e_form", "A_dist", "A_azi",  "B_dist", "B_azi", "T_dist", "T_azi") # t = turning point
## REGENERATION
# this dataset contains the inventory status, position and extend of the sampling circle satelites of the regeneration inventory of the HBI (BZE2)
RG_loc_info <- read.delim(file = here("data/input/BZE2_HBI/bej.csv"), sep = ",", dec = ".", stringsAsFactors=FALSE) %>%
select(bund_nr, pk_nr, pk_richtung, pk_dist, pk_aufnahme ,pk_maxdist)
# assign column names    # bund_nr     pk_nr      pk_richtung     pk_dist     pk_aufnahme      pk_maxdist
colnames(RG_loc_info) <- c("plot_ID", "CCS_nr", "CCS_position",  "CCS_dist", "CCS_RG_inv_status", "CCS_max_dist_cm")
# this dataset contains the plant specific inventory data of the regenertaion inventory of the HBI (BZE2), including stand and area info
RG_data <- read.delim(file = here("data/input/BZE2_HBI/bejb.csv"), sep = ",", dec = ",")
#  "bund_nr"  "pk_nr"  "lfd_nr"   "bart"  "hoehe"    "grklasse"
colnames(RG_data) <- c("plot_ID", "CCS_nr", "tree_ID", "SP_code", "H_cm", "D_class_cm")
##DEADWOOD
# deadwood inventory info
DW_inv_info <- read.delim(file = here("data/input/BZE2_HBI/be_totholz_punkt.csv"), sep = ",", dec = ".", stringsAsFactors=FALSE)
colnames(DW_inv_info) <- c("plot_ID", "CCS_DW_inv_status",  "dist_cm", "azi")
# deadwood single item data
DW_data <- read.delim(file = here("data/input/BZE2_HBI/be_totholz_liste.csv"), sep = ",", dec = ".") %>%
select( bund_nr, lfd_nr, typ, baumgruppe, anzahl,  durchmesser, laenge, zersetzung)
#  bund_nr lfd_nr typ      baumgruppe anzahl  durchmesser laenge zersetzung
colnames(DW_data) <- c("plot_ID", "tree_ID", "dw_type", "dw_sp", "count", "d_cm", "l_dm", "decay")
# 1. data prep  --------------------------------------
# 1.1. ALL - all plots & stand components ------------------------------------------------------------------------------------------------------------------------
# create a list with the BZE plots that should be excluded -----------------
# select plots that have a "Punktstatus (x_plotstatus_bze)"
plots_to_exclude <- inv_info %>%
filter(plot_inv_status >= 21 | plot_inv_status <0) %>%
# select(plot_ID) %>%
mutate(rem_reason = "whole plot excluded during inventory status sorting")
# 1.2. LIVING TREES ----------------------------------------------------------------------------------------------------------------------------------------
# 1.2.1. prepare tree data: add old data to removed trees for stock calculations later ----------------------------------------------------------------
#### this is only for post inventory data, so BZE3 it´s only here in the code to keep the scripts equal
# there may be trees that are labelled as "lost" (removed or died of but for further processing we) by their tree inventory status and by that do not have
# we still need their data from the previous inventory to calcualte their sampling circuit and assing ther species groups etc.
#  dist_cm azi_gon age age_meth SP_code Kraft C_layer H_dm C_h_dm D_mm
if(exists('trees_HBI')== TRUE){
BZE3_trees_old_data <- trees_data %>%
# selectonly trees with inventory status indicating the tree was lost or the status is unknown (eversthing other then 0 or 1)
filter(!(tree_inventory_status %in% c(0,1)))%>%
# then filter for those rows that do not contain the old data of the respective tree that was passed on from the previous inventory
# https://stackoverflow.com/questions/33520854/filtering-data-frame-based-on-na-on-multiple-columns
filter_at(vars(multi_stem:DBH_h_cm),any_vars(is.na(.))) %>%
#replace cells with NA by values from HBI for the respective plot_ID und tree_ID: https://stackoverflow.com/questions/32899580/update-rows-of-data-frame-in-r
rows_patch(trees_HBI %>%
# filter for HBI trees that have the same plot and tree ID as those trees in BZE3 with
# status != c(0, 1) and no old data passed on from HBI by semi_join
semi_join(.,
trees_data %>%
filter(!(tree_inventory_status %in% c(0,1)))%>%
filter_at(vars(multi_stem:DBH_h_cm),any_vars(is.na(.))),
by = c("plot_ID", "tree_ID")) %>%
select(-tree_inventory_status),
by = c("plot_ID", "tree_ID"))
# add trees with "removed" status for which old data was found in HBI to BZE3 trees_data
trees_data <-
trees_data %>%
# 1. remove trees that have a tree_inv_stat indicates they were lost from the trees dataset but have replacement data in
anti_join(., BZE3_trees_old_data, by = c("plot_ID", "tree_ID")) %>%
# 2. add trees that have a "tree was lost" inventory status in BZE3 but have data in: https://dplyr.tidyverse.org/reference/rows.html
rows_insert(., BZE3_trees_old_data, by = c("plot_ID", "tree_ID")) %>%
arrange(plot_ID, tree_ID)
}
# 1.2.2. prepare tree data:species & inventory names -------------------------------------------------------------------------------------------------------------------------------------
trees_data <- trees_data %>%
# join in inventory info
left_join(., tree_inv_info %>% dplyr::select("plot_ID", "inv_year", "inv"), by = "plot_ID")  %>%
# join in the species names from x_bart to ensure the Dahm DBH correction function
left_join(., SP_names_com_ID_tapeS %>%
mutate(char_code_ger_lowcase = tolower(Chr_code_ger)),
by = c("SP_code" = "char_code_ger_lowcase")) %>%
mutate(DBH_h_cm = ifelse(is.na(DBH_h_cm), 130, DBH_h_cm),        # assign DBH measuring height of 130cm when missing
# calculate corrected BDH if measuringheight != 1.3m
DBH_cm = ifelse(DBH_h_cm == 130, as.numeric(D_mm)/10, DBH_Dahm(plot_ID, D_mm, DBH_h_cm, BWI))) %>%
# asssing corect samling circle diameter according to DBH of the tree to be able to join in the right plot area
mutate(CCS_r_m = case_when(DBH_cm >= 7  & DBH_cm < 10 ~ 5.64,
DBH_cm >= 10 & DBH_cm < 30 ~ 12.62,
DBH_cm >= 30 ~ 17.84,
TRUE ~ NA)) %>%
arrange(plot_ID, tree_ID)
# check if there are no trees left that don´t have a SP_code in xBart/ SP_names_com_ID_tapeS
SP_NAs <- trees_data %>%
anti_join(SP_names_com_ID_tapeS %>%
mutate(char_code_ger_lowcase = tolower(Chr_code_ger)),
by = c("SP_code" = "char_code_ger_lowcase"))
if(nrow(SP_NAs) != 0){print("There are species names or codes in the trees dataset that do not match
the species names and codes listed in x_bart")}else{"all fine"}
# 1.2.3. filter trees in processable and removed  -----------------------------------------------------------
# save trees to be removed in other dataset
trees_removed <- trees_data %>%
# trees that don´t have a species code or are outside the widest CCS
filter(is.na(SP_code) | is.na(plot_ID) | dist_cm > 1784) %>%
mutate(rem_reason = "single LT excluded during inventory status sorting")
# remove trees without species code or plot ID from the dataset
trees_data <- trees_data %>%
# we cannot do this via antijoining "trees removed" as the species and the plot id
# that we also use to join the data will be NA for removed trees
# exclude those trees that don´t have a species code
filter(!(is.na(SP_code)) & !(is.na(plot_ID) ))%>%
# exclude trees outside the widest CCS
filter(dist_cm <= 1784)
# 1.2.3. forest edges dataset ---------------------------------------------
forest_edges <- forest_edges %>%
# join in inventory info
left_join(., tree_inv_info %>% dplyr::select("plot_ID", "inv_year", "inv"), by = "plot_ID")
# 1.3. REGENRATION --------------------------------------------------------
RG_data <- RG_data %>%
# join  in inventory info
left_join(., tree_inv_info %>% select(plot_ID, inv_year, inv), by = "plot_ID") %>%
arrange(plot_ID, CCS_nr, tree_ID)
# if the CCR no is not a an integer but a character, we have to change that
RG_loc_info <- RG_loc_info %>%
# join  in inventory info
left_join(., tree_inv_info %>% select(plot_ID, inv_year, inv), by = "plot_ID") %>%
arrange(plot_ID, CCS_nr)
# 1.4. DEADWOOD -----------------------------------------------------------
DW_data <- DW_data %>%
# join in inventory info
left_join(., tree_inv_info %>% dplyr::select("plot_ID", "inv_year", "inv"),
by = "plot_ID")
# 2. data processing ------------------------------------------------------------------------------------------------------------------------------------------------------
# 2.2. LIVING TREES -------------------------------------------------------------------------------------------------------------------------------------------------------
# 2.2.1. remove not preocessable plots and sampling circuits form tree_inventory_info dataset ------------------------------------------------------------
tree_inv_info <- tree_inv_info %>%
# pivoting B, C: https://stackoverflow.com/questions/70700654/pivot-longer-with-names-pattern-and-pairs-of-columns
pivot_longer(., "CCS_5_inv_status":"CCS_17_inv_status", names_to = "CCS_r_m", values_to = "CCS_LT_inv_status") %>%
mutate(CCS_r_m = as.numeric(case_when(CCS_r_m == "CCS_5_inv_status" ~ 5.64,
CCS_r_m == "CCS_12_inv_status" ~ 12.62,
CCS_r_m == "CCS_17_inv_status" ~ 17.84,
TRUE~ NA))) %>%
distinct() %>%
arrange(plot_ID)
# 2.2.2. create dataset with LT CCS to remove from trees data df ------------------------------------------------------------------------------------------------------------------------------------------------------------
# remove CCS that were not inventorable from the trees df and filter NFI (BWI) plots as well
LT_CCS_to_exclude <- plyr::rbind.fill(
tree_inv_info %>%
# selects plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
semi_join(., plots_to_exclude, by = "plot_ID") %>%
mutate(rem_reason = "whole plot excluded during inventory status sorting"),
# remove CCS that were not inventorable from the trees df and filter NFI (BWI) plots as well
tree_inv_info%>%
filter(!(CCS_LT_inv_status %in% c(1, 2)) |# CCS that were not inventorable
!(hbi_status %in% c(1,2)) |
inv == "warning") %>%      # plot was part of NFI not BSI
mutate(rem_reason = case_when(
!(CCS_LT_inv_status %in% c(1, 2)) ~ "LT circle excluded during inventory status sorting",
!(hbi_status %in% c(1,2)) | inv == "warning" ~ "all LT circles excluded during inventory status sorting",
TRUE ~ NA))) %>%
distinct()
# remove CCS that were not inventorable from the trees df and filter NFI (BWI) plots as well
tree_inv_info%>%
filter(!(CCS_LT_inv_status %in% c(1, 2)) |# CCS that were not inventorable
!(hbi_status %in% c(1,2)) |
inv == "warning") %>%      # plot was part of NFI not BSI
mutate(rem_reason = case_when(
!(CCS_LT_inv_status %in% c(1, 2)) ~ "LT circle excluded during inventory status sorting",
!(hbi_status %in% c(1,2)) | inv == "warning" ~ "all LT circles excluded during inventory status sorting",
TRUE ~ NA)) %>%
rows_update(., tree_inv_info %>%
# selects plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
semi_join(., plots_to_exclude, by = "plot_ID") %>%
mutate(rem_reason = "whole plot excluded during inventory status sorting"))
tree_inv_info%>%
filter(!(CCS_LT_inv_status %in% c(1, 2)) |# CCS that were not inventorable
!(hbi_status %in% c(1,2)) |
inv == "warning") %>%      # plot was part of NFI not BSI
mutate(rem_reason = case_when(
!(CCS_LT_inv_status %in% c(1, 2)) ~ "LT circle excluded during inventory status sorting",
!(hbi_status %in% c(1,2)) | inv == "warning" ~ "all LT circles excluded during inventory status sorting",
TRUE ~ NA))
plots_to_exclude
# remove CCS that were not inventorable from the trees df and filter NFI (BWI) plots as well
tree_inv_info%>%
filter(!(CCS_LT_inv_status %in% c(1, 2)) |# CCS that were not inventorable
!(hbi_status %in% c(1,2)) |
inv == "warning") %>%      # plot was part of NFI not BSI
mutate(rem_reason = case_when(
!(CCS_LT_inv_status %in% c(1, 2)) ~ "LT circle excluded during inventory status sorting",
!(hbi_status %in% c(1,2)) | inv == "warning" ~ "all LT circles excluded during inventory status sorting",
TRUE ~ NA)) %>%
rows_update(., tree_inv_info %>%
# selects plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
semi_join(., plots_to_exclude, by = c("plot_ID", "team", "date")) %>%
mutate(rem_reason = "whole plot excluded during inventory status sorting"))
tree_inv_info%>%
filter(!(CCS_LT_inv_status %in% c(1, 2)) |# CCS that were not inventorable
!(hbi_status %in% c(1,2)) |
inv == "warning") %>%      # plot was part of NFI not BSI
mutate(rem_reason = case_when(
!(CCS_LT_inv_status %in% c(1, 2)) ~ "LT circle excluded during inventory status sorting",
!(hbi_status %in% c(1,2)) | inv == "warning" ~ "all LT circles excluded during inventory status sorting",
TRUE ~ NA)) %>%
rows_update(., tree_inv_info %>%
# selects plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
semi_join(., plots_to_exclude, by = c("plot_ID", "team", "date"))
tree_inv_info%>%
tree_inv_info%>%
filter(!(CCS_LT_inv_status %in% c(1, 2)) |# CCS that were not inventorable
!(hbi_status %in% c(1,2)) |
inv == "warning") %>%      # plot was part of NFI not BSI
mutate(rem_reason = case_when(
!(CCS_LT_inv_status %in% c(1, 2)) ~ "LT circle excluded during inventory status sorting",
!(hbi_status %in% c(1,2)) | inv == "warning" ~ "all LT circles excluded during inventory status sorting",
TRUE ~ NA)) %>%
rows_update(., tree_inv_info %>%
# selects plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
semi_join(., plots_to_exclude%>%
mutate(rem_reason = "whole plot excluded during inventory status sorting"),
by = c("plot_ID", "team", "date")) )
tree_inv_info%>%
filter(!(CCS_LT_inv_status %in% c(1, 2)) |# CCS that were not inventorable
!(hbi_status %in% c(1,2)) |
inv == "warning") %>%      # plot was part of NFI not BSI
mutate(rem_reason = case_when(
!(CCS_LT_inv_status %in% c(1, 2)) ~ "LT circle excluded during inventory status sorting",
!(hbi_status %in% c(1,2)) | inv == "warning" ~ "all LT circles excluded during inventory status sorting",
TRUE ~ NA)) %>%
rows_upsert(., tree_inv_info %>%
# selects plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
semi_join(., plots_to_exclude%>%
mutate(rem_reason = "whole plot excluded during inventory status sorting"),
by = c("plot_ID", "team", "date")) )
tree_inv_info%>%
filter(!(CCS_LT_inv_status %in% c(1, 2)) |# CCS that were not inventorable
!(hbi_status %in% c(1,2)) |
inv == "warning") %>%      # plot was part of NFI not BSI
mutate(rem_reason = case_when(
!(CCS_LT_inv_status %in% c(1, 2)) ~ "LT circle excluded during inventory status sorting",
!(hbi_status %in% c(1,2)) | inv == "warning" ~ "all LT circles excluded during inventory status sorting",
TRUE ~ NA)) %>%
rows_insert(., tree_inv_info %>%
# selects plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
semi_join(., plots_to_exclude%>%
mutate(rem_reason = "whole plot excluded during inventory status sorting"),
by = c("plot_ID", "team", "date")) )
# remove CCS that were not inventorable from the trees df and filter NFI (BWI) plots as well
tree_inv_info%>%
filter(!(CCS_LT_inv_status %in% c(1, 2)) |# CCS that were not inventorable
!(hbi_status %in% c(1,2)) |
inv == "warning") %>%      # plot was part of NFI not BSI
mutate(rem_reason = case_when(
!(CCS_LT_inv_status %in% c(1, 2)) ~ "LT circle excluded during inventory status sorting",
!(hbi_status %in% c(1,2)) | inv == "warning" ~ "all LT circles excluded during inventory status sorting",
TRUE ~ NA)) %>%
rows_update(., tree_inv_info %>%
# selects plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
semi_join(., plots_to_exclude%>%
mutate(rem_reason = "whole plot excluded during inventory status sorting"),
by = c("plot_ID", "team", "date")) )
plots_to_exclude
tree_inv_info%>%
filter(!(CCS_LT_inv_status %in% c(1, 2)) |# CCS that were not inventorable
!(hbi_status %in% c(1,2)) |
inv == "warning") %>%      # plot was part of NFI not BSI
mutate(rem_reason = case_when(
!(CCS_LT_inv_status %in% c(1, 2)) ~ "LT circle excluded during inventory status sorting",
!(hbi_status %in% c(1,2)) | inv == "warning" ~ "all LT circles excluded during inventory status sorting",
TRUE ~ NA)) %>%
rows_update(., tree_inv_info %>%
# selects plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
semi_join(., plots_to_exclude,
by = c("plot_ID", "team", "date")) )
plyr::rbind.fill(
tree_inv_info %>%
# selects plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
semi_join(., plots_to_exclude, by = "plot_ID") %>%
mutate(rem_reason = "whole plot excluded during inventory status sorting"),
# remove CCS that were not inventorable from the trees df and filter NFI (BWI) plots as well
tree_inv_info%>%
filter(!(CCS_LT_inv_status %in% c(1, 2)) |# CCS that were not inventorable
!(hbi_status %in% c(1,2)) |
inv == "warning") %>%      # plot was part of NFI not BSI
mutate(rem_reason = case_when(
!(CCS_LT_inv_status %in% c(1, 2)) ~ "LT circle excluded during inventory status sorting",
!(hbi_status %in% c(1,2)) | inv == "warning" ~ "all LT circles excluded during inventory status sorting",
TRUE ~ NA))) %>%
distinct()

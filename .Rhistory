x.2 <- intersection_line_circle(b0, b1, c.x0, c.y0,  c.rmax, coordinate = "x2") # this is: easting, longitude, RW
y.2 <- intersection_line_circle(b0, b1 ,c.x0, c.y0,  c.rmax, coordinate = "y2") # this is: northing, latitude, HW
# for edge form 1 we have to consider that the square has to be directed into the direction of the smaller half of the circle
# calculate coordiantes of the middle of thie line between
x_m_line = (x.1 + x.2)/2
y_m_line = (y.1 + y.2)/2
# calculate the parameters of the equation between the middle of the line and the centre of the circle
b1_MC = slope(c.x0, c.y0, x_m_line, y_m_line)
b0_MC = intercept(c.x0, c.y0, x_m_line, y_m_line)
# calcualte the x corrdiante of the interception of the line between M and the centre of the cirle and the circle at the given radio
X1_inter_MC = intersection_line_circle(b0_MC, b1_MC,  c.x0, c.y0,  c.rmax,  coordinate = "x1")
X2_inter_MC = intersection_line_circle(b0_MC, b1_MC,  c.x0, c.y0,  c.rmax,  coordinate = "x2")
# insert the intersection x corodinate in the line function to get the respective y coordinate
y1_inter_MC = intersection_line_circle(b0_MC, b1_MC,  c.x0, c.y0,  c.rmax,  coordinate = "y1")
y2_inter_MC = intersection_line_circle(b0_MC, b1_MC,  c.x0, c.y0,  c.rmax,  coordinate = "y2")
# distance between the intersections (inter_MC_1, inter_MC_2) to M on the line
dist_C_inter_1_MC = distance(X1_inter_MC, y1_inter_MC, x_m_line, y_m_line)
dist_C_inter_2_MC = distance(X2_inter_MC, y2_inter_MC, x_m_line, y_m_line)
# find the x and y coordinate of the intersection on the shorter side , which is the side to exlcude from the plot
X_inter_MC_shorter_side = ifelse(dist_C_inter_1_MC < dist_C_inter_2_MC, X1_inter_MC, X2_inter_MC)
Y_inter_MC_shorter_side = ifelse(dist_C_inter_1_MC < dist_C_inter_2_MC, y1_inter_MC, y2_inter_MC)
# creating the polar coordiantes of a turning point of a triangle by selecting the intersection of the
# line from the middle of the AB.inter-ray and the circle center (MC_line) with
# the 60m radius at the "shorter side" so the intersection of the MC_line with a 60m radius that has le lest distance to the MC point on the AB.inter-ray
turning.east <- X_inter_MC_shorter_side   # + my.center.easting
turning.north <-  Y_inter_MC_shorter_side # + my.center.northing
# UTM coordiantes of corner points
x1.east <- x.1   # + my.center.easting
y1.north <- y.1  # + my.center.northing
x2.east <- x.2   # + my.center.easting
y2.north <- y.2  # + my.center.northing
# create dataframe that holds coordinates of the intersections of the AB line with a 60m radius and the turning pint of a diagonal line through the AB line with a 60m radius circle
triangle.e1.df <- as.data.frame(cbind("lon" = c(turning.east, x1.east, x2.east, turning.east),
"lat" = c(turning.north, y1.north, y2.north,  turning.north),
"plot_ID" = c(my.plot.id, my.plot.id, my.plot.id, my.plot.id),
"e_ID" = c(my.e.id, my.e.id, my.e.id, my.e.id),
"inv_year" = c(my.inv.year, my.inv.year, my.inv.year, my.inv.year)))
# creating polygones in sf: https://stackoverflow.com/questions/61215968/creating-sf-polygons-from-a-dataframe
triangle.e1.poly <-  sfheaders::sf_polygon(obj = triangle.e1.df
, x = "lon"
, y = "lat"
, polygon_id = "e_ID")
## georef
## assign crs
# my.utm.epsg <-  paste0("+proj=utm +zone=", pick_utm(my.center.easting)," ", "+datum=WGS84 +units=m +no_defs +type=crs")
## assing crs
# sf::st_crs(triangle.e1.poly) <- my.utm.epsg
print(plot(triangle.e1.poly, main = my.plot.id))
#save polygones in list
triangle.e1.list.nogeo[[i]] <- c("plot_ID" = my.plot.id, "inv_year" = my.inv.year, triangle.e1.poly)
# save coordiantes of polygones in list
triangle.e1.coords.nogeo[[i]] <- triangle.e1.df
} # closing loop for square polys of edge form 1
triangle.e1.list.final.nogeo <- rbindlist(triangle.e1.list.nogeo, fill=TRUE)
triangle.e1.poly.df.nogeo <- as.data.frame(triangle.e1.list.final.nogeo) %>% mutate("e_form" = 1)
triangle.e1.poly.df.nogeo
triangle.e1.coords.list.nogeo <- rbindlist(triangle.e1.coords.nogeo)
triangle.e1.coords.df.nogeo <- as.data.frame(triangle.e1.coords.list.nogeo) %>%
mutate("e_form" = 1)
triangle.e1.coords.df.nogeo
## loop to create list of polygones for edge form 1
forest_edges.man.sub.e2.nogeo <- forest_edges.man %>%
filter(e_form == 2) %>%  # nrow = 21
filter(inter_status_AT_17 == "two I" | inter_status_BT_17 == "two I") # %>%
triangle.e2.list.nogeo <- vector("list", length = length(forest_edges.man.sub.e2.nogeo$plot_ID) )
triangle.e2.coords.nogeo <- vector("list", length = length(forest_edges.man.sub.e2.nogeo$plot_ID))
# select plot ID accordint to positioin in the list
my.plot.id <- forest_edges.man.sub.e2.nogeo[i, "plot_ID"]
my.plot.id
i = 1
# select plot ID accordint to positioin in the list
my.plot.id <- forest_edges.man.sub.e2.nogeo[i, "plot_ID"]
my.plot.id
my.e.id <- forest_edges.man.sub.e2.nogeo[i, "e_ID"]
my.e.form <- forest_edges.man.sub.e2.nogeo[i, "e_form"]
my.inv.year <- forest_edges.man.sub.e2.nogeo[i, "inv_year"]
my.inv.year
# circle data
c.x0 = 0
c.y0 = 0
c.r0 = 17.84
c.rmax = 300
# extract polar coordiantes of forest edge
# point A
dist.A <- forest_edges.man.sub.e2.nogeo[i, "A_dist"]
azi.A <- forest_edges.man.sub.e2.nogeo[i, "A_azi"]
x.A <- dist.A*sin(azi.A)   # longitude, easting, RW, X
y.A <- dist.A*cos(azi.A)   # latitude, northing, HW, y
# point B
dist.B <- forest_edges.man.sub.e2.nogeo[i, "B_dist"]
azi.B <- forest_edges.man.sub.e2.nogeo[i, "B_azi"]
x.B <- dist.B*sin(azi.B)   # longitude, easting, RW, X
y.B <- dist.B*cos(azi.B)   # latitude, northing, HW, y
# point T
dist.T <- forest_edges.man.sub.e2.nogeo[i, "T_dist"]
azi.T <- forest_edges.man.sub.e2.nogeo[i, "T_azi"]
x.T <- dist.T*sin(azi.T)   # longitude, easting, RW, X
y.T <- dist.T*cos(azi.T)   # latitude, northing, HW, y
b0.AT = intercept(x.T, y.T, x.A, y.A)
b1.AT = slope(x.T, y.T, x.A, y.A)
b0.BT = intercept(x.T, y.T, x.B, y.B)
b1.BT = slope(x.T, y.T, x.B, y.B)
# select polar coordiantes of the points of the triangle corners via "inter_for_triangle"-function
# for AT side
AT.x <- inter.for.triangle(b0.AT, b1.AT,c.x0, c.y0, c.rmax, x.A, y.A, x.T, y.T, coordinate = "x")                              # longitude, easting, RW, X
AT.y <- inter.for.triangle(b0.AT, b1.AT, c.x0, c.y0, c.rmax, x.A, y.A, x.T, y.T, coordinate = "y")                              # latitude, northing, HW, y
# for BT side
BT.x <- inter.for.triangle(b0.BT, b1.BT, c.x0, c.y0, c.rmax, x.B, y.B, x.T, y.T, coordinate = "x")                              # longitude, easting, RW, X
BT.y <- inter.for.triangle(b0.BT, b1.BT, c.x0, c.y0, c.rmax, x.B, y.B, x.T, y.T, coordinate = "y")                              # latitude, northing, HW, y
#calculate UTM coordiantes of triangle corners
T.east <- x.T        # + my.center.easting                             # longitude, easting, RW, X
T.north <- y.T       # + my.center.northing                           # latitude, northing, HW, y
AT.x.east <-  AT.x   # + my.center.easting                        # longitude, easting, RW, X
AT.y.north <- AT.y   # + my.center.northing                       # latitude, northing, HW, y
BT.x.east <- BT.x    # + my.center.easting                        # longitude, easting, RW, X
BT.y.north <- BT.y   # + my.center.northing                       # latitude, northing, HW, y
# create dataframe with triangle corner UTM coordiantes
triangle.e2.df <- as.data.frame(cbind("lon" = c(T.east, AT.x.east, BT.x.east, T.east),       # longitude, easting, RW, X
"lat" = c(T.north, AT.y.north, BT.y.north, T.north),   # latitude, northing, HW, y
"plot_ID" =  c(my.plot.id, my.plot.id, my.plot.id, my.plot.id),
"e_ID" = c(my.e.id, my.e.id, my.e.id, my.e.id ),
"inv_year" = c(my.inv.year,my.inv.year,my.inv.year,my.inv.year)))
# createa polygone with triangle corners via sf package: https://r-spatial.github.io/sf/reference/st.html
triangle.e2.poly <- sfheaders::sf_polygon(obj = triangle.e2.df
, x = "lon"
, y = "lat"
, polygon_id = "e_ID")
# print triangle
print(plot(triangle.e2.poly$geometry, main = my.plot.id))
# save polygones in list
triangle.e2.list.nogeo[[i]] <- c("plot_ID" = my.plot.id, "inv_year" = my.inv.year, triangle.e2.poly)
triangle.e2.list.nogeo[[i]]
## loop to create list of polygones for edge form 1
forest_edges.man.sub.e2.nogeo <- forest_edges.man %>%
filter(e_form == 2) %>%  # nrow = 21
filter(inter_status_AT_17 == "two I" | inter_status_BT_17 == "two I") # %>%
triangle.e2.list.nogeo <- vector("list", length = length(forest_edges.man.sub.e2.nogeo$plot_ID) )
triangle.e2.coords.nogeo <- vector("list", length = length(forest_edges.man.sub.e2.nogeo$plot_ID))
for(i in 1:length(forest_edges.man.sub.e2.nogeo$plot_ID) ) {
# i = 1
# i = which(grepl(50023, forest_edges.man.sub.e2.nogeo$plot_ID)
# select plot ID accordint to positioin in the list
my.plot.id <- forest_edges.man.sub.e2.nogeo[i, "plot_ID"]
my.e.id <- forest_edges.man.sub.e2.nogeo[i, "e_ID"]
my.e.form <- forest_edges.man.sub.e2.nogeo[i, "e_form"]
my.inv.year <- forest_edges.man.sub.e2.nogeo[i, "inv_year"]
## select UTM corrdinates of the plot center
# my.center.easting <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "RW_MED"]
# my.center.northing <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "HW_MED"]
# circle data
c.x0 = 0
c.y0 = 0
c.r0 = 17.84
c.rmax = 300
# extract polar coordiantes of forest edge
# point A
dist.A <- forest_edges.man.sub.e2.nogeo[i, "A_dist"]
azi.A <- forest_edges.man.sub.e2.nogeo[i, "A_azi"]
x.A <- dist.A*sin(azi.A)   # longitude, easting, RW, X
y.A <- dist.A*cos(azi.A)   # latitude, northing, HW, y
# point B
dist.B <- forest_edges.man.sub.e2.nogeo[i, "B_dist"]
azi.B <- forest_edges.man.sub.e2.nogeo[i, "B_azi"]
x.B <- dist.B*sin(azi.B)   # longitude, easting, RW, X
y.B <- dist.B*cos(azi.B)   # latitude, northing, HW, y
# point T
dist.T <- forest_edges.man.sub.e2.nogeo[i, "T_dist"]
azi.T <- forest_edges.man.sub.e2.nogeo[i, "T_azi"]
x.T <- dist.T*sin(azi.T)   # longitude, easting, RW, X
y.T <- dist.T*cos(azi.T)   # latitude, northing, HW, y
b0.AT = intercept(x.T, y.T, x.A, y.A)
b1.AT = slope(x.T, y.T, x.A, y.A)
b0.BT = intercept(x.T, y.T, x.B, y.B)
b1.BT = slope(x.T, y.T, x.B, y.B)
# select polar coordiantes of the points of the triangle corners via "inter_for_triangle"-function
# for AT side
AT.x <- inter.for.triangle(b0.AT, b1.AT,c.x0, c.y0, c.rmax, x.A, y.A, x.T, y.T, coordinate = "x")                              # longitude, easting, RW, X
AT.y <- inter.for.triangle(b0.AT, b1.AT, c.x0, c.y0, c.rmax, x.A, y.A, x.T, y.T, coordinate = "y")                              # latitude, northing, HW, y
# for BT side
BT.x <- inter.for.triangle(b0.BT, b1.BT, c.x0, c.y0, c.rmax, x.B, y.B, x.T, y.T, coordinate = "x")                              # longitude, easting, RW, X
BT.y <- inter.for.triangle(b0.BT, b1.BT, c.x0, c.y0, c.rmax, x.B, y.B, x.T, y.T, coordinate = "y")                              # latitude, northing, HW, y
#calculate UTM coordiantes of triangle corners
T.east <- x.T        # + my.center.easting                             # longitude, easting, RW, X
T.north <- y.T       # + my.center.northing                           # latitude, northing, HW, y
AT.x.east <-  AT.x   # + my.center.easting                        # longitude, easting, RW, X
AT.y.north <- AT.y   # + my.center.northing                       # latitude, northing, HW, y
BT.x.east <- BT.x    # + my.center.easting                        # longitude, easting, RW, X
BT.y.north <- BT.y   # + my.center.northing                       # latitude, northing, HW, y
# create dataframe with triangle corner UTM coordiantes
triangle.e2.df <- as.data.frame(cbind("lon" = c(T.east, AT.x.east, BT.x.east, T.east),       # longitude, easting, RW, X
"lat" = c(T.north, AT.y.north, BT.y.north, T.north),   # latitude, northing, HW, y
"plot_ID" =  c(my.plot.id, my.plot.id, my.plot.id, my.plot.id),
"e_ID" = c(my.e.id, my.e.id, my.e.id, my.e.id ),
"inv_year" = c(my.inv.year,my.inv.year,my.inv.year,my.inv.year)))
# createa polygone with triangle corners via sf package: https://r-spatial.github.io/sf/reference/st.html
triangle.e2.poly <- sfheaders::sf_polygon(obj = triangle.e2.df
, x = "lon"
, y = "lat"
, polygon_id = "e_ID")
## select crs
# my.utm.epsg <-  paste0("+proj=utm +zone=", pick_utm(my.center.easting)," ", "+datum=WGS84 +units=m +no_defs +type=crs")
## assing crs
# sf::st_crs(triangle.e2.poly) <- my.utm.epsg
# print triangle
print(plot(triangle.e2.poly$geometry, main = my.plot.id))
# save polygones in list
triangle.e2.list.nogeo[[i]] <- c("plot_ID" = my.plot.id, "inv_year" = my.inv.year, triangle.e2.poly)
# save coordiantes of polygones in list
triangle.e2.coords.nogeo[[i]] <- triangle.e2.df
}
# list of polygones
triangle.e2.list.final.nogeo <- rbindlist(triangle.e2.list.nogeo)
triangle.e2.poly.df.nogeo <- as.data.frame(triangle.e2.list.final.nogeo) %>% mutate("e_form" = 2)
#list of coordiantes of triangle.e2 polygones
triangle.e2.coords.list.nogeo <- rbindlist(triangle.e2.coords.nogeo)
triangle.e2.coords.df.nogeo <- as.data.frame(triangle.e2.coords.list.nogeo) %>%  mutate("e_form" = 2)
triangle.e2.poly.df.nogeo
triangle.e2.coords.df.nogeo
# dataprep for loop
# bind polygone dataframes together
edge.poly.df.nogeo <- rbind(triangle.e1.poly.df.nogeo, triangle.e2.poly.df.nogeo) # rows: 83
# createa dataframe with plots that have only one forest edges
forest_edges.man.sub.1.edge.nogeo <- forest_edges.man %>% # rows:84
# select only plots with a known edge form and for edge 2 only those that actually intersect the 17m circle
filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%  # rows:81
# remove plots that have two edges
anti_join(forest_edges.man %>%  filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%
group_by(plot_ID) %>% summarise(n = n()) %>% filter(n > 1) %>% select(plot_ID), by = "plot_ID")#  %>% # 14 plots with 2 edges --> 28 rows -> 53 left
edges.list.nogeo <- vector("list", length = length(unique(forest_edges.man.sub.1.edge.nogeo$plot_ID)))
inter.poly.list.nogeo <- vector("list", length = length(unique(forest_edges.man.sub.1.edge.nogeo$plot_ID)))
#inter.poly.NA.list <- vector("list", length = length(unique(forest_edges.man.sub.1.edge$plot_ID)))
remaining.circle.poly.list.nogeo <- vector("list", length = length(unique(forest_edges.man.sub.1.edge.nogeo$plot_ID)))
remaining.circle.multipoly.list.nogeo <- vector("list", length = length(unique(forest_edges.man.sub.1.edge.nogeo$plot_ID)))
i = 4
# select plot ID of the respective circle
my.plot.id <- forest_edges.man.sub.1.edge.nogeo[i, "plot_ID"]
my.plot.id
my.e.form <- edge.poly.df.nogeo$e_form[edge.poly.df.nogeo$plot_ID == my.plot.id]
my.e.form
my.e.id <- edge.poly.df.nogeo$e_ID[edge.poly.df.nogeo$plot_ID == my.plot.id]
my.e.id
my.inv.year <- forest_edges.man.sub.1.edge.nogeo[i, "inv_year"]
my.inv.year
# circle data
c.x0 = 0 # + my.center.easting
c.y0 = 0 # + my.center.northing
c.r3 = 17.84
c.r2 = 12.62
c.r1 = 5.64
center.df<- as.data.frame(cbind("lon" = c.x0, "lat" = c.y0))
# build polygon (circlular buffer) around center point
circle.pt <- sf::st_as_sf(center.df, coords = c("lon", "lat"))
## assing crs to cirlce corodiantes
# sf::st_crs(circle.pt) <- my.utm.epsg
circle.17 <- sf::st_buffer(circle.pt, c.r3)
circle.12 <- sf::st_buffer(circle.pt, c.r2)
circle.5 <- sf::st_buffer(circle.pt, c.r1)
## select the respective polygones the circle is intersected by
my.poly <- sf::st_as_sf(edge.poly.df.nogeo %>% filter(plot_ID == my.plot.id))
## select the respective polygones the circle is intersected by
my.poly <- sf::st_as_sf(edge.poly.df.nogeo %>% filter(plot_ID == my.plot.id & inv_year == my.inv.year))
# print the cirlce and edge polygone
print(plot(circle.17, main = paste0("plot:", " ", my.plot.id, ",", " ", "e_form:"," ", my.e.form)),
plot(my.poly, col = 0, add = T))
#### 17m circle
# calculate intersection for 17m circle
inter.poly.17  <- sf::st_intersection(circle.17, my.poly)
inter.status.poly.17 <- ifelse(nrow(inter.poly.17) == 0, "no intersections",
ifelse(my.e.form == 1 & inter.poly.17$geometry == circle.17$geometry,  "no intersections",
ifelse(my.e.form == 2 & inter.poly.17$geometry == circle.17$geometry, "fully covering circle",
"partly intersecting")))
# this is just to remove all the additional attributes from the intersection polygone
#inter.poly  <- sf::st_intersection(circle.17, st_geometry(my.poly))
# if the ednge covers all of the circle remaining, the inter.polygone its going to be set to 0 so we know there are no direct intersections
inter.poly.17 <- if(isTRUE(inter.poly.17) && inter.poly.17$geometry == circle.17$geometry){inter.poly.17 <- data.frame()}else{inter.poly.17}
# if the edge-circle intersection is equal to 0 (so there is no intersection) return the whole cirlce as remaining circle area, else calculate the remaining circle by decuctng the intersection are from the circle area
remaining.circle.poly.17  <- if(isTRUE(nrow(inter.poly.17)==0)){circle.17}else{sf::st_difference(circle.17, inter.poly.17)}
plot(remaining.circle.poly.17)
# calculate area
# intersection
inter.area.17 <- ifelse(nrow(inter.poly.17) == 0, 0, sf::st_area(inter.poly.17))
#remaining circle
remaining.circle.area.17 <- ifelse(nrow(remaining.circle.poly.17) == 0, 0, sf::st_area(remaining.circle.poly.17))
my.plot.id <- forest_edges.man.sub.e2.nogeo[i, "plot_ID"]
my.e.id <- forest_edges.man.sub.e2.nogeo[i, "e_ID"]
my.e.form <- forest_edges.man.sub.e2.nogeo[i, "e_form"]
my.inv.year <- forest_edges.man.sub.e2.nogeo[i, "inv_year"]
## select UTM corrdinates of the plot center
# my.center.easting <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "RW_MED"]
# my.center.northing <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "HW_MED"]
# circle data
c.x0 = 0
c.y0 = 0
c.r0 = 17.84
c.rmax = 300
# extract polar coordiantes of forest edge
# point A
dist.A <- forest_edges.man.sub.e2.nogeo[i, "A_dist"]
azi.A <- forest_edges.man.sub.e2.nogeo[i, "A_azi"]
x.A <- dist.A*sin(azi.A)   # longitude, easting, RW, X
y.A <- dist.A*cos(azi.A)   # latitude, northing, HW, y
# point B
dist.B <- forest_edges.man.sub.e2.nogeo[i, "B_dist"]
azi.B <- forest_edges.man.sub.e2.nogeo[i, "B_azi"]
x.B <- dist.B*sin(azi.B)   # longitude, easting, RW, X
y.B <- dist.B*cos(azi.B)   # latitude, northing, HW, y
# point T
dist.T <- forest_edges.man.sub.e2.nogeo[i, "T_dist"]
azi.T <- forest_edges.man.sub.e2.nogeo[i, "T_azi"]
x.T <- dist.T*sin(azi.T)   # longitude, easting, RW, X
y.T <- dist.T*cos(azi.T)   # latitude, northing, HW, y
b0.AT = intercept(x.T, y.T, x.A, y.A)
b1.AT = slope(x.T, y.T, x.A, y.A)
b0.BT = intercept(x.T, y.T, x.B, y.B)
b1.BT = slope(x.T, y.T, x.B, y.B)
# select polar coordiantes of the points of the triangle corners via "inter_for_triangle"-function
# for AT side
AT.x <- inter.for.triangle(b0.AT, b1.AT,c.x0, c.y0, c.rmax, x.A, y.A, x.T, y.T, coordinate = "x")                              # longitude, easting, RW, X
AT.y <- inter.for.triangle(b0.AT, b1.AT, c.x0, c.y0, c.rmax, x.A, y.A, x.T, y.T, coordinate = "y")                              # latitude, northing, HW, y
# for BT side
BT.x <- inter.for.triangle(b0.BT, b1.BT, c.x0, c.y0, c.rmax, x.B, y.B, x.T, y.T, coordinate = "x")                              # longitude, easting, RW, X
BT.y <- inter.for.triangle(b0.BT, b1.BT, c.x0, c.y0, c.rmax, x.B, y.B, x.T, y.T, coordinate = "y")                              # latitude, northing, HW, y
#calculate UTM coordiantes of triangle corners
T.east <- x.T        # + my.center.easting                             # longitude, easting, RW, X
T.north <- y.T       # + my.center.northing                           # latitude, northing, HW, y
AT.x.east <-  AT.x   # + my.center.easting                        # longitude, easting, RW, X
AT.y.north <- AT.y   # + my.center.northing                       # latitude, northing, HW, y
BT.x.east <- BT.x    # + my.center.easting                        # longitude, easting, RW, X
BT.y.north <- BT.y   # + my.center.northing                       # latitude, northing, HW, y
# create dataframe with triangle corner UTM coordiantes
triangle.e2.df <- as.data.frame(cbind("lon" = c(T.east, AT.x.east, BT.x.east, T.east),       # longitude, easting, RW, X
"lat" = c(T.north, AT.y.north, BT.y.north, T.north),   # latitude, northing, HW, y
"plot_ID" =  c(my.plot.id, my.plot.id, my.plot.id, my.plot.id),
"e_ID" = c(my.e.id, my.e.id, my.e.id, my.e.id ),
"inv_year" = c(my.inv.year,my.inv.year,my.inv.year,my.inv.year)))
# createa polygone with triangle corners via sf package: https://r-spatial.github.io/sf/reference/st.html
triangle.e2.poly <- sfheaders::sf_polygon(obj = triangle.e2.df
, x = "lon"
, y = "lat"
, polygon_id = "e_ID")
## select crs
# my.utm.epsg <-  paste0("+proj=utm +zone=", pick_utm(my.center.easting)," ", "+datum=WGS84 +units=m +no_defs +type=crs")
## assing crs
# sf::st_crs(triangle.e2.poly) <- my.utm.epsg
# print triangle
print(plot(triangle.e2.poly$geometry, main = my.plot.id))
# save polygones in list
triangle.e2.list.nogeo[[i]] <- c("plot_ID" = my.plot.id, "inv_year" = my.inv.year, triangle.e2.poly)
# save coordiantes of polygones in list
triangle.e2.coords.nogeo[[i]] <- triangle.e2.df
}
# list of polygones
triangle.e2.list.final.nogeo <- rbindlist(triangle.e2.list.nogeo)
triangle.e2.poly.df.nogeo <- as.data.frame(triangle.e2.list.final.nogeo) %>% mutate("e_form" = 2)
#list of coordiantes of triangle.e2 polygones
triangle.e2.coords.list.nogeo <- rbindlist(triangle.e2.coords.nogeo)
triangle.e2.coords.df.nogeo <- as.data.frame(triangle.e2.coords.list.nogeo) %>%  mutate("e_form" = 2)
# 3.2.1.3. loop for intersections between circles and edges -------------------------------------------------------------------------------------------------------------------------------------
# 3.2.1.3.1. loop for intersections for plots with only one edge  -------------------------------------------------------------------------------------------------------------------------------
# dataprep for loop
# bind polygone dataframes together
edge.poly.df.nogeo <- rbind(triangle.e1.poly.df.nogeo, triangle.e2.poly.df.nogeo) # rows: 83
# createa dataframe with plots that have only one forest edges
forest_edges.man.sub.1.edge.nogeo <- forest_edges.man %>% # rows:84
# select only plots with a known edge form and for edge 2 only those that actually intersect the 17m circle
filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%  # rows:81
# remove plots that have two edges
anti_join(forest_edges.man %>%  filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%
group_by(plot_ID) %>% summarise(n = n()) %>% filter(n > 1) %>% select(plot_ID), by = "plot_ID")#  %>% # 14 plots with 2 edges --> 28 rows -> 53 left
## remove plots that do now have a corresponding center coordiante in the HBI loc document
# semi_join(HBI_loc %>% filter(!is.na( RW_MED) & !is.na(HW_MED)) %>%  select(plot_ID)  %>% distinct(), by = "plot_ID") # nrow = 52 --> there is 1 plots without corresponding
# prepare output datasets
edges.list.nogeo <- vector("list", length = length(unique(forest_edges.man.sub.1.edge.nogeo$plot_ID)))
inter.poly.list.nogeo <- vector("list", length = length(unique(forest_edges.man.sub.1.edge.nogeo$plot_ID)))
#inter.poly.NA.list <- vector("list", length = length(unique(forest_edges.man.sub.1.edge$plot_ID)))
remaining.circle.poly.list.nogeo <- vector("list", length = length(unique(forest_edges.man.sub.1.edge.nogeo$plot_ID)))
remaining.circle.multipoly.list.nogeo <- vector("list", length = length(unique(forest_edges.man.sub.1.edge.nogeo$plot_ID)))
# loop for intersection of all edge triablge polygoens woth their respective sampling cirlce for plots with one edge only
for (i in 1:length(unique(forest_edges.man.sub.1.edge.nogeo$plot_ID))){
# i = 48
#i = which(grepl(50133, (forest_edges.man.sub.1.edge.nogeo$plot_ID)))
# select plot ID of the respective circle
my.plot.id <- forest_edges.man.sub.1.edge.nogeo[i, "plot_ID"]
my.e.form <- edge.poly.df.nogeo$e_form[edge.poly.df.nogeo$plot_ID == my.plot.id]
my.e.id <- edge.poly.df.nogeo$e_ID[edge.poly.df.nogeo$plot_ID == my.plot.id]
my.inv.year <- forest_edges.man.sub.1.edge.nogeo[i, "inv_year"]
##  select UTM corrdinates of the plot center
# my.center.easting <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "RW_MED"]
# my.center.northing <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "HW_MED"]
## select crs
# my.utm.epsg <-  paste0("+proj=utm +zone=", pick_utm(my.center.easting)," ", "+datum=WGS84 +units=m +no_defs +type=crs")
# circle data
c.x0 = 0 # + my.center.easting
c.y0 = 0 # + my.center.northing
c.r3 = 17.84
c.r2 = 12.62
c.r1 = 5.64
center.df<- as.data.frame(cbind("lon" = c.x0, "lat" = c.y0))
# build polygon (circlular buffer) around center point
circle.pt <- sf::st_as_sf(center.df, coords = c("lon", "lat"))
## assing crs to cirlce corodiantes
# sf::st_crs(circle.pt) <- my.utm.epsg
circle.17 <- sf::st_buffer(circle.pt, c.r3)
circle.12 <- sf::st_buffer(circle.pt, c.r2)
circle.5 <- sf::st_buffer(circle.pt, c.r1)
## select the respective polygones the circle is intersected by
my.poly <- sf::st_as_sf(edge.poly.df.nogeo %>% filter(plot_ID == my.plot.id & inv_year == my.inv.year))
# print the cirlce and edge polygone
print(plot(circle.17, main = paste0("plot:", " ", my.plot.id, ",", " ", "e_form:"," ", my.e.form)),
plot(my.poly, col = 0, add = T))
#### 17m circle
# calculate intersection for 17m circle
inter.poly.17  <- sf::st_intersection(circle.17, my.poly)
inter.status.poly.17 <- ifelse(nrow(inter.poly.17) == 0, "no intersections",
ifelse(my.e.form == 1 & inter.poly.17$geometry == circle.17$geometry,  "no intersections",
ifelse(my.e.form == 2 & inter.poly.17$geometry == circle.17$geometry, "fully covering circle",
"partly intersecting")))
# this is just to remove all the additional attributes from the intersection polygone
#inter.poly  <- sf::st_intersection(circle.17, st_geometry(my.poly))
# if the ednge covers all of the circle remaining, the inter.polygone its going to be set to 0 so we know there are no direct intersections
inter.poly.17 <- if(isTRUE(inter.poly.17) && inter.poly.17$geometry == circle.17$geometry){inter.poly.17 <- data.frame()}else{inter.poly.17}
# if the edge-circle intersection is equal to 0 (so there is no intersection) return the whole cirlce as remaining circle area, else calculate the remaining circle by decuctng the intersection are from the circle area
remaining.circle.poly.17  <- if(isTRUE(nrow(inter.poly.17)==0)){circle.17}else{sf::st_difference(circle.17, inter.poly.17)}
# plot(remaining.circle.poly.17)
# calculate area
# intersection
inter.area.17 <- ifelse(nrow(inter.poly.17) == 0, 0, sf::st_area(inter.poly.17))
#remaining circle
remaining.circle.area.17 <- ifelse(nrow(remaining.circle.poly.17) == 0, 0, sf::st_area(remaining.circle.poly.17))
# create area dataframe for areas
inter.area.df.17 <- as.data.frame(cbind("plot_ID" = c(my.plot.id, my.plot.id),
"e_ID" = c(my.e.id,  0),
"inv_year" = c(my.inv.year, my.inv.year),
# "e_form" = c(my.e.form, 0),
#"shape" = c("edge", "circle"),
"CCS_r_m" = c(c.r3, c.r3), "inter_stat" = c(inter.status.poly.17, 0),
"area_m2" = c(inter.area.17, remaining.circle.area.17)))
##### 12m circle
# calculate intersection for 17m circle
inter.poly.12  <- sf::st_intersection(circle.12, my.poly)
inter.status.poly.12 <- ifelse(nrow(inter.poly.12) == 0, "no intersections",
ifelse(my.e.form == 1 & inter.poly.12$geometry == circle.12$geometry,  "no intersections",
ifelse(my.e.form == 2 & inter.poly.12$geometry == circle.12$geometry, "fully covering circle",
"partly intersecting")))
# this is just to remove all the additional attributes from the intersection polygone
#inter.poly  <- sf::st_intersection(circle.17, st_geometry(my.poly))
# if the ednge covers all of the circle remaining, the inter.polygone its going to be set to 0 so we know there are no direct intersections
inter.poly.12 <- if(isTRUE(inter.poly.12) && inter.poly.12$geometry == circle.12$geometry){inter.poly.12 <- data.frame()}else{inter.poly.12}
# if the edge-circle intersection is equal to 0 (so there is no intersection) return the whole cirlce as remaining circle area, else calculate the remaining circle by decuctng the intersection are from the circle area
remaining.circle.poly.12  <- if(isTRUE(nrow(inter.poly.12)==0)){circle.12}else{sf::st_difference(circle.12, inter.poly.12)}
# plot(remaining.circle.poly.12$geometry)
# calculate area
# intersection
inter.area.12 <- ifelse(nrow(inter.poly.12) == 0, 0, sf::st_area(inter.poly.12))
#remaining circle
remaining.circle.area.12 <- ifelse(nrow(remaining.circle.poly.12) == 0, 0, sf::st_area(remaining.circle.poly.12))
# create area dataframe for areas
inter.area.df.12 <- as.data.frame(cbind("plot_ID" = c(my.plot.id, my.plot.id), "e_ID" = c(my.e.id,  0),
"inv_year" = c(my.inv.year, my.inv.year),
# "e_form" = c(my.e.form, 0),
#"shape" = c("edge", "circle"),
"CCS_r_m" = c(c.r2, c.r2),"inter_stat" = c(inter.status.poly.12, 0),
"area_m2" = c(inter.area.12, remaining.circle.area.12)))
##### 5m circle
# calculate intersection for 17m circle
inter.poly.5  <- sf::st_intersection(circle.5, my.poly)
inter.status.poly.5 <- ifelse(nrow(inter.poly.5) == 0, "no intersections",
ifelse(my.e.form == 1 & inter.poly.5$geometry == circle.5$geometry,  "no intersections",
ifelse(my.e.form == 2 & inter.poly.5$geometry == circle.5$geometry, "fully covering circle",
"partly intersecting")))
# this is just to remove all the additional attributes from the intersection polygone
#inter.poly  <- sf::st_intersection(circle.17, st_geometry(my.poly))
# if the ednge covers all of the circle remaining, the inter.polygone its going to be set to 0 so we know there are no direct intersections
inter.poly.5 <- if(isTRUE(inter.poly.5) && inter.poly.5$geometry == circle.5$geometry){inter.poly.5 <-data.frame()}else{inter.poly.5}
# if the edge-circle intersection is equal to 0 (so there is no intersection) return the whole cirlce as remaining circle area, else calculate the remaining circle by decuctng the intersection are from the circle area
remaining.circle.poly.5  <- if(isTRUE(nrow(inter.poly.5)==0)){circle.5}else{sf::st_difference(circle.5, inter.poly.5)}
# calculate area
# intersection
inter.area.5 <- ifelse(nrow(inter.poly.5) == 0, 0, sf::st_area(inter.poly.5))
#remaining circle
remaining.circle.area.5 <- ifelse(nrow(remaining.circle.poly.5) == 0, 0, sf::st_area(remaining.circle.poly.5))
# create area dataframe for areas
inter.area.df.5 <- as.data.frame(cbind("plot_ID" = c(my.plot.id, my.plot.id), "e_ID" = c(my.e.id,  0),
"inv_year" = c(my.inv.year, my.inv.year),
# "e_form" = c(my.e.form, 0),
#"shape" = c("edge", "circle"),
"CCS_r_m" = c(c.r1, c.r1),"inter_stat" = c(inter.status.poly.5, 0),
"area_m2" = c(inter.area.5, remaining.circle.area.5)))
# bind area dataframes together
inter.area.df <- rbind(inter.area.df.17, inter.area.df.12, inter.area.df.5)
i = which(grepl(50133, (forest_edges.man.sub.1.edge.nogeo$plot_ID)))
# select plot ID of the respective circle
my.plot.id <- forest_edges.man.sub.1.edge.nogeo[i, "plot_ID"]
my.plot.id
my.plot.id
# dataprep for loop
# bind polygone dataframes together
edge.poly.df.nogeo <- rbind(triangle.e1.poly.df.nogeo, triangle.e2.poly.df.nogeo) # rows: 83
# createa dataframe with plots that have only one forest edges
forest_edges.man.sub.1.edge.nogeo <- forest_edges.man %>% # rows:84
# select only plots with a known edge form and for edge 2 only those that actually intersect the 17m circle
filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%  # rows:81
# remove plots that have two edges
anti_join(forest_edges.man %>%  filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%
group_by(plot_ID) %>% summarise(n = n()) %>% filter(n > 1) %>% select(plot_ID), by = "plot_ID")#  %>% # 14 plots with 2 edges --> 28 rows -> 53 left
# prepare output datasets
edges.list.nogeo <- vector("list", length = length(unique(forest_edges.man.sub.1.edge.nogeo$plot_ID)))
inter.poly.list.nogeo <- vector("list", length = length(unique(forest_edges.man.sub.1.edge.nogeo$plot_ID)))
#inter.poly.NA.list <- vector("list", length = length(unique(forest_edges.man.sub.1.edge$plot_ID)))
remaining.circle.poly.list.nogeo <- vector("list", length = length(unique(forest_edges.man.sub.1.edge.nogeo$plot_ID)))
remaining.circle.multipoly.list.nogeo <- vector("list", length = length(unique(forest_edges.man.sub.1.edge.nogeo$plot_ID)))
edge.poly.df.nogeo

# save areas into dataframe
edges.list.two.edges.final.nogeo <- rbindlist(edges.list.two.edges.nogeo)
edges.area.two.edges.df.nogeo <- as.data.frame(edges.list.two.edges.final.nogeo)
# save plot IDs with overlappig edges within the 17.84m circle into dataframe
intersection.two.edges.warning.final.nogeo <- rbindlist(intersection.warning.edges.list.nogeo, fill=TRUE)
intersection.two.edges.warning.df.nogeo <- na.omit(as.data.frame(intersection.two.edges.warning.final.nogeo))
# save intersection polygones into dataframe
# list of polygones 1 of forest edges
inter.poly.1.list.final.nogeo <- rbindlist(inter.poly.1.list.nogeo, fill=TRUE)
inter.poly.1.two.edges.df.nogeo <- as.data.frame(inter.poly.1.list.final.nogeo)
# list of polygones 2 of forest edges
inter.poly.2.list.final.nogeo <- rbindlist(inter.poly.2.list.nogeo, fill=TRUE)
inter.poly.2.two.edges.df.nogeo <- as.data.frame(inter.poly.2.list.final.nogeo)[,c(1,2,3,4)]
# bind the both edges per plot together
inter.poly.two.edges.df.nogeo <- rbind(inter.poly.1.two.edges.df.nogeo, inter.poly.2.two.edges.df.nogeo) %>% arrange(plot_ID, e_ID)
# list of polygones of remainign circles
rem.circle.poly.two.edges.list.final.nogeo <- rbindlist(rem.circle.poly.2.edges.list.nogeo, fill = TRUE)
rem.circle.poly.two.edges.df.nogeo <- as.data.frame(rem.circle.poly.two.edges.list.final.nogeo)[,c(1,2,3,4)]  %>% distinct()
# list of multipolygones of remaining circles
rem.circle.multipoly.two.edges.list.final.nogeo <- rbindlist(rem.circle.multipoly.2.edges.list.nogeo)
rem.circle.multipoly.two.edges.df.nogeo <- as.data.frame(rem.circle.multipoly.two.edges.list.final.nogeo)[,c(1,2,3,10)] %>% distinct()
# binding the both circle lists back together
rem.circle.two.edges.df.nogeo <- if(nrow(rem.circle.poly.two.edges.df.nogeo) != 0 && nrow(rem.circle.multipoly.two.edges.list.final.nogeo) != 0){
rbind(rem.circle.poly.two.edges.df.nogeo, rem.circle.multipoly.two.edges.df.nogeo)
}else{rem.circle.poly.two.edges.df.nogeo}
# bind all edges area dataframes together
all.edges.area.df.nogeo <- rbind(edges.area.df.nogeo, edges.area.two.edges.df.nogeo) %>% mutate(area_m2 = as.numeric(area_m2))
# 3.2.1.4. sorting TREES into edge and remaining circle polygones ---------
# 3.2.1.4.1. plots with one edge: sorting trees into edge and remaining circle polygones ---------
trees.one.edge.nogeo <- HBI_trees %>%
# filter only for trees that are located in plots with a forest edge
semi_join(forest_edges_HBI.man %>% filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%
select(plot_ID) %>% distinct(), by = "plot_ID") %>%
# filter for trees located in plots htat haev only one forest edge
anti_join(forest_edges_HBI.man %>% filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>% group_by(plot_ID) %>% summarise(n = n()) %>% filter(n > 1) %>% select(plot_ID), by = "plot_ID") #%>%
# remove plots that do now have a corresponding center coordiante in the HBI loc document
#semi_join(HBI_loc %>% filter(!is.na( RW_MED) & !is.na(HW_MED)) %>%  select(plot_ID)  %>% distinct(), by = "plot_ID")
tree.status.list.nogeo <- vector("list", length = length(trees.one.edge.nogeo$tree_ID))
tree.points.list.nogeo <- vector("list", length = length(trees.one.edge.nogeo$tree_ID))
for (i in 1:length(trees.one.edge.nogeo$tree_ID)){
#i = 997
# i = which(grepl(50133, (trees.one.edge.nogeo$plot_ID)))[7]
# select plot ID accordint to positioin in the list
my.plot.id <- trees.one.edge.nogeo[i, "plot_ID"]
my.tree.id <- trees.one.edge.nogeo[i, "tree_ID"]
# select the remaining cirlce we want to intersect the tree with
my.rem.circle <- sf::st_as_sf(rem.circle.one.edge.df.nogeo %>% filter(plot_ID == my.plot.id) %>% distinct())
my.inter <- sf::st_as_sf(inter.poly.one.edge.df.nogeo  %>% filter(plot_ID == my.plot.id) %>% distinct())
# sort area dataframe by size of cirlce fragments:
# bigger polygone/ polygone with greater area is assigned to category A, smaller area polygone is assigned to B
area.plot.df <- edges.area.df.nogeo %>% filter(plot_ID == my.plot.id & CCS_r_m == 17.84) %>%
arrange(area_m2) %>%
mutate(stand = case_when(
row_number()== 1 ~ "B",
row_number()== 2 ~ "A",
TRUE ~ NA))
# assign stand category to the polygones depending on which one is bigger/ smaller
my.rem.circle$stand <- area.plot.df$stand[area.plot.df$e_ID == 0]
my.inter$stand <- area.plot.df$stand[area.plot.df$e_ID == 1 | area.plot.df$e_ID == 2]
# # assign crs
#my.utm.epsg <- "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs +type=crs"
# # select UTM corrdinates of the plot center
#my.center.easting <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "RW_MED"]
#my.center.northing <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "HW_MED"]
# extract polar coordiantes of forest edge
# point A
dist.tree <- trees.one.edge.nogeo[i, "Dist_cm"]/100
azi.tree <- trees.one.edge.nogeo[i, "azi_gon"]
x.tree <- dist.tree*sin(azi.tree)   # longitude, easting, RW, X
y.tree <- dist.tree*cos(azi.tree)   # latitude, northing, HW, y
# transform polar into cartesian coordiantes
tree.east <- x.tree #+ my.center.easting
tree.north <-  y.tree # + my.center.northing
# save cartesian coordiantes in dataframe
tree.coord.df <- as.data.frame(cbind(
"plot_ID" = c(my.plot.id),
"tree_ID" = c(my.tree.id),
"lon" = c(tree.east),
"lat" = c(tree.north)
))
# create sf point object from dataframe
#https://stackoverflow.com/questions/52551016/creating-sf-points-from-multiple-lat-longs
tree.sf <-  sf::st_as_sf(tree.coord.df, coords = c("lon", "lat"), remove = FALSE)
# assing CRS to points
#sf::st_crs(tree.sf) <- my.utm.epsg
# print(plot(my.inter$geometry),
#      plot(my.rem.circle$geometry, add = T),
#      plot(tree.sf$geometry, add = T)
#     )
inter.tree.circle <- sf::st_intersection(tree.sf, my.rem.circle)
inter.tree.edge <- sf::st_intersection(tree.sf, my.inter)
tree_status <- ifelse(nrow(inter.tree.edge)!= 0, my.inter$stand,
ifelse(nrow(inter.tree.circle) != 0,  my.rem.circle$stand,
"warning"))
tree.status.list.nogeo[[i]] <- as.data.frame(cbind(
"plot_ID" = c(my.plot.id),
"tree_ID" = c(my.tree.id),
"lon" = c(tree.coord.df$lon),
"lat" = c(tree.coord.df$lat),
"t_stat" = c(tree_status)))
# export tree points as sf
tree.points.list.nogeo[[i]] <- c("t_stat" = tree_status, tree.sf)
}
# save tree corodiantes and status into dataframe
tree.status.list.one.edge.final.nogeo <- rbindlist(tree.status.list.nogeo)
tree.status.one.edge.df.nogeo <- as.data.frame(tree.status.list.one.edge.final.nogeo)
# save tree sf into dataframe
tree.points.list.one.edge.final.nogeo <- rbindlist(tree.points.list.nogeo)
tree.points.one.edge.df.nogeo <- as.data.frame(tree.points.list.one.edge.final.nogeo)
# 3.2.1.4.2. plots with 2 edges: sorting trees into edge and remaining circle polygones ---------
# intersection of trees with 2 edges
trees.two.edges.nogeo <- HBI_trees %>%
# filter only for trees that are located in plots with a forest edge
semi_join(forest_edges_HBI.man %>% filter(e_form == 1 | e_form == 2) %>%
#& inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%
select(plot_ID) %>% distinct(), by = "plot_ID") %>%
# filter for trees located in plots htat haev only one forest edge
semi_join(forest_edges_HBI.man %>% filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%
group_by(plot_ID) %>% summarise(n = n()) %>% filter(n > 1) %>% select(plot_ID), by = "plot_ID") #%>%
# remove plots that do now have a corresponding center coordiante in the HBI loc document
# semi_join(HBI_loc %>% filter(!is.na( RW_MED) & !is.na(HW_MED)) %>%  select(plot_ID)  %>% distinct(), by = "plot_ID")
tree.status.two.edges.list.nogeo <- vector("list", length = length(trees.two.edges.nogeo$tree_ID))
tree.points.two.edges.list.nogeo <- vector("list", length = length(trees.two.edges.nogeo$tree_ID))
for (i in 1:length(trees.two.edges.nogeo$tree_ID)){
# i = 1
# i = which(grepl(50122, (trees.two.edges.nogeo$plot_ID)))[2]
# select plot ID accordint to positioin in the list
my.plot.id <- trees.two.edges.nogeo[i, "plot_ID"]
my.tree.id <- trees.two.edges.nogeo[i, "tree_ID"]
# select the remaining cirlce we want to intersect the tree with
my.rem.circle <- sf::st_as_sf(rem.circle.two.edges.df.nogeo %>% filter(plot_ID == my.plot.id) %>% distinct())
my.edges.df <- inter.poly.two.edges.df.nogeo %>% filter(plot_ID == my.plot.id) %>% distinct() %>% arrange(e_ID)
my.inter.1 <- sf::st_as_sf(my.edges.df[1,])
my.inter.2 <- sf::st_as_sf(my.edges.df[2,])
# assign stand category to the polygones depending on which one is bigger/ smaller:
# bigger polygone/ polygone with greater area is assigned to category A, smaller area polygone is assigned to B
area.plot.df <- edges.area.two.edges.df.nogeo %>% filter(plot_ID == my.plot.id & CCS_r_m == 17.84) %>%
arrange(as.numeric(area_m2)) %>%
mutate(stand = case_when(
row_number()== 1 ~ "C",
row_number()== 2 ~ "B",
row_number()== 3 ~ "A",
TRUE ~ NA))
# assign stand category to the polygones depending on which one is bigger/ smaller
my.rem.circle$stand <- area.plot.df$stand[area.plot.df$e_ID == 0]
my.inter.1$stand <- area.plot.df$stand[area.plot.df$e_ID == 1]
my.inter.2$stand <- area.plot.df$stand[area.plot.df$e_ID == 2]
# # assign crs
# my.utm.epsg <- "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs +type=crs"
# # select UTM corrdinates of the plot center
# my.center.easting <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "RW_MED"]
# my.center.northing <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "HW_MED"]
# extract polar coordiantes of forest edge
# point A
dist.tree <- trees.two.edges.nogeo[i, "Dist_cm"]/100
azi.tree <- trees.two.edges.nogeo[i, "azi_gon"]
x.tree <- dist.tree*sin(azi.tree)   # longitude, easting, RW, X
y.tree <- dist.tree*cos(azi.tree)   # latitude, northing, HW, y
# transform polar into cartesian coordiantes
tree.east <- x.tree  # + my.center.easting
tree.north <- y.tree # + my.center.northing
# save cartesian coordiantes in dataframe
tree.coord.df <- as.data.frame(cbind(
"plot_ID" = c(my.plot.id),
"tree_ID" = c(my.tree.id),
"lon" = c(tree.east),
"lat" = c(tree.north)
))
# create sf point object from dataframe
#https://stackoverflow.com/questions/52551016/creating-sf-points-from-multiple-lat-longs
tree.sf <-  sf::st_as_sf(tree.coord.df, coords = c("lon", "lat"), remove = FALSE)
# assing CRS to points
#sf::st_crs(tree.sf) <- my.utm.epsg
# print(plot(my.rem.circle$geometry, col = "red"),
#       plot(my.inter.2$geometry, add = T),
#       plot(my.inter.1$geometry, add = T),
#       plot(tree.sf$geometry, add = T)
#       )
inter.tree.circle <- sf::st_intersection(tree.sf, my.rem.circle)
inter.tree.edge.1 <- sf::st_intersection(tree.sf, my.inter.1)
inter.tree.edge.2 <- sf::st_intersection(tree.sf, my.inter.2)
tree_status <- ifelse(nrow(inter.tree.edge.1)!= 0 & nrow(inter.tree.edge.2)== 0 & nrow(inter.tree.circle)== 0,  my.inter.1$stand,                     # if tree is in edge 1
ifelse(nrow(inter.tree.edge.2)!= 0 & nrow(inter.tree.edge.1)== 0 & nrow(inter.tree.circle)== 0,  my.inter.2$stand,              # if tree is in edge 2
ifelse(nrow(inter.tree.circle)!= 0 & nrow(inter.tree.edge.1)== 0 & nrow(inter.tree.edge.2)== 0,  my.rem.circle$stand,    # if tree is in circle
#ifelse(nrow(inter.tree.circle)== 0 & nrow(inter.tree.edge.1)!= 0 & nrow(inter.tree.edge.2)!= 0,  "warning",       # if tree is in two edges
"warning")))                                                                                             # if tree is nowhere
tree.status.two.edges.list.nogeo[[i]] <- as.data.frame(cbind(
"plot_ID" = c(my.plot.id),
"tree_ID" = c(my.tree.id),
"lon" = c(tree.coord.df$lon),
"lat" = c(tree.coord.df$lat),
"t_stat" = c(tree_status)))
tree.points.two.edges.list.nogeo[[i]] <- c("t_stat" = tree_status, tree.sf)
}
# save tree corodiantes and status into dataframe
tree.status.list.two.edges.final.nogeo <- rbindlist(tree.status.two.edges.list.nogeo)
tree.status.two.edges.df.nogeo <- as.data.frame(tree.status.list.two.edges.final.nogeo)
# save tree sf into dataframe
tree.points.list.two.edges.final.nogeo <- rbindlist(tree.points.two.edges.list.nogeo)
tree.points.two.edges.df.nogeo <- as.data.frame(tree.points.list.two.edges.final.nogeo)
all.trees.points.df.nogeo <- rbind(tree.points.one.edge.df.nogeo,tree.points.two.edges.df.nogeo)
# 3.2.1.4.1. plots with no edge edge: sorting trees into circle ---------
trees.no.edge.nogeo <- anti_join(HBI_trees, all.trees.points.df.nogeo %>% select(plot_ID) %>% distinct(), by = "plot_ID")
tree.status.no.edge.list.nogeo <- vector("list", length = length(trees.no.edge.nogeo$tree_ID))
tree.points.no.edge.list.nogeo <- vector("list", length = length(trees.no.edge.nogeo$tree_ID))
for (i in 1:length(trees.no.edge.nogeo$tree_ID)){
#i =1
#i = which(grepl(50080, unique(trees.one.edge$plot_ID)))
# select plot ID accordint to positioin in the list
my.plot.id <- trees.no.edge.nogeo[i, "plot_ID"]
my.tree.id <- trees.no.edge.nogeo[i, "tree_ID"]
# extract polar coordiantes of forest edge
# point A
dist.tree <- trees.no.edge.nogeo[i, "Dist_cm"]/100
azi.tree <- trees.no.edge.nogeo[i, "azi_gon"]
x.tree <- dist.tree*sin(azi.tree)   # longitude, easting, RW, X
y.tree <- dist.tree*cos(azi.tree)   # latitude, northing, HW, y
# transform polar into cartesian coordiantes
tree.east <- x.tree  # + my.center.easting
tree.north <- y.tree # + my.center.northing
# save cartesian coordiantes in dataframe
tree.coord.df <- as.data.frame(cbind(
"plot_ID" = c(my.plot.id),
"tree_ID" = c(my.tree.id),
"lon" = c(tree.east),
"lat" = c(tree.north)
))
# create sf point object from dataframe
#https://stackoverflow.com/questions/52551016/creating-sf-points-from-multiple-lat-longs
tree.sf <-  sf::st_as_sf(tree.coord.df, coords = c("lon", "lat"), remove = FALSE)
# assing CRS to points
#sf::st_crs(tree.sf) <- my.utm.epsg
# select the UTM coordiantes of the center of the cirlce corresponding with the plot ID
# my.center.easting <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "RW_MED"]
# my.center.northing <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "HW_MED"]
#### build circle
# circle data
c.x0 = 0
c.y0 = 0
c.r3 = 17.84
c.r2 = 12.62
c.r1 = 5.64
# build polygon (circlular buffer) around center point
center.df<- as.data.frame(cbind("lon" = c.x0, "lat" = c.y0))
# center.df <- as.data.frame(cbind("lon" = my.center.easting, "lat" = my.center.northing))
circle.pt <- sf::st_as_sf(center.df, coords = c("lon", "lat"))
circle.17 <- sf::st_buffer(circle.pt, c.r3)
circle.12 <- sf::st_buffer(circle.pt, c.r2)
circle.5 <- sf::st_buffer(circle.pt, c.r1)
inter.tree.circle.17 <- sf::st_intersection(tree.sf, circle.17)
tree_status <- ifelse(nrow(inter.tree.circle.17)!= 0,  "A", "warning")                                                                                            # if tree is nowhere
tree.status.no.edge.list.nogeo[[i]] <- as.data.frame(cbind(
"plot_ID" = c(my.plot.id),
"tree_ID" = c(my.tree.id),
"lon" = c(tree.coord.df$lon),
"lat" = c(tree.coord.df$lat),
"t_stat" = c(tree_status)))
tree.points.no.edge.list.nogeo[[i]] <- c("t_stat" = tree_status, tree.sf)
}
# save tree corodiantes and status into dataframe
tree.status.no.edges.final.nogeo <- rbindlist(tree.status.no.edge.list.nogeo)
tree.status.no.edges.df.nogeo <- as.data.frame(tree.status.no.edges.final.nogeo)
# save tree sf into dataframe
tree.points.list.no.edges.final.nogeo <- rbindlist(tree.points.no.edge.list.nogeo)
tree.points.no.edges.df.nogeo <- as.data.frame(tree.points.list.no.edges.final.nogeo)
# bind all tree point.sf dataframes (with & without edges together)
all.trees.points.df.nogeo <-
rbind(all.trees.points.df.nogeo ,
tree.points.no.edges.df.nogeo) %>%
left_join(., trees_and_edges %>%
select(plot_ID, tree_ID, DBH_cm),
by = c("plot_ID", "tree_ID"))
all.trees.status.df <-
rbind(tree.status.no.edges.df.nogeo,
tree.status.one.edge.df.nogeo,
tree.status.two.edges.df.nogeo)
# bind all tree point.sf dataframes (with & without edges together)
all.trees.points.df.nogeo <-
rbind(all.trees.points.df.nogeo ,
tree.points.no.edges.df.nogeo)
all.trees.points.df.nogeo
tree.points.no.edges.df.nogeo
# bind all tree point.sf dataframes (with & without edges together)
all.trees.points.df.nogeo <-
rbind(all.trees.points.df.nogeo ,
tree.points.no.edges.df.nogeo) %>%
left_join(., trees_and_edges %>%
select(plot_ID, tree_ID, DBH_cm),
by = c("plot_ID", "tree_ID"),
multiple = "all")
# bind all tree point.sf dataframes (with & without edges together)
all.trees.points.df.nogeo <-
rbind(all.trees.points.df.nogeo ,
tree.points.no.edges.df.nogeo %>%
left_join(., trees_and_edges %>%
select(plot_ID, tree_ID, DBH_cm),
by = c("plot_ID", "tree_ID"),
multiple = "all"))
all.trees.status.df <-
rbind(tree.status.no.edges.df.nogeo,
tree.status.one.edge.df.nogeo,
tree.status.two.edges.df.nogeo)
HBI_trees%>%
# join in stand of each tree
left_join(., all.trees.status.df %>%
select(plot_ID, tree_ID, t_stat),
by = c("plot_ID", "tree_ID"),
multiple = "all") %>%
rename(stand = t_stat)
# harmonize strings of all.trees.status.df and
# https://stackoverflow.com/questions/20637360/convert-all-data-frame-character-columns-to-factors
all.trees.status.df[,c(1,2, 3, 4)] <- lapply(all.trees.status.df[,c(1,2, 3, 4)], as.numeric)
HBI_trees%>%
# join in stand of each tree
left_join(., all.trees.status.df %>%
select(plot_ID, tree_ID, t_stat),
by = c("plot_ID", "tree_ID"),
multiple = "all") %>%
rename(stand = t_stat)
HBI_trees%>%
# join in stand of each tree
left_join(., all.trees.status.df %>%
select(plot_ID, tree_ID, t_stat),
by = c("plot_ID", "tree_ID"),
multiple = "all") %>%
rename(stand = t_stat) %>%
# then join in plot area the tree reffers to due to it´s DBH which determines the sampling circuit it was found in
# asssing corect samling circle diameter according to DBH of the tree
mutate(CCS_r_m = case_when(DBH_cm >= 7  & DBH_cm < 10 ~ 5.64,
DBH_cm >= 10 & DBH_cm < 30 ~ 12.62,
DBH_cm >= 30 ~ 17.84,
TRUE ~ NA))
HBI_trees%>%
# join in stand of each tree
left_join(., all.trees.status.df %>%
select(plot_ID, tree_ID, t_stat),
by = c("plot_ID", "tree_ID"),
multiple = "all") %>%
rename(stand = t_stat) %>%
# then join in plot area the tree reffers to due to it´s DBH which determines the sampling circuit it was found in
# asssing corect samling circle diameter according to DBH of the tree
mutate(CCS_r_m = case_when(DBH_cm >= 7  & DBH_cm < 10 ~ 5.64,
DBH_cm >= 10 & DBH_cm < 30 ~ 12.62,
DBH_cm >= 30 ~ 17.84,
TRUE ~ NA)) %>%
left_join(., all.edges.area.df.nogeo %>%
select(plot_ID, e_ID, CCS_r_m, stand, area_m2) %>%
by = c("plot_ID", "CCS_r_m", "stand"))
HBI_trees%>%
# join in stand of each tree
left_join(., all.trees.status.df %>%
select(plot_ID, tree_ID, t_stat),
by = c("plot_ID", "tree_ID"),
multiple = "all") %>%
rename(stand = t_stat) %>%
# then join in plot area the tree reffers to due to it´s DBH which determines the sampling circuit it was found in
# asssing corect samling circle diameter according to DBH of the tree
mutate(CCS_r_m = case_when(DBH_cm >= 7  & DBH_cm < 10 ~ 5.64,
DBH_cm >= 10 & DBH_cm < 30 ~ 12.62,
DBH_cm >= 30 ~ 17.84,
TRUE ~ NA)) %>%
left_join(., all.edges.area.df.nogeo %>%
select(plot_ID, e_ID, CCS_r_m, stand, area_m2) %>%
by = c("plot_ID", "CCS_r_m", "stand"))
HBI_trees%>%
# join in stand of each tree
left_join(., all.trees.status.df %>%
select(plot_ID, tree_ID, t_stat),
by = c("plot_ID", "tree_ID"),
multiple = "all") %>%
rename(stand = t_stat) %>%
# then join in plot area the tree reffers to due to it´s DBH which determines the sampling circuit it was found in
# asssing corect samling circle diameter according to DBH of the tree
mutate(CCS_r_m = case_when(DBH_cm >= 7  & DBH_cm < 10 ~ 5.64,
DBH_cm >= 10 & DBH_cm < 30 ~ 12.62,
DBH_cm >= 30 ~ 17.84,
TRUE ~ NA)) %>%
left_join(., all.edges.area.df.nogeo %>%
select(plot_ID, e_ID, CCS_r_m, stand, area_m2),
by = c("plot_ID", "CCS_r_m", "stand"))
colnames(all.edges.area.df.nogeo)
all.edges.area.df.nogeo[,c(1,2, 3, 5)]
# harmonize strings of all.trees.status.df and
# https://stackoverflow.com/questions/20637360/convert-all-data-frame-character-columns-to-factors
all.trees.status.df[,c(1,2, 3, 4)] <- lapply(all.trees.status.df[,c(1,2, 3, 4)], as.numeric)
all.edges.area.df.nogeo[,c(1,2, 3, 5)] <- lapply(all.edges.area.df.nogeo[,c(1,2, 3, 5)], as.numeric)
trees_edges_HBI <- HBI_trees%>%
# join in stand of each tree
left_join(., all.trees.status.df %>%
select(plot_ID, tree_ID, t_stat),
by = c("plot_ID", "tree_ID"),
multiple = "all") %>%
rename(stand = t_stat) %>%
# then join in plot area the tree reffers to due to it´s DBH which determines the sampling circuit it was found in
# asssing corect samling circle diameter according to DBH of the tree
mutate(CCS_r_m = case_when(DBH_cm >= 7  & DBH_cm < 10 ~ 5.64,
DBH_cm >= 10 & DBH_cm < 30 ~ 12.62,
DBH_cm >= 30 ~ 17.84,
TRUE ~ NA)) %>%
left_join(., all.edges.area.df.nogeo %>%
select(plot_ID, e_ID, CCS_r_m, stand, area_m2),
by = c("plot_ID", "CCS_r_m", "stand")) %>%
mutate(area_m2 = ifelse(stand == "A" & is.na(e_ID) & is.na(area_m2), c_A(CCS_r_m), area_m2),
plot_A_ha = as.numeric(area_m2)/10000,
inv = "HBI")
HBI_trees%>%
# join in stand of each tree
left_join(., all.trees.status.df %>%
select(plot_ID, tree_ID, t_stat),
by = c("plot_ID", "tree_ID"),
multiple = "all") %>%
rename(stand = t_stat) %>%
# then join in plot area the tree reffers to due to it´s DBH which determines the sampling circuit it was found in
# asssing corect samling circle diameter according to DBH of the tree
mutate(CCS_r_m = case_when(DBH_cm >= 7  & DBH_cm < 10 ~ 5.64,
DBH_cm >= 10 & DBH_cm < 30 ~ 12.62,
DBH_cm >= 30 ~ 17.84,
TRUE ~ NA)) %>%
left_join(., all.edges.area.df.nogeo %>%
select(plot_ID, e_ID, CCS_r_m, stand, area_m2),
by = c("plot_ID", "CCS_r_m", "stand"))
HBI_trees%>%
# join in stand of each tree
left_join(., all.trees.status.df %>%
select(plot_ID, tree_ID, t_stat),
by = c("plot_ID", "tree_ID"),
multiple = "all") %>%
rename(stand = t_stat) %>%
# then join in plot area the tree reffers to due to it´s DBH which determines the sampling circuit it was found in
# asssing corect samling circle diameter according to DBH of the tree
mutate(CCS_r_m = case_when(DBH_cm >= 7  & DBH_cm < 10 ~ 5.64,
DBH_cm >= 10 & DBH_cm < 30 ~ 12.62,
DBH_cm >= 30 ~ 17.84,
TRUE ~ NA)) %>%
left_join(., all.edges.area.df.nogeo %>%
select(plot_ID, e_ID, CCS_r_m, stand, area_m2),
by = c("plot_ID", "e_ID", "CCS_r_m", "stand")) %>%
mutate(area_m2 = ifelse(stand == "A" & is.na(e_ID) & is.na(area_m2), c_A(CCS_r_m), area_m2),
plot_A_ha = as.numeric(area_m2)/10000,
inv = "HBI")
trees_edges_HBI <- HBI_trees%>%
# join in stand of each tree
left_join(., all.trees.status.df %>%
select(plot_ID, tree_ID, t_stat),
by = c("plot_ID", "tree_ID"),
multiple = "all") %>%
rename(stand = t_stat) %>%
# then join in plot area the tree reffers to due to it´s DBH which determines the sampling circuit it was found in
# asssing corect samling circle diameter according to DBH of the tree
mutate(CCS_r_m = case_when(DBH_cm >= 7  & DBH_cm < 10 ~ 5.64,
DBH_cm >= 10 & DBH_cm < 30 ~ 12.62,
DBH_cm >= 30 ~ 17.84,
TRUE ~ NA)) %>%
left_join(., all.edges.area.df.nogeo %>%
select(plot_ID, e_ID, CCS_r_m, stand, area_m2),
by = c("plot_ID", "e_ID", "CCS_r_m", "stand")) %>%
mutate(area_m2 = ifelse(stand == "A" & is.na(e_ID) & is.na(area_m2), c_A(CCS_r_m), area_m2),
plot_A_ha = as.numeric(area_m2)/10000,
inv = "HBI")
gc()
# exporting data ----------------------------------------------------------
# exporting tree and edge/ plot area data
write.csv(HBI_trees_update_2, paste0(out.path.BZE3,"HBI_trees_update_2.csv"))
HBI_trees_update_2 <- HBI_trees%>%
# join in stand of each tree
left_join(., all.trees.status.df %>%
select(plot_ID, tree_ID, t_stat),
by = c("plot_ID", "tree_ID"),
multiple = "all") %>%
rename(stand = t_stat) %>%
# then join in plot area the tree reffers to due to it´s DBH which determines the sampling circuit it was found in
# asssing corect samling circle diameter according to DBH of the tree
mutate(CCS_r_m = case_when(DBH_cm >= 7  & DBH_cm < 10 ~ 5.64,
DBH_cm >= 10 & DBH_cm < 30 ~ 12.62,
DBH_cm >= 30 ~ 17.84,
TRUE ~ NA)) %>%
left_join(., all.edges.area.df.nogeo %>%
select(plot_ID, e_ID, CCS_r_m, stand, area_m2),
by = c("plot_ID", "e_ID", "CCS_r_m", "stand")) %>%
mutate(area_m2 = ifelse(stand == "A" & is.na(e_ID) & is.na(area_m2), c_A(CCS_r_m), area_m2),
plot_A_ha = as.numeric(area_m2)/10000,
inv = "HBI")
# exporting data ----------------------------------------------------------
# exporting tree and edge/ plot area data
write.csv(HBI_trees_update_2, paste0(out.path.BZE3,"HBI_trees_update_2.csv"))
write.csv(trees_and_edges, paste0(out.path.BZE3,"LT_edges_HBI.csv"))
# export areas and stand info of all sampling circuits, edges and remaining circles
write.csv(all.trees.status.df, paste0(out.path.BZE3,"all_trees_status.csv"))
# export tree stand status of all trees nomatter if they have one, two or no forest edges at their plot
write.csv(all.edges.area.df.nogeo, paste0(out.path.BZE3,"all_edges_rem_circles_area.csv"))
HBI_trees_update_2
colnames(HBI_trees_update_2)
#calcualte the height and diameter of a stem reprensenting the mean basal area
# this is creates a tree dataset with mean BHD, d_g, h_g per species per plot per canopy layer which we need for SLOBODA
Hg_Dg_trees_total.df <- trees_total %>%
group_by(inv, plot_ID,stand, C_layer, SP_code, CCS_r_m) %>%    # group by plot and species, canopy layer and sampling circuit to calcualte all paremeters needed
summarise(no_trees_CC = n(),
BA_CC = sum(BA_m2),                        # sum up basal  area per sampling circuit to then reffer it to the hektar value of the respective circuit
CC_A_ha = mean(plot_A_ha),                   # mean area in ha per sampling circuit
BA_CC_m2_ha = BA_CC/CC_A_ha,               # calculating the BA hectare value of each tree species per c layer to account for the different sampling circuits
no_trees_CC_ha = no_trees_CC/CC_A_ha,
mean_DBH_mm_CC = mean(DBH_cm*10),          # calculate mean DBH per sampling circuit and species and C layer and plot
mean_H_m_CC = mean(na.omit(H_m))) %>%      # calculate mean height per sampling circuit and species and C layer and plot
group_by(inv, plot_ID, stand, C_layer, SP_code )%>%            # group by plot and species,  canopy layer and sampling circuit to calcualte dg, hg
summarize(no_trees_ha = sum(no_trees_CC_ha),                                # calculate number of trees per plot
BA_m2_ha = sum(BA_CC_m2_ha),               # calculate sum of BA across all sampling circuit to account for represnation of different trees in the sampling circuits
mean_DBH_mm = mean(mean_DBH_mm_CC),        # calculate mean of DBH across all sampling circuit to account for represnation of different trees in the sampling circuits
mean_H_m = mean(mean_H_m_CC),              # calculate mean of height across all sampling circuit to account for represnation of different trees in the sampling circuits
mean_BA_m2_tree = BA_m2_ha/no_trees_ha,
H_g = sum(mean(na.omit(mean_H_m))*BA_m2_ha)/sum(BA_m2_ha),    # Hoehe des Grundflächemittelstammes, calculation according to S. Schnell
mean_DBH_mm = mean(mean_DBH_mm),                           # mean diameter per species per canopy layer per plot
D_g = ((sqrt((mean_BA_m2_tree/pi)))*2)*100)              #  Durchmesser des Grundflächenmittelstammes; *100 to get from 1m -> 100cm

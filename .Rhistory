# HBI BE locations dataset: this dataset contains the coordinates of the center point of the tree inventory accompanying the second national soil inventory
geo_loc <- read.delim(file = here(paste0("data/input/BZE2_HBI/location_",  trees_data$inv[1], ".csv")), sep = ";", dec = ",")
# HBI forest edges (Waldränder) info
forest_edges <- read.delim(file = here(paste0(out.path.BZE3, trees_data$inv[1], "_forest_edges_update_1.csv")), sep = ",", dec = ".")
# test
forest_edges$A_dist <- 1784
forest_edges$A_azi <- 100
forest_edges$B_dist <- 1784
forest_edges$B_azi <- 300
# ----- 0.6 harmonising column names & structure  -------------------------
# HBI locations
geo_loc <- geo_loc[1:12]
colnames(geo_loc) <- c("plot_ID", "ToEckId", "K2_RW",
"K2_HW", "K3_RW", "K3_HW", "RW_MED",
"HW_MED",  "LAT_MED",  "LON_MED",
"LAT_MEAN", "LON_MEAN")
# ----- 1.1.2.1. join in edge info to tree dataset ------------------------
# ----- 1.1.2.1.1. HBI join in forest edge info per plot -----------------------------------------------
trees_data <- trees_data %>%
# calculate the coordinates of every tree
mutate(dist_m = dist_cm/100,
X_tree = coord(data_circle$x0[1], data_circle$y0[1], dist_m, azi_gon, coordinate = "x"),
Y_tree = coord(data_circle$x0[1], data_circle$y0[1], dist_m, azi_gon, coordinate = "y")) %>%
# join in the forest edge information per plot
left_join(., forest_edges %>%
select(plot_ID, e_ID, e_type, e_form),
by = "plot_ID",
multiple = "all") # this is necesarry since there are, apperently, multiple edges per plot
# ----- 1.1.2.2. edge  point coordinates,  line parameters, intersections with circles -----------------------------------------------------------
# set up line from 2 points manually
forest_edges.man <- forest_edges %>%
filter(e_form %in% c("1", "2")) %>%
# convert distance from cm to m
mutate(across(c("A_dist", "B_dist", "T_dist"), ~ (.x)/100)) %>%
# find line parameters
# 1. calculate x and y coordinates for all edge points
mutate(X_A = ifelse(A_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], A_dist, A_azi, coordinate = "x"), NA), # if the value is marked -2 its equal to an NA
X_B = ifelse(B_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], B_dist, B_azi, coordinate = "x"), NA),
X_T = ifelse(T_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], T_dist, T_azi, coordinate = "x"), NA),
Y_A = ifelse(A_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], A_dist, A_azi, coordinate = "y"), NA), # if the value is marked -2 its equal to an NA
Y_B = ifelse(B_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], B_dist, B_azi, coordinate = "y"), NA),
Y_T = ifelse(T_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], T_dist, T_azi, coordinate = "y"), NA)) %>%
# 2. calcualte slope ß1 = (y2-y1)/(x2-x1) hight/width
mutate(b1_AB = ifelse(e_form == "1", slope(X_A, Y_A, X_B, Y_B), NA),
b1_AT = ifelse(e_form == "2", slope(X_T, Y_T, X_A, Y_A), NA),
b1_BT = ifelse(e_form == "2", slope(X_T, Y_T, X_B, Y_B), NA)) %>%
# 3. intercept of line with y-axis b0 : insert known point: XA YA
# Y_A = b1_AB*X_A + b0_AB -- -b1_AB*X_A --> b0_AB =  Y_A - b1_AB*X_A
mutate(b0_AB = ifelse(e_form == "1", intercept(X_A, Y_A,  X_B, Y_B), NA),
b0_AT = ifelse(e_form == "2", intercept(X_T, Y_T, X_A, Y_A), NA),
b0_BT = ifelse(e_form == "2", intercept(X_T, Y_T, X_B, Y_B), NA)) %>%
### 17m circle --> used for tree status also
# find x coordinate of the interception between line and 17.84m circle: insert line equation in circle equation (function: intersection_line_circle)
# for AB line
mutate(X1_inter_AB_17 = intersection_line_circle(b0_AB, b1_AB,  data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x1"),
X2_inter_AB_17 = intersection_line_circle(b0_AB, b1_AB, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x2"),
inter_status_AB_17 = intersection.status(intersection_line_circle(b0_AB, b1_AB,  data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x1"),
intersection_line_circle(b0_AB, b1_AB, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x2")),
# for AT line
X1_inter_AT_17 = intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x1"),
X2_inter_AT_17 = intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x2"),
inter_status_AT_17 = intersection.status(intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x1"),
intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x2")),
# for BT line
X1_inter_BT_17 = intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x1"),
X2_inter_BT_17 = intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x2"),
inter_status_BT_17 = intersection.status(intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x1"),
intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x2"))) %>%
# y intersection with 17m circle: insert x of intercept with circle in equation of line
# AB line
mutate(Y1_inter_AB_17 = intersection_line_circle(b0_AB, b1_AB,  data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="y1"),
Y2_inter_AB_17 = intersection_line_circle(b0_AB, b1_AB,  data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="y2"),
# AT line
Y1_inter_AT_17 = intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="y1"),
Y2_inter_AT_17 = intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="y2"),
# BT line
Y1_inter_BT_17 = intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="y1"),
Y2_inter_BT_17 = intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="y2")) %>%
# distance interception centre --> to see if points are actually placed on the rim of the circle
mutate(inter_1_dist = distance(X1_inter_AB_17, Y1_inter_AB_17, 0, 0)) %>%     # this is just to control if the whole thing worked and
# selecting intersections on the "right" side to check if point lies within triangle
# to calculate the triangles Barycentric coordinates we need 3 points: A, B, C = centre point
# in case T lies within the circle, we want R to select A and B from the intersection with the circle.
# Whereby we have to use a wider radius, to make sure that trees located the halfmoon of the circle cut by the triangle (Kreisbogen) are selected too.
# when t lies inside the circle (so both lines reach outside) ue only intersception point where direction between inter_AT and AT is equal choose this x, we need a buffer tho
# the following statement says:  check if the slope of x_inter_1  or the slope of x_inter_2 is equal to the slope of AT,
#                                choose the x which has the same slope (x_inter_1 or x_inter_2)as the second point on the line (A or B)
#                                but with a buffer of 60m radius, which is why it has to be newly calculated
# find the intercept of circle and line that prolonges the line between a and t or B and T via inter.for.triangle function
# if azimut T to A  identical to azimut T to intercept 1 A and circle use this intercept (inter_AT_1) for the triable, if azimut T to A identical to azimute T to intercept 2 between A and  circle use this intercept (inter_AT_2),
mutate(X_inter_AT_triangle_60 = inter.for.triangle(b0_AT, b1_AT, 0, 0, data_circle$rmax[3]*2, X_A, Y_A, X_T, Y_T, coordinate = "x"),
X_inter_BT_triangle_60 = inter.for.triangle(b0_BT, b1_BT, 0, 0, data_circle$rmax[3]*2, X_B, Y_B, X_T, Y_T, coordinate = "x"),
# calcualte y to the x that lie in the same direction then the second point on the line, if turning points lies witin circle and lines "reach out"
Y_inter_AT_triangle_60 = inter.for.triangle(b0_AT, b1_AT, 0, 0, data_circle$rmax[3]*2, X_A, Y_A, X_T, Y_T, coordinate = "y"),
Y_inter_BT_triangle_60 = inter.for.triangle(b0_BT, b1_BT, 0, 0, data_circle$rmax[3]*2, X_B, Y_B, X_T, Y_T, coordinate = "y"))
forest_edges.man.sub.e1.nogeo <-  forest_edges.man%>% filter(e_form == 1) # %>%
triangle.e1.list.nogeo <- vector("list", length = length(forest_edges.man.sub.e1.nogeo$plot_ID))
triangle.e1.coords.nogeo <- vector("list", length = length(forest_edges.man.sub.e1.nogeo$plot_ID)*4)
i = 1
# select plot ID, edge form and edge_ID accordint to positioin in the list
my.plot.id <- forest_edges.man.sub.e1.nogeo[i, "plot_ID"]
my.e.id <- forest_edges.man.sub.e1.nogeo[i, "e_ID"]
my.e.form <- forest_edges.man.sub.e1.nogeo[i, "e_form"]
my.inv.year <- forest_edges.man.sub.e1.nogeo[i, "inv_year"]
# circle center and radius to calcualte intersections
c.x0 = 0
c.y0 = 0
c.r0 = 17.84
c.rmax =  60
# extract polar coordiantes of forest edge
# point A
dist.A <-  forest_edges.man.sub.e1.nogeo[i, "A_dist"]
azi.A <- forest_edges.man.sub.e1.nogeo[i, "A_azi"]
x.A <- round(dist.A*sin(azi.A*pi/200), digits = 12)       # this is: easting, longitude, RW ##test*pi/200
y.A <- round(dist.A*cos(azi.A*pi/200), digits = 12)       # this is: northing, latitude, HW ##test*pi/200
# point B
dist.B <- forest_edges.man.sub.e1.nogeo[i, "B_dist"]
azi.B <- forest_edges.man.sub.e1.nogeo[i, "B_azi"]
x.B <-  round(dist.B*sin(azi.B*pi/200), digits = 12)      # this is: easting, longitude, RW #test*pi/200
y.B <-  round(dist.B*cos(azi.B*pi/200), digits = 12)      # this is: northing, latitude, HW #test*pi/200
# calcualte slope (b1) and intercept (b0)
b1 <- (y.B- y.A)/(x.B - x.A)
b0 <- y.B - b1*x.B
b1
b0
# test
plot(x = c(x.B, x.A, 0), y = c(y.B, y.A, 0), add = T)
# calculate polar coordiantes of intersections of AB line with
x.1 <- intersection_line_circle(b0, b1, c.x0, c.y0,  c.rmax, coordinate = "x1") # this is: easting, longitude, RW
y.1 <- intersection_line_circle(b0, b1, c.x0, c.y0,  c.rmax, coordinate = "y1") # this is: northing, latitude, HW
x.2 <- intersection_line_circle(b0, b1, c.x0, c.y0,  c.rmax, coordinate = "x2") # this is: easting, longitude, RW
y.2 <- intersection_line_circle(b0, b1 ,c.x0, c.y0,  c.rmax, coordinate = "y2") # this is: northing, latitude, HW
x.1
y.1
x.2
y.2
# for edge form 1 we have to consider that the triangle has to be directed into the direction of the smaller half of the circle
# calculate coordiantes of the middle of thie line between inter_1 and inter_2
x_m_line = (x.1 + x.2)/2
y_m_line = (y.1 + y.2)/2
x_m_line
y_m_line
b1_MC
# calculate the parameters of the equation between the middle of the line and the centre of the circle
# here we have to consider that if the middle between the intersections is equal to the center of the circle,
# we cannot calculate the slope or intercept of the line between the center of AB line and center of the circle
# accordng to https://www.sofatutor.com/mathematik/videos/parallele-und-orthogonale-geraden#orthogonale-geraden
# we can create the function of a orthogonal line by the function:
# -1 = AB_b1 * MC_b1 <=> MC_b1 = -1/(AB_b1)
b1_MC = ortho_line(b1, c.x0, c.y0, parameter= "slope") # slope(c.x0, c.y0, x_m_line, y_m_line)
b1_MC
b0_MC =  ortho_line(b1, c.x0, c.y0, parameter= "intercept") # intercept(c.x0, c.y0, x_m_line, y_m_line)
b0_MC
# calcualte the x corrdiante of the interception of the line between M and the centre of the cirle and the circle at the given radio
X1_inter_MC = intersection_line_circle(b0_MC, b1_MC,  c.x0, c.y0,  c.rmax,  coordinate = "x1")
X2_inter_MC = intersection_line_circle(b0_MC, b1_MC,  c.x0, c.y0,  c.rmax,  coordinate = "x2")
# insert the intersection x corodinate in the line function to get the respective y coordinate
y1_inter_MC = intersection_line_circle(b0_MC, b1_MC,  c.x0, c.y0,  c.rmax,  coordinate = "y1")
y2_inter_MC = intersection_line_circle(b0_MC, b1_MC,  c.x0, c.y0,  c.rmax,  coordinate = "y2")
# distance between the intersections (inter_MC_1, inter_MC_2) to M on the line
dist_C_inter_1_MC = distance(X1_inter_MC, y1_inter_MC, x_m_line, y_m_line)
dist_C_inter_2_MC = distance(X2_inter_MC, y2_inter_MC, x_m_line, y_m_line)
# find the x and y coordinate of the intersection on the shorter side , which is the side to exlcude from the plot
X_inter_MC_shorter_side = ifelse(dist_C_inter_1_MC < dist_C_inter_2_MC, X1_inter_MC, X2_inter_MC)
Y_inter_MC_shorter_side = ifelse(dist_C_inter_1_MC < dist_C_inter_2_MC, y1_inter_MC, y2_inter_MC)
# creating the polar coordiantes of a turning point of a triangle by selecting the intersection of the
# line from the middle of the AB.inter-ray and the circle center (MC_line) with
# the 60m radius at the "shorter side" so the intersection of the MC_line with a 60m radius that has le lest distance to the MC point on the AB.inter-ray
turning.east <- X_inter_MC_shorter_side   # + my.center.easting
turning.north <- Y_inter_MC_shorter_side # + my.center.northing
turning.east
turning.north
# UTM coordiantes of corner points
x1.east <- x.1   # + my.center.easting
y1.north <- y.1  # + my.center.northing
x2.east <- x.2   # + my.center.easting
y2.north <- y.2  # + my.center.northing
# create dataframe that holds coordinates of the intersections of the AB line with a 60m radius and the turning pint of a diagonal line through the AB line with a 60m radius circle
triangle.e1.df <- as.data.frame(cbind("lon" = c(turning.east, x1.east, x2.east, turning.east),
"lat" = c(turning.north, y1.north, y2.north,  turning.north),
"plot_ID" = c(my.plot.id, my.plot.id, my.plot.id, my.plot.id),
"e_ID" = c(my.e.id, my.e.id, my.e.id, my.e.id),
"inv_year" = c(my.inv.year, my.inv.year, my.inv.year, my.inv.year)))
# this is a correction in case that either the base line of the triangle
# runs along with/ parallel to the y achis (meaning the b1 = Inf) or
# that the line from the middle of the trinangle base to the outer edge of the cirlce is parrallel to the y achsis and the b1_MC is Inf
triangle.e1.df <- triangle.e1.df %>%
mutate(lon = case_when(
# base line of triangle (edge line) is line from east to west (along x achsis)
b1_MC %in% c(Inf, -Inf) & row_number() %in% c(1, 4) & azi.A == 100 & azi.B == 300 &  is.na(lon) | # X turning point when A to B or B to A are a straight line along  x achsis (gon 100 and 300) so that the right-angle MC line runs from gon 0 to 200
b1_MC %in% c(Inf, -Inf) & row_number() %in% c(1, 4) & azi.A == 300 & azi.B == 100 &  is.na(lon) |
# base of triangle (edge line) is line from north to south (along y achsis)
b1 %in% c(Inf, -Inf) &  row_number() %in% c(2, 3) & azi.A == 0 & azi.B == 200 & is.na(lon)| # X1 when base of triable A to B runs along y-achsis (gon 0 and 200)
b1 %in% c(Inf, -Inf) & row_number() %in% c(2, 3) & azi.A == 200 & azi.B == 0 & is.na(lon)  ~ 0, # X2 when base of triable B to A runs along y-achsis (gon 0 and 200)
b1 %in% c(Inf, -Inf) &  row_number() %in% c(1, 4) & azi.A == 0 & azi.B == 200 & is.na(lon)| # X1 when base of triable A to B runs along y-achsis (gon 0 and 200)
b1 %in% c(Inf, -Inf) & row_number() %in% c(1, 4) & azi.A == 200 & azi.B == 0 & is.na(lon)  ~ -c.rmax,
# base of triangle is line parrallel to y achsis but not ON y-achsis:
b1 %in% c(Inf, -Inf) &  row_number() %in% c(1, 4) & x.A > 0 & x.B >0 & is.na(lon) ~ c.rmax, #  if the line is in the x >0 part of the circle, x of turning point had to be +60
b1 %in% c(Inf, -Inf) &  row_number() %in% c(1, 4) & x.A < 0 & x.B < 0 & is.na(lon) ~ -c.rmax, #  if the line is in the x >0 part of the circle, x of turning point had to be -60
TRUE ~ lon),
lat = case_when(
# base of triangle (edge line) is a line from east to west (along x achsis)
b1_MC %in% c(Inf, -Inf) & row_number() %in% c(1, 4) & azi.A == 100 & azi.B == 300 &  is.na(lat) | # Y turning point when A to B or B to A are a straight line along  x achsis (gon 100 and 300) so that the right-angle MC line runs from gon 0 to 200
b1_MC %in% c(Inf, -Inf) & row_number() %in% c(1, 4) & azi.A == 300 & azi.B == 100 &  is.na(lat) |
b1 %in% c(Inf, -Inf) &  row_number() == 3 & azi.A == 0 & azi.B == 200 & is.na(lat)|
b1 %in% c(Inf, -Inf) & row_number()==3 & azi.A == 200 & azi.B == 0 & is.na(lat)  ~ -c.rmax, # Y2 when base of triable B to A runs along y-achsis (gon 0 and 200)
# base line of triangle (edge line) is line from north to south (along y achsis)
b1 %in% c(Inf, -Inf) &  row_number() == 2 & azi.A == 0 & azi.B == 200 & is.na(lat)|
b1 %in% c(Inf, -Inf) & row_number()==2 & azi.A == 200 & azi.B == 0 & is.na(lat)  ~ c.rmax, # Y1 when base of triable B to A runs along y-achsis (gon 0 and 200)
b1 %in% c(Inf, -Inf) &  row_number() %in% c(1, 4) & azi.A == 0 & azi.B == 200 & is.na(lat)|
b1 %in% c(Inf, -Inf) & row_number() %in% c(1, 4) & azi.A == 200 & azi.B == 0 & is.na(lat)| # y turning point when base of triable A to B runs along y-achsis (gon 0 and 200)
# base of triangle is line parrallel to y achsis but not ON y-achsis:
b1 %in% c(Inf, -Inf) &  row_number() %in% c(1, 4) & x.A > 0 & x.B >0 & is.na(lat) |
b1 %in% c(Inf, -Inf) &  row_number() %in% c(1, 4) & x.A < 0 & x.B < 0 & is.na(lat) ~ 0,
TRUE ~ lat)
)
triangle.e1.df
# creating polygones in sf: https://stackoverflow.com/questions/61215968/creating-sf-polygons-from-a-dataframe
triangle.e1.poly <-  sfheaders::sf_polygon(obj = triangle.e1.df
, x = "lon"
, y = "lat"
, polygon_id = "e_ID")
print(plot(triangle.e1.poly, main = my.plot.id))
c.df <- as.data.frame(cbind("lon" = 0, "lat" = 0))
c.pt <- sf::st_as_sf(c.df, coords = c("lon", "lat"))
c.poly.17 <- sf::st_buffer(c.pt, 17.84)
c.poly.12 <- sf::st_buffer(c.pt, 12.62)
c.poly.5 <- sf::st_buffer(c.pt, 5.64)
c.poly.60 <-  sf::st_buffer(c.pt, 60.0)
# test
print(ggplot() +
ggtitle(my.plot.id)+
geom_sf(data = c.poly.60, aes(alpha = 0))+
geom_sf(data = c.poly.17, aes(alpha = 0))+
geom_sf(data = c.poly.12, aes(alpha = 0))+
geom_sf(data = c.poly.5, aes(alpha = 0))+
geom_sf(data = triangle.e1.poly, aes(alpha = 0))+
xlim(-80, 80)+
ylim(-80, 80))
# test
forest_edges$A_dist <- 1784
forest_edges$A_azi <- 50
forest_edges$B_dist <- 1784
forest_edges$B_azi <- 350
# ----- 0.6 harmonising column names & structure  -------------------------
# HBI locations
geo_loc <- geo_loc[1:12]
colnames(geo_loc) <- c("plot_ID", "ToEckId", "K2_RW",
"K2_HW", "K3_RW", "K3_HW", "RW_MED",
"HW_MED",  "LAT_MED",  "LON_MED",
"LAT_MEAN", "LON_MEAN")
# ----- 1.1.2.1. join in edge info to tree dataset ------------------------
# ----- 1.1.2.1.1. HBI join in forest edge info per plot -----------------------------------------------
trees_data <- trees_data %>%
# calculate the coordinates of every tree
mutate(dist_m = dist_cm/100,
X_tree = coord(data_circle$x0[1], data_circle$y0[1], dist_m, azi_gon, coordinate = "x"),
Y_tree = coord(data_circle$x0[1], data_circle$y0[1], dist_m, azi_gon, coordinate = "y")) %>%
# join in the forest edge information per plot
left_join(., forest_edges %>%
select(plot_ID, e_ID, e_type, e_form),
by = "plot_ID",
multiple = "all") # this is necesarry since there are, apperently, multiple edges per plot
# ----- 1.1.2.2. edge  point coordinates,  line parameters, intersections with circles -----------------------------------------------------------
# set up line from 2 points manually
forest_edges.man <- forest_edges %>%
filter(e_form %in% c("1", "2")) %>%
# convert distance from cm to m
mutate(across(c("A_dist", "B_dist", "T_dist"), ~ (.x)/100)) %>%
# find line parameters
# 1. calculate x and y coordinates for all edge points
mutate(X_A = ifelse(A_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], A_dist, A_azi, coordinate = "x"), NA), # if the value is marked -2 its equal to an NA
X_B = ifelse(B_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], B_dist, B_azi, coordinate = "x"), NA),
X_T = ifelse(T_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], T_dist, T_azi, coordinate = "x"), NA),
Y_A = ifelse(A_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], A_dist, A_azi, coordinate = "y"), NA), # if the value is marked -2 its equal to an NA
Y_B = ifelse(B_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], B_dist, B_azi, coordinate = "y"), NA),
Y_T = ifelse(T_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], T_dist, T_azi, coordinate = "y"), NA)) %>%
# 2. calcualte slope ß1 = (y2-y1)/(x2-x1) hight/width
mutate(b1_AB = ifelse(e_form == "1", slope(X_A, Y_A, X_B, Y_B), NA),
b1_AT = ifelse(e_form == "2", slope(X_T, Y_T, X_A, Y_A), NA),
b1_BT = ifelse(e_form == "2", slope(X_T, Y_T, X_B, Y_B), NA)) %>%
# 3. intercept of line with y-axis b0 : insert known point: XA YA
# Y_A = b1_AB*X_A + b0_AB -- -b1_AB*X_A --> b0_AB =  Y_A - b1_AB*X_A
mutate(b0_AB = ifelse(e_form == "1", intercept(X_A, Y_A,  X_B, Y_B), NA),
b0_AT = ifelse(e_form == "2", intercept(X_T, Y_T, X_A, Y_A), NA),
b0_BT = ifelse(e_form == "2", intercept(X_T, Y_T, X_B, Y_B), NA)) %>%
### 17m circle --> used for tree status also
# find x coordinate of the interception between line and 17.84m circle: insert line equation in circle equation (function: intersection_line_circle)
# for AB line
mutate(X1_inter_AB_17 = intersection_line_circle(b0_AB, b1_AB,  data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x1"),
X2_inter_AB_17 = intersection_line_circle(b0_AB, b1_AB, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x2"),
inter_status_AB_17 = intersection.status(intersection_line_circle(b0_AB, b1_AB,  data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x1"),
intersection_line_circle(b0_AB, b1_AB, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x2")),
# for AT line
X1_inter_AT_17 = intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x1"),
X2_inter_AT_17 = intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x2"),
inter_status_AT_17 = intersection.status(intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x1"),
intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x2")),
# for BT line
X1_inter_BT_17 = intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x1"),
X2_inter_BT_17 = intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x2"),
inter_status_BT_17 = intersection.status(intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x1"),
intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x2"))) %>%
# y intersection with 17m circle: insert x of intercept with circle in equation of line
# AB line
mutate(Y1_inter_AB_17 = intersection_line_circle(b0_AB, b1_AB,  data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="y1"),
Y2_inter_AB_17 = intersection_line_circle(b0_AB, b1_AB,  data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="y2"),
# AT line
Y1_inter_AT_17 = intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="y1"),
Y2_inter_AT_17 = intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="y2"),
# BT line
Y1_inter_BT_17 = intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="y1"),
Y2_inter_BT_17 = intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="y2")) %>%
# distance interception centre --> to see if points are actually placed on the rim of the circle
mutate(inter_1_dist = distance(X1_inter_AB_17, Y1_inter_AB_17, 0, 0)) %>%     # this is just to control if the whole thing worked and
# selecting intersections on the "right" side to check if point lies within triangle
# to calculate the triangles Barycentric coordinates we need 3 points: A, B, C = centre point
# in case T lies within the circle, we want R to select A and B from the intersection with the circle.
# Whereby we have to use a wider radius, to make sure that trees located the halfmoon of the circle cut by the triangle (Kreisbogen) are selected too.
# when t lies inside the circle (so both lines reach outside) ue only intersception point where direction between inter_AT and AT is equal choose this x, we need a buffer tho
# the following statement says:  check if the slope of x_inter_1  or the slope of x_inter_2 is equal to the slope of AT,
#                                choose the x which has the same slope (x_inter_1 or x_inter_2)as the second point on the line (A or B)
#                                but with a buffer of 60m radius, which is why it has to be newly calculated
# find the intercept of circle and line that prolonges the line between a and t or B and T via inter.for.triangle function
# if azimut T to A  identical to azimut T to intercept 1 A and circle use this intercept (inter_AT_1) for the triable, if azimut T to A identical to azimute T to intercept 2 between A and  circle use this intercept (inter_AT_2),
mutate(X_inter_AT_triangle_60 = inter.for.triangle(b0_AT, b1_AT, 0, 0, data_circle$rmax[3]*2, X_A, Y_A, X_T, Y_T, coordinate = "x"),
X_inter_BT_triangle_60 = inter.for.triangle(b0_BT, b1_BT, 0, 0, data_circle$rmax[3]*2, X_B, Y_B, X_T, Y_T, coordinate = "x"),
# calcualte y to the x that lie in the same direction then the second point on the line, if turning points lies witin circle and lines "reach out"
Y_inter_AT_triangle_60 = inter.for.triangle(b0_AT, b1_AT, 0, 0, data_circle$rmax[3]*2, X_A, Y_A, X_T, Y_T, coordinate = "y"),
Y_inter_BT_triangle_60 = inter.for.triangle(b0_BT, b1_BT, 0, 0, data_circle$rmax[3]*2, X_B, Y_B, X_T, Y_T, coordinate = "y"))
forest_edges.man
forest_edges.man.sub.e1.nogeo <-  forest_edges.man%>% filter(e_form == 1) # %>%
triangle.e1.list.nogeo <- vector("list", length = length(forest_edges.man.sub.e1.nogeo$plot_ID))
triangle.e1.coords.nogeo <- vector("list", length = length(forest_edges.man.sub.e1.nogeo$plot_ID)*4)
# select plot ID, edge form and edge_ID accordint to positioin in the list
my.plot.id <- forest_edges.man.sub.e1.nogeo[i, "plot_ID"]
my.e.id <- forest_edges.man.sub.e1.nogeo[i, "e_ID"]
my.e.form <- forest_edges.man.sub.e1.nogeo[i, "e_form"]
my.inv.year <- forest_edges.man.sub.e1.nogeo[i, "inv_year"]
# circle center and radius to calcualte intersections
c.x0 = 0
c.y0 = 0
c.r0 = 17.84
c.rmax =  60
# extract polar coordiantes of forest edge
# point A
dist.A <-  forest_edges.man.sub.e1.nogeo[i, "A_dist"]
azi.A <- forest_edges.man.sub.e1.nogeo[i, "A_azi"]
x.A <- round(dist.A*sin(azi.A*pi/200), digits = 12)       # this is: easting, longitude, RW ##test*pi/200
y.A <- round(dist.A*cos(azi.A*pi/200), digits = 12)       # this is: northing, latitude, HW ##test*pi/200
# point B
dist.B <- forest_edges.man.sub.e1.nogeo[i, "B_dist"]
azi.B <- forest_edges.man.sub.e1.nogeo[i, "B_azi"]
x.B <-  round(dist.B*sin(azi.B*pi/200), digits = 12)      # this is: easting, longitude, RW #test*pi/200
y.B <-  round(dist.B*cos(azi.B*pi/200), digits = 12)      # this is: northing, latitude, HW #test*pi/200
# calcualte slope (b1) and intercept (b0)
b1 <- (y.B- y.A)/(x.B - x.A)
b0 <- y.B - b1*x.B
b1
b0
# calculate polar coordiantes of intersections of AB line with
x.1 <- intersection_line_circle(b0, b1, c.x0, c.y0,  c.rmax, coordinate = "x1") # this is: easting, longitude, RW
y.1 <- intersection_line_circle(b0, b1, c.x0, c.y0,  c.rmax, coordinate = "y1") # this is: northing, latitude, HW
x.2 <- intersection_line_circle(b0, b1, c.x0, c.y0,  c.rmax, coordinate = "x2") # this is: easting, longitude, RW
y.2 <- intersection_line_circle(b0, b1 ,c.x0, c.y0,  c.rmax, coordinate = "y2") # this is: northing, latitude, HW
x.1
y.1
x.2
y.2
# for edge form 1 we have to consider that the triangle has to be directed into the direction of the smaller half of the circle
# calculate coordiantes of the middle of thie line between inter_1 and inter_2
x_m_line = (x.1 + x.2)/2
x_m_line
y_m_line
# for edge form 1 we have to consider that the triangle has to be directed into the direction of the smaller half of the circle
# calculate coordiantes of the middle of thie line between inter_1 and inter_2
x_m_line = (x.1 + x.2)/2
y_m_line = (y.1 + y.2)/2
y_m_line
x_m_line
# calculate the parameters of the equation between the middle of the line and the centre of the circle
# here we have to consider that if the middle between the intersections is equal to the center of the circle,
# we cannot calculate the slope or intercept of the line between the center of AB line and center of the circle
# accordng to https://www.sofatutor.com/mathematik/videos/parallele-und-orthogonale-geraden#orthogonale-geraden
# we can create the function of a orthogonal line by the function:
# -1 = AB_b1 * MC_b1 <=> MC_b1 = -1/(AB_b1)
b1_MC = ortho_line(b1, c.x0, c.y0, parameter= "slope") # slope(c.x0, c.y0, x_m_line, y_m_line)
b1_MC
b0_MC =  ortho_line(b1, c.x0, c.y0, parameter= "intercept") # intercept(c.x0, c.y0, x_m_line, y_m_line)
b0_MC
# calcualte the x corrdiante of the interception of the line between M and the centre of the cirle and the circle at the given radio
X1_inter_MC = intersection_line_circle(b0_MC, b1_MC,  c.x0, c.y0,  c.rmax,  coordinate = "x1")
X2_inter_MC = intersection_line_circle(b0_MC, b1_MC,  c.x0, c.y0,  c.rmax,  coordinate = "x2")
# insert the intersection x corodinate in the line function to get the respective y coordinate
y1_inter_MC = intersection_line_circle(b0_MC, b1_MC,  c.x0, c.y0,  c.rmax,  coordinate = "y1")
y2_inter_MC = intersection_line_circle(b0_MC, b1_MC,  c.x0, c.y0,  c.rmax,  coordinate = "y2")
# distance between the intersections (inter_MC_1, inter_MC_2) to M on the line
dist_C_inter_1_MC = distance(X1_inter_MC, y1_inter_MC, x_m_line, y_m_line)
dist_C_inter_2_MC = distance(X2_inter_MC, y2_inter_MC, x_m_line, y_m_line)
# find the x and y coordinate of the intersection on the shorter side , which is the side to exlcude from the plot
X_inter_MC_shorter_side = ifelse(dist_C_inter_1_MC < dist_C_inter_2_MC, X1_inter_MC, X2_inter_MC)
Y_inter_MC_shorter_side = ifelse(dist_C_inter_1_MC < dist_C_inter_2_MC, y1_inter_MC, y2_inter_MC)
# creating the polar coordiantes of a turning point of a triangle by selecting the intersection of the
# line from the middle of the AB.inter-ray and the circle center (MC_line) with
# the 60m radius at the "shorter side" so the intersection of the MC_line with a 60m radius that has le lest distance to the MC point on the AB.inter-ray
turning.east <- X_inter_MC_shorter_side   # + my.center.easting
turning.north <- Y_inter_MC_shorter_side # + my.center.northing
# UTM coordiantes of corner points
x1.east <- x.1   # + my.center.easting
y1.north <- y.1  # + my.center.northing
x2.east <- x.2   # + my.center.easting
y2.north <- y.2  # + my.center.northing
# create dataframe that holds coordinates of the intersections of the AB line with a 60m radius and the turning pint of a diagonal line through the AB line with a 60m radius circle
triangle.e1.df <- as.data.frame(cbind("lon" = c(turning.east, x1.east, x2.east, turning.east),
"lat" = c(turning.north, y1.north, y2.north,  turning.north),
"plot_ID" = c(my.plot.id, my.plot.id, my.plot.id, my.plot.id),
"e_ID" = c(my.e.id, my.e.id, my.e.id, my.e.id),
"inv_year" = c(my.inv.year, my.inv.year, my.inv.year, my.inv.year)))
triangle.e1.df
b1_MC
b0_MC
install.packages("usethis")
install.packages('RPostgreSQL')
install.packages("RPostgres")
install.packages("RPostgres")
install.packages("DBI")
install.packages("DBI")
require(usethis)
library(RPostgreSQL)
install.packages("usethis")
install.packages('RPostgreSQL')
install.packages("RPostgres")
install.packages("DBI")
install.packages("here")
install.packages("readr")
install.packages("tidyverse")
install.packages("tibble")
install.packages("dplyr")
install.packages("data.table")
install.packages("broom")
install.packages("purrr")
install.packages("devtools")
install.packages("plyr")
install.packages("RODBC")
install.packages("rstudioapi")
install.packages("gsubfn")
install.packages("sjmisc")
## laTex
install.packages("stargazer")  #for compatability with Latex
install.packages("tikzDevice") #for compatability with Latex#
# visualisation
install.packages("ggthemes")
install.packages("ggplot2")
install.packages("reshape2") #for multiple y values
install.packages("ggforce") #for zooming in parts of the plot
install.packages("ggrepel")
options(tz="CA")
install.packages("reshape2")
install.packages("gridExtra")
# analysis
install.packages("corrplot")
install.packages("AICcmodavg")
# forest related
install.packages("forestmangr")
install.packages("rBDAT")
install.packages("TapeR")
install.packages("pkgbuild")
require("devtools")
if (! require("remotes"))
install.packages("remotes")
#   remotes::install_gitlab("vochr/tapes", build_vignettes = TRUE)
#  remotes::install_gitlab("vochr/TapeS", build_vignettes = TRUE)
install.packages("magrittr")
if(!require(devtools)) install.packages("devtools")
devtools::install_github("kassambara/ggcorrplot")
# spatial
install.packages("sf")
install.packages("rgdal")
install.packages("terra")
install.packages("sfheaders")
install.packages("here")
install.packages("tidyverse")
install.packages("DBI")
install.packages("RPostgres")
install.packages("usethis")
install.packages("devtools")
install.packages("rstudioapi")
install.packages("plyr")
install.packages("purrr")
install.packages("broom")
install.packages("reshape2")
install.packages("reshape2")
install.packages("forestmangr")
install.packages("AICcmodavg")
install.packages("sf")
install.packages("magrittr")
install.packages("magrittr")
install.packages("sf")
install.packages("AICcmodavg")
install.packages("forestmangr")
install.packages("reshape2")
install.packages("reshape2")
install.packages("broom")
install.packages("plyr")
install.packages("purrr")
install.packages("rstudioapi")
install.packages("devtools")
install.packages("RPostgres")
install.packages("usethis")
install.packages("DBI")
install.packages("tidyverse")
install.packages("here")

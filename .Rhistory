# # assign crs
#my.utm.epsg <- "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs +type=crs"
# # select UTM corrdinates of the plot center
#my.center.easting <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "RW_MED"]
#my.center.northing <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "HW_MED"]
# extract polar coordiantes of forest edge
# point A
dist.tree <- trees.one.edge.nogeo[i, "dist_cm"]/100
azi.tree <- trees.one.edge.nogeo[i, "azi_gon"]
x.tree <- dist.tree*sin(azi.tree)   # longitude, easting, RW, X
y.tree <- dist.tree*cos(azi.tree)   # latitude, northing, HW, y
# transform polar into cartesian coordiantes
tree.east <- x.tree #+ my.center.easting
tree.north <-  y.tree # + my.center.northing
# save cartesian coordiantes in dataframe
tree.coord.df <- as.data.frame(cbind(
"plot_ID" = c(as.integer(my.plot.id)),
"tree_ID" = c(as.integer(my.tree.id)),
"inv" = c(my.inv),
"lon" = c(tree.east),
"lat" = c(tree.north)
))
# create sf point object from dataframe
#https://stackoverflow.com/questions/52551016/creating-sf-points-from-multiple-lat-longs
tree.sf <-  sf::st_as_sf(tree.coord.df, coords = c("lon", "lat"), remove = FALSE)
# assing CRS to points
#sf::st_crs(tree.sf) <- my.utm.epsg
# print(plot(my.inter$geometry),
#      plot(my.rem.circle$geometry, add = T),
#      plot(tree.sf$geometry, add = T)
#     )
inter.tree.circle <- sf::st_intersection(tree.sf, my.rem.circle)
inter.tree.edge <- sf::st_intersection(tree.sf, my.inter)
tree_status <- ifelse(nrow(inter.tree.edge)!= 0, my.inter$stand,
ifelse(nrow(inter.tree.circle) != 0,  my.rem.circle$stand,
"warning"))
tree.status.list.nogeo[[i]] <- as.data.frame(cbind(
"plot_ID" = c(as.integer(my.plot.id)),
"tree_ID" = c(as.integer(my.tree.id)),
"inv" = c(my.inv),
"lon" = c(as.numeric(tree.coord.df$lon)),
"lat" = c(as.numeric(tree.coord.df$lat)),
"t_stat" = c(tree_status)))
# export tree points as sf
tree.points.list.nogeo[[i]] <- c("t_stat" = tree_status, tree.sf)
}
# save tree corodiantes and status into dataframe
tree.status.list.one.edge.final.nogeo <- rbindlist(tree.status.list.nogeo)
tree.status.one.edge.df.nogeo <- as.data.frame(tree.status.list.one.edge.final.nogeo)
# save tree sf into dataframe
tree.points.list.one.edge.final.nogeo <- rbindlist(tree.points.list.nogeo)
tree.points.one.edge.df.nogeo <- as.data.frame(tree.points.list.one.edge.final.nogeo)
# 3.2.2.2. plots with 2 edges: sorting trees into edge and remaining circle polygones ---------
# intersection of trees with 2 edges
trees.two.edges.nogeo <- HBI_trees %>%
# filter only for trees that are located in plots with a forest edge
semi_join(forest_edges_HBI.man %>% filter(e_form == 1 | e_form == 2) %>%
#& inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%
select(plot_ID) %>% distinct(), by = "plot_ID") %>%
# filter for trees located in plots htat haev only one forest edge
semi_join(forest_edges_HBI.man %>% filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%
group_by(plot_ID) %>% summarise(n = n()) %>% filter(n > 1) %>% select(plot_ID), by = "plot_ID") #%>%
tree.status.two.edges.list.nogeo <- vector("list", length = length(trees.two.edges.nogeo$tree_ID))
tree.points.two.edges.list.nogeo <- vector("list", length = length(trees.two.edges.nogeo$tree_ID))
for (i in 1:length(trees.two.edges.nogeo$tree_ID)){
# i = 1
# i = which(grepl(50122, (trees.two.edges.nogeo$plot_ID)))[2]
# select plot ID accordint to positioin in the list
my.plot.id <- trees.two.edges.nogeo[i, "plot_ID"]
my.tree.id <- trees.two.edges.nogeo[i, "tree_ID"]
my.inv <- trees.two.edges.nogeo[i, "inv"]
# select the remaining cirlce we want to intersect the tree with
my.rem.circle <- sf::st_as_sf(rem.circle.two.edges.df.nogeo %>% filter(plot_ID == my.plot.id) %>% distinct())
my.edges.df <- inter.poly.two.edges.df.nogeo %>% filter(plot_ID == my.plot.id) %>% distinct() %>% arrange(e_ID)
my.inter.1 <- sf::st_as_sf(my.edges.df[1,])
my.inter.2 <- sf::st_as_sf(my.edges.df[2,])
# assign stand category to the polygones depending on which one is bigger/ smaller:
# bigger polygone/ polygone with greater area is assigned to category A, smaller area polygone is assigned to B
area.plot.df <- edges.area.two.edges.df.nogeo %>% filter(plot_ID == my.plot.id & CCS_r_m == 17.84) %>%
arrange(as.numeric(area_m2)) %>%
mutate(stand = case_when(
row_number()== 1 ~ "C",
row_number()== 2 ~ "B",
row_number()== 3 ~ "A",
TRUE ~ NA))
# assign stand category to the polygones depending on which one is bigger/ smaller
my.rem.circle$stand <- area.plot.df$stand[area.plot.df$e_ID == 0]
my.inter.1$stand <- area.plot.df$stand[area.plot.df$e_ID == 1]
my.inter.2$stand <- area.plot.df$stand[area.plot.df$e_ID == 2]
# # assign crs
# my.utm.epsg <- "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs +type=crs"
# # select UTM corrdinates of the plot center
# my.center.easting <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "RW_MED"]
# my.center.northing <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "HW_MED"]
# extract polar coordiantes of forest edge
# point A
dist.tree <- trees.two.edges.nogeo[i, "dist_cm"]/100
azi.tree <- trees.two.edges.nogeo[i, "azi_gon"]
x.tree <- dist.tree*sin(azi.tree)   # longitude, easting, RW, X
y.tree <- dist.tree*cos(azi.tree)   # latitude, northing, HW, y
# transform polar into cartesian coordiantes
tree.east <- x.tree  # + my.center.easting
tree.north <- y.tree # + my.center.northing
# save cartesian coordiantes in dataframe
tree.coord.df <- as.data.frame(cbind(
"plot_ID" = c(as.integer(my.plot.id)),
"tree_ID" = c(as.integer(my.tree.id)),
"inv" = c(my.inv),
"lon" = c(tree.east),
"lat" = c(tree.north)
))
# create sf point object from dataframe
#https://stackoverflow.com/questions/52551016/creating-sf-points-from-multiple-lat-longs
tree.sf <-  sf::st_as_sf(tree.coord.df, coords = c("lon", "lat"), remove = FALSE)
# assing CRS to points
#sf::st_crs(tree.sf) <- my.utm.epsg
# print(plot(my.rem.circle$geometry, col = "red"),
#       plot(my.inter.2$geometry, add = T),
#       plot(my.inter.1$geometry, add = T),
#       plot(tree.sf$geometry, add = T)
#       )
inter.tree.circle <- sf::st_intersection(tree.sf, my.rem.circle)
inter.tree.edge.1 <- sf::st_intersection(tree.sf, my.inter.1)
inter.tree.edge.2 <- sf::st_intersection(tree.sf, my.inter.2)
tree_status <- ifelse(nrow(inter.tree.edge.1)!= 0 & nrow(inter.tree.edge.2)== 0 & nrow(inter.tree.circle)== 0,  my.inter.1$stand,                     # if tree is in edge 1
ifelse(nrow(inter.tree.edge.2)!= 0 & nrow(inter.tree.edge.1)== 0 & nrow(inter.tree.circle)== 0,  my.inter.2$stand,              # if tree is in edge 2
ifelse(nrow(inter.tree.circle)!= 0 & nrow(inter.tree.edge.1)== 0 & nrow(inter.tree.edge.2)== 0,  my.rem.circle$stand,    # if tree is in circle
#ifelse(nrow(inter.tree.circle)== 0 & nrow(inter.tree.edge.1)!= 0 & nrow(inter.tree.edge.2)!= 0,  "warning",       # if tree is in two edges
"warning")))                                                                                             # if tree is nowhere
tree.status.two.edges.list.nogeo[[i]] <- as.data.frame(cbind(
"plot_ID" = c(as.integer(my.plot.id)),
"tree_ID" = c(as.integer(my.tree.id)),
"inv" = c(my.inv),
"lon" = c(as.numeric(tree.coord.df$lon)),
"lat" = c(as.numeric(tree.coord.df$lat)),
"t_stat" = c(tree_status)))
tree.points.two.edges.list.nogeo[[i]] <- c("t_stat" = tree_status, tree.sf)
}
# save tree corodiantes and status into dataframe
tree.status.list.two.edges.final.nogeo <- rbindlist(tree.status.two.edges.list.nogeo)
tree.status.two.edges.df.nogeo <- as.data.frame(tree.status.list.two.edges.final.nogeo)
# save tree sf into dataframe
tree.points.list.two.edges.final.nogeo <- rbindlist(tree.points.two.edges.list.nogeo)
tree.points.two.edges.df.nogeo <- as.data.frame(tree.points.list.two.edges.final.nogeo)
# bind the tree point datafarmes of one and two edges plots together
two.and.one.edge.trees.points.df.nogeo <- rbind(tree.points.one.edge.df.nogeo,tree.points.two.edges.df.nogeo) %>% mutate(plot_ID = as.integer(plot_ID))
# 3.2.2.3 plots with no edge edge: sorting trees into circle ---------
trees.no.edge.nogeo <- anti_join(HBI_trees, two.and.one.edge.trees.points.df.nogeo %>% select(plot_ID) %>% distinct(), by = "plot_ID")
tree.status.no.edge.list.nogeo <- vector("list", length = length(trees.no.edge.nogeo$tree_ID))
tree.points.no.edge.list.nogeo <- vector("list", length = length(trees.no.edge.nogeo$tree_ID))
for (i in 1:length(trees.no.edge.nogeo$tree_ID)){
#i =1
#i = which(grepl(50080, unique(trees.one.edge$plot_ID)))
# select plot ID accordint to positioin in the list
my.plot.id <- trees.no.edge.nogeo[i, "plot_ID"]
my.tree.id <- trees.no.edge.nogeo[i, "tree_ID"]
my.inv <- trees.two.edges.nogeo[i, "inv"]
# extract polar coordiantes of forest edge
# point A
dist.tree <- trees.no.edge.nogeo[i, "dist_cm"]/100
azi.tree <- trees.no.edge.nogeo[i, "azi_gon"]
x.tree <- dist.tree*sin(azi.tree)   # longitude, easting, RW, X
y.tree <- dist.tree*cos(azi.tree)   # latitude, northing, HW, y
# transform polar into cartesian coordiantes
tree.east <- x.tree  # + my.center.easting
tree.north <- y.tree # + my.center.northing
# save cartesian coordiantes in dataframe
tree.coord.df <- as.data.frame(cbind(
"plot_ID" = c(as.integer(my.plot.id)),
"tree_ID" = c(as.integer(my.tree.id)),
"inv" = c(my.inv),
"lon" = c(as.numeric(tree.east)),
"lat" = c(as.numeric(tree.north))
))
# create sf point object from dataframe
#https://stackoverflow.com/questions/52551016/creating-sf-points-from-multiple-lat-longs
tree.sf <-  sf::st_as_sf(tree.coord.df, coords = c("lon", "lat"), remove = FALSE)
# assing CRS to points
#sf::st_crs(tree.sf) <- my.utm.epsg
# select the UTM coordiantes of the center of the cirlce corresponding with the plot ID
# my.center.easting <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "RW_MED"]
# my.center.northing <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "HW_MED"]
#### build circle
# circle data
c.x0 = 0  # + my.center.easting
c.y0 = 0  # + my.center.northing
c.r3 = 17.84
c.r2 = 12.62
c.r1 = 5.64
# build polygon (circlular buffer) around center point
center.df<- as.data.frame(cbind("lon" = c.x0, "lat" = c.y0))
# center.df <- as.data.frame(cbind("lon" = my.center.easting, "lat" = my.center.northing))
circle.pt <- sf::st_as_sf(center.df, coords = c("lon", "lat"))
circle.17 <- sf::st_buffer(circle.pt, c.r3)
circle.12 <- sf::st_buffer(circle.pt, c.r2)
circle.5 <- sf::st_buffer(circle.pt, c.r1)
inter.tree.circle.17 <- sf::st_intersection(tree.sf, circle.17)
# if a tree is not intersecting with the circle or its exactly at the edge of the cirlce the inter.tree.circle.17 will be empty,
# however, trees that are exactly 17.84 meters apart from the circle center would still be part of the plot, tho the polygones won´t detect and intersection
# which is why trees only receive the status "warning" if they are acturally situated outside of the circle
tree_status <- ifelse(nrow(inter.tree.circle.17) == 0 & dist.tree > 17.84,  "warning", "A")                                                                                            # if tree is nowhere
tree.status.no.edge.list.nogeo[[i]] <- as.data.frame(cbind(
"plot_ID" = c(as.integer(my.plot.id)),
"tree_ID" = c(as.integer(my.tree.id)),
"inv" = c(my.inv),
"lon" = c(as.numeric(tree.coord.df$lon)),
"lat" = c(as.numeric(tree.coord.df$lat)),
"t_stat" = c(tree_status))
)
tree.points.no.edge.list.nogeo[[i]] <- c("t_stat" = tree_status, tree.sf)
}
# save tree corodiantes and status into dataframe
tree.status.no.edges.final.nogeo <- rbindlist(tree.status.no.edge.list.nogeo)
tree.status.no.edges.df.nogeo <- as.data.frame(tree.status.no.edges.final.nogeo)
# save tree sf into dataframe
tree.points.list.no.edges.final.nogeo <- rbindlist(tree.points.no.edge.list.nogeo)
tree.points.no.edges.df.nogeo <- as.data.frame(tree.points.list.no.edges.final.nogeo)
# bind all tree point.sf dataframes (with & without edges together)
all.trees.points.df.nogeo <-
rbind(two.and.one.edge.trees.points.df.nogeo ,
tree.points.no.edges.df.nogeo) %>%
mutate(across(plot_ID:tree_ID, ~ as.integer(.x))) %>%
left_join(., trees_and_edges %>%
select(plot_ID, tree_ID, DBH_cm),
by = c("plot_ID", "tree_ID"),
multiple = "all")
# bind all tree status dataframes together (one edge, two edges, no edge plots)
all.trees.status.df <-
rbind(tree.status.no.edges.df.nogeo,
tree.status.one.edge.df.nogeo,
tree.status.two.edges.df.nogeo)
# 3.3. data export ---------------------------------------------------------------------------------------------------------
# 3.3.1. data prep for export -----------------------------------------------------------------------------------------------
# 3.3.1.1. harmonzing strings for join --------------------------------------------------------
# harmonize strings of all.trees.status.df and
# https://stackoverflow.com/questions/20637360/convert-all-data-frame-character-columns-to-factors
all.trees.status.df[,c(1,2, 4, 5)] <- lapply(all.trees.status.df[,c(1,2, 4, 5)], as.numeric)
all.edges.area.df.nogeo[,c(1,2, 3, 5)] <- lapply(all.edges.area.df.nogeo[,c(1,2, 3, 5)], as.numeric)
# 3.3.1.2. join tree stand status and plot areas into trees dataset  --------------------------------------------------------
HBI_trees_update_1 <- HBI_trees %>%
# join in stand of each tree
left_join(., all.trees.status.df %>%
select(plot_ID, tree_ID, inv, t_stat) %>%
distinct(),
by = c("plot_ID", "tree_ID", "inv")) %>%
rename(stand = t_stat) %>%
# then join in plot area the tree reffers to due to it´s DBH which determines the sampling circuit it was found in
# asssing corect samling circle diameter according to DBH of the tree to be able to join in the right plot area
mutate(CCS_r_m = case_when(DBH_cm >= 7  & DBH_cm < 10 ~ 5.64,
DBH_cm >= 10 & DBH_cm < 30 ~ 12.62,
DBH_cm >= 30 ~ 17.84,
TRUE ~ NA)) %>%
# join in the area that belongs to the tree according to the CCS the tree was measured in/ belongs to
left_join(., all.edges.area.df.nogeo %>%
select(plot_ID, inter_stat, CCS_r_m, stand, area_m2),
by = c("plot_ID", "CCS_r_m", "stand")) %>%
# if there was no plot area claualted due to the fact that there is no edger at the plot,
# we calcualte the area from the sampling circuit diameter assign under CCD_r_m
mutate(area_m2 = ifelse(is.na(e_ID) & is.na(area_m2) |
# for trees alloceted to a in a cirlce without intersections wil not run throuhg the loops
# thus they do  have an edge ID but no calcualted areas or assigned intersection status
# therefore we have to calculate their area manually subsequently
# trees with the status "warning" will not have any stand and area from the dataset "all.edges.area.df.nogeo" assigned
# as this stand category doesn´t exist
# trees with the status "warning" will be excluded from the analysis
stand == "A" & inter_stat != "partly intersecting" & is.na(area_m2) |
stand == "A" & is.na(inter_stat) & is.na(area_m2), c_A(CCS_r_m), area_m2),
plot_A_ha = as.numeric(area_m2)/10000)  # dividedd by 10 000 to transform m2 into hectar
# 3.3.1.3. sort trees into remove and process on datasets by status "warning" --------------------------------------------------------
HBI_trees_removed_1 <- HBI_trees_update_1 %>% filter(stand == "warning")
HBI_trees_update_1 <- HBI_trees_update_1 %>% filter(stand != "warning")
# 3.3.1.4.  binding datasets together ----------------------------------------------------------
all.triangle.polys.df.nogeo <- rbind(triangle.e1.poly.df.nogeo, triangle.e2.poly.df.nogeo)
all.edge.intersections.poly  <- rbind(inter.poly.one.edge.df.nogeo , inter.poly.two.edges.df.nogeo)#%>% nest("geometry" = geometry)
all.remaning.circles.poly <- rbind(rem.circle.one.edge.df.nogeo, rem.circle.two.edges.df.nogeo) #%>% nest("geometry" = geometry)
all.triangle.coords.df.nogeo <- rbind(triangle.e1.coords.df.nogeo, triangle.e2.coords.df.nogeo) %>%
# the exportet polygones only include the widest cirlce intersection at 17.84m radius
mutate(CCS_r_m = 17.84) %>%
# join in the stand info by plot_ID, e_ID, CCS_r_M
left_join(., all.edges.area.df.nogeo %>% select(plot_ID, e_ID, CCS_r_m, stand),
by = c("plot_ID", "e_ID", "CCS_r_m"))
# exporting tree and edge/ plot area data
write.csv2(HBI_trees_update_1, paste0(out.path.BZE3, paste(unique(HBI_trees_update_1$inv)[1], "trees_update_1", sep = "_"), ".csv"))
write.csv2(HBI_trees_removed_1, paste0(out.path.BZE3, paste(unique(HBI_trees_removed_1$inv)[1], "trees_removed_1", sep = "_"), ".csv"))
write.csv2(trees_and_edges, paste0(out.path.BZE3, paste(unique(HBI_trees_update_1$inv)[1], "LT_edges", sep = "_"), ".csv"))
# export tree stand status of all trees nomatter if they have one, two or no forest edges at their plot
write.csv2(all.trees.status.df, paste0(out.path.BZE3, paste(unique(HBI_trees_update_1$inv)[1], "all_trees_stand", sep = "_"), ".csv"))
# export areas and stand info of all sampling circuits, edges and remaining circles
write.csv2(all.edges.area.df.nogeo,  paste0(out.path.BZE3, paste(unique(HBI_trees_update_1$inv)[1], "all_edges_rem_circles", sep = "_"), ".csv"))
# export list of plots where the both edge polygones intersect within the 17.84 radius
write.csv2(intersection.two.edges.warning.df.nogeo,  paste0(out.path.BZE3, paste(unique(HBI_trees_update_1$inv)[1], "edges_intersecting_warning", sep = "_"), ".csv"))
# exporting edge triangle polygones
write.csv2(all.triangle.polys.df.nogeo, paste0(out.path.BZE3, paste(unique(HBI_trees_update_1$inv)[1], "all_edges_triangle_poly", sep = "_"), ".csv"))
# exporting edge triangle coordiantes
write.csv2(all.triangle.coords.df.nogeo, paste0(out.path.BZE3, paste(unique(HBI_trees_update_1$inv)[1], "all_edges_triangle_coords", sep = "_"), ".csv"))
# exporting edge intersection polygones
#write.csv2(all.edge.intersections.poly, paste0(out.path.BZE3, paste(unique(HBI_trees_update_1$inv)[1], "all_edges_intersection_poly", sep = "_"), ".csv"))
# to export the dataframes with long geometries and keep the geometries in list format for better processing later
# thus we export them with the following function, that enables to save the whole geometry list in 1 Table
# https://stackoverflow.com/questions/48024266/save-a-data-frame-with-list-columns-as-csv-file
tibble_with_lists_to_csv(all.edge.intersections.poly %>% nest("geometry" = geometry), paste0(out.path.BZE3, paste(unique(HBI_trees_update_1$inv)[1], "all_edges_intersection_poly", sep = "_"), ".csv"))
# exporting all remaining circles polygones
tibble_with_lists_to_csv(all.remaning.circles.poly %>% nest("geometry" = geometry), paste0(out.path.BZE3, paste(unique(HBI_trees_update_1$inv)[1], "all_edges_rem_circles_poly", sep = "_"), ".csv"))
## export coordiantes of all edge-triangle-circle-intersections polygones  to  dataframes
all.edge.intersections.coords.list <- vector("list", length = nrow(unique(all.edge.intersections.poly[, c("plot_ID", "e_ID")])))
for (i in 1:nrow(unique(all.edge.intersections.poly[, c("plot_ID", "e_ID")]))) {
# i = 1
all.edge.intersections.coords.list[[i]] <- as.data.frame(cbind(
"plot_ID" = c(all.edge.intersections.poly$plot_ID[i]),
"e_ID" = c(all.edge.intersections.poly$e_ID[i]),
"e_form" = c(all.edge.intersections.poly$e_form[i]),
"lon" = (as_tibble(st_coordinates(all.edge.intersections.poly$geometry[i])) %>% select("X", -c( "L1", "L2"))),
"lat" = (as_tibble(st_coordinates(all.edge.intersections.poly$geometry[i])) %>% select("Y", -c( "L1", "L2")))
))
}
all.edge.intersections.coords.list.final <- rbindlist(all.edge.intersections.coords.list)
all.edge.intersections.coords.df <- as.data.frame(all.edge.intersections.coords.list.final) %>%
# the exportet polygones only include the widest cirlce intersection at 17.84m radius
mutate(CCS_r_m = 17.84) %>%
# join in the stand info by plot_ID, e_ID, CCS_r_M
left_join(., all.edges.area.df.nogeo %>% select(plot_ID, e_ID, CCS_r_m, stand),
by = c("plot_ID", "e_ID", "CCS_r_m"))
write.csv2(all.edge.intersections.coords.df,  paste0(out.path.BZE3, paste(unique(HBI_trees_update_1$inv)[1], "all_edges_intersection_coords", sep = "_"), ".csv"))
## export coordiantes of all remaining polygones  to  dataframes
all.rem.circle.coords.list <- vector("list", length = nrow(unique(all.remaning.circles.poly[, c("plot_ID", "e_ID")])))
for (i in 1:nrow(unique(all.remaning.circles.poly[, c("plot_ID", "e_ID")]))) {
# i = 1
all.rem.circle.coords.list[[i]] <- as.data.frame(cbind(
"plot_ID" = c(all.remaning.circles.poly$plot_ID[i]),
"e_ID" = c(all.remaning.circles.poly$e_ID[i]),
"e_form" = c(all.remaning.circles.poly$e_form[i]),
"lon" = (as_tibble(st_coordinates(all.remaning.circles.poly$geometry[i])) %>% select("X", -c( "L1", "L2"))),
"lat" = (as_tibble(st_coordinates(all.remaning.circles.poly$geometry[i])) %>% select("Y", -c( "L1", "L2")))
))
}
all.rem.circle.coords.list.final <- rbindlist(all.rem.circle.coords.list)
all.rem.circle.coords.df <- as.data.frame(all.rem.circle.coords.list.final) %>%
# the exportet polygones only include the widest cirlce intersection at 17.84m radius
mutate(CCS_r_m = 17.84) %>%
# join in the stand info by plot_ID, e_ID, CCS_r_M
left_join(., all.edges.area.df.nogeo %>% select(plot_ID, e_ID, CCS_r_m, stand),
by = c("plot_ID", "e_ID", "CCS_r_m"))
write.csv2(all.rem.circle.coords.df,  paste0(out.path.BZE3, paste(unique(HBI_trees_update_1$inv)[1], "all_rem_circles_coords", sep = "_"), ".csv"))
# 3.4. visulaizing for all plots, edges, trees -------------------------
dev.off()
for(i in 1:(nrow(HBI_trees %>% select(plot_ID) %>% distinct()))){
# https://ggplot2.tidyverse.org/reference/ggsf.html
#i = 2
# i = which(grepl(50141, unique(HBI_trees$plot_ID)))
my.plot.id = unique(HBI_trees$plot_ID)[i]
#print(my.plot.id)
c.df <- as.data.frame(cbind("lon" = 0, "lat" = 0))
c.pt <- sf::st_as_sf(c.df, coords = c("lon", "lat"))
c.poly.17 <- sf::st_buffer(c.pt, 17.84)
c.poly.12 <- sf::st_buffer(c.pt, 12.62)
c.poly.5 <- sf::st_buffer(c.pt, 5.64)
print(ggplot() +
ggtitle(my.plot.id)+
geom_sf(data = c.poly.17, aes(alpha = 0))+
geom_sf(data = c.poly.12, aes(alpha = 0))+
geom_sf(data = c.poly.5, aes(alpha = 0))+
geom_sf(data = triangle.e1.poly.df.nogeo$geometry[triangle.e1.poly.df.nogeo$plot_ID == my.plot.id], aes(alpha = 0))+
geom_sf(data = triangle.e2.poly.df.nogeo$geometry[triangle.e2.poly.df.nogeo$plot_ID == my.plot.id], aes(alpha = 0))+
geom_sf(data = all.trees.points.df.nogeo$geometry[all.trees.points.df.nogeo$plot_ID == my.plot.id],
aes(color = all.trees.points.df.nogeo$t_stat[all.trees.points.df.nogeo$plot_ID == my.plot.id],
size =  all.trees.points.df.nogeo$DBH_cm[all.trees.points.df.nogeo$plot_ID == my.plot.id]))+
guides(color=guide_legend(title="tree status"))+
guides(size=guide_legend(title="DBH cm"))+
geom_sf_text(data = all.trees.points.df.nogeo$geometry[all.trees.points.df.nogeo$plot_ID == my.plot.id],
aes(label = all.trees.points.df.nogeo$tree_ID[all.trees.points.df.nogeo$plot_ID == my.plot.id]))+
xlim(-30, 30)+
ylim(-30, 30)
)
}
all_areas_stands
# 0.4 data prep: harmonise strings, assign columnnames etc. ---------------------------------------------------------------------
# assign column names
# bund_nr     pk_nr      pk_richtung     pk_dist     pk_aufnahme      pk_maxdist
colnames(HBI_RG_loc) <- c("plot_ID", "CCS_nr", "CCS_position",  "CCS_dist", "RG_inv_status", "CCS_max_dist_cm", "inv_year")
#  "bund_nr"  "pk_nr"  "lfd_nr"   "bart"  "hoehe"    "grklasse"
colnames(HBI_RG) <- c("plot_ID", "CCS_no", "t_ID", "SP_code", "H_cm", "D_class_cm", "inv_year")
# 1. calculations ---------------------------------------------------------
# 1.1. assign gon according to exposition --------------------------------
HBI_RG_loc <- HBI_RG_loc %>%
mutate(inv = inv_name(inv_year)) %>%
left_join(., HBI_forest_edges %>% select(plot_ID, e_ID, e_form), by = "plot_ID", multiple = "all") %>%
mutate(CCS_gon = case_when(CCS_position == "n" ~ 0,
CCS_position == "o" ~ 100,
CCS_position == "s" ~ 200,
CCS_position == "w" ~ 300,
CCS_position == "nw" ~ 350,
CCS_position == "no" ~ 50,
CCS_position == "sw" ~ 250,
CCS_position == "so" ~ 150,
TRUE ~ NA),
# if the max distance of the last plant in the RG CCS is not measured we assume it´s 5m or 500cm
CCS_max_dist_cm = ifelse(CCS_max_dist_cm == -9 | is.na(CCS_max_dist_cm), 500, CCS_max_dist_cm))
HBI_RG_loc
# ----- 0.1. packages and functions --------------------------------------------
source(paste0(getwd(), "/scripts/00_functions_library.R"))
# ----- 0.2. working directory -------------------------------------------------
here::here()
getwd()
out.path.BZE3 <- ("output/out_data/out_data_BZE/")
# ----- 0.3 data import --------------------------------------------------------
# regeneration
# this dataset contains the plant specific inventory data of the regenertaion inventory of the HBI (BZE2)
HBI_RG <- read.delim(file = here("data/input/BZE2_HBI/bejb.csv"), sep = ",", dec = ",") %>% mutate(inv_year = 2012)
# this dataset contains the position and extend of the sampling circle satelites of the regeneration inventory of the HBI (BZE2)
HBI_RG_loc <- read.delim(file = here("data/input/BZE2_HBI/bej.csv"), sep = ",", dec = ",")%>% mutate(inv_year = 2012)
# this dataset contains the HBI forest edges info
HBI_forest_edges <- read.delim(file = here("data/input/BZE2_HBI/be_waldraender.csv"), sep = ";", dec = ",")
colnames(HBI_forest_edges) <- c("plot_ID", "e_ID", "e_type", "e_form",
"A_dist", "A_azi",  "B_dist", "B_azi",
"T_dist", "T_azi") # t = turning point
HBI_forest_edges
# # import coordinates of polygones along all edges iin triangle shape
all_edge_intersections_coords <- read.delim(file = here(paste0(out.path.BZE3, inv_name(HBI_RG$inv_year[1]), "_all_edges_intersection_coords.csv")), sep = ";", dec = ",")
all_rem_circles_coords <- read.delim(file = here(paste0(out.path.BZE3, inv_name(HBI_RG$inv_year[1]), "_all_rem_circles_coords.csv")), sep = ";", dec = ",")
all_edge_triangles_coords <- read.delim(file = here(paste0(out.path.BZE3, inv_name(HBI_RG$inv_year[1]), "_all_edges_triangle_coords.csv")), sep = ";", dec = ",")
all_areas_stands <- read.delim(file = here(paste0(out.path.BZE3, inv_name(HBI_RG$inv_year[1]), "_all_edges_rem_circles.csv")), sep = ";", dec = ",")
HBI_RG_loc
colnames(HBI_RG_loc)
colnames(HBI_RG)
# 1. calculations ---------------------------------------------------------
# 1.1. assign gon according to exposition --------------------------------
HBI_RG_loc <- HBI_RG_loc %>%
left_join(., HBI_forest_edges %>% select(plot_ID, e_ID, e_form), by = "plot_ID", multiple = "all") %>%
mutate(CCS_gon = case_when(CCS_position == "n" ~ 0,
CCS_position == "o" ~ 100,
CCS_position == "s" ~ 200,
CCS_position == "w" ~ 300,
CCS_position == "nw" ~ 350,
CCS_position == "no" ~ 50,
CCS_position == "sw" ~ 250,
CCS_position == "so" ~ 150,
TRUE ~ NA),
# if the max distance of the last plant in the RG CCS is not measured we assume it´s 5m or 500cm
CCS_max_dist_cm = ifelse(CCS_max_dist_cm == -9 | is.na(CCS_max_dist_cm), 500, CCS_max_dist_cm))
# 0.4 data prep: harmonise strings, assign columnnames etc. ---------------------------------------------------------------------
# assign column names
# bund_nr     pk_nr      pk_richtung     pk_dist     pk_aufnahme      pk_maxdist
colnames(HBI_RG_loc) <- c("plot_ID", "CCS_nr", "CCS_position",  "CCS_dist", "RG_inv_status", "CCS_max_dist_cm", "inv_year")
#  "bund_nr"  "pk_nr"  "lfd_nr"   "bart"  "hoehe"    "grklasse"
colnames(HBI_RG) <- c("plot_ID", "CCS_no", "t_ID", "SP_code", "H_cm", "D_class_cm", "inv_year")
# 1. calculations ---------------------------------------------------------
# 1.1. assign gon according to exposition --------------------------------
HBI_RG_loc <- HBI_RG_loc %>%
left_join(., HBI_forest_edges %>% select(plot_ID, e_ID, e_form), by = "plot_ID", multiple = "all") %>%
mutate(CCS_gon = case_when(CCS_position == "n" ~ 0,
CCS_position == "o" ~ 100,
CCS_position == "s" ~ 200,
CCS_position == "w" ~ 300,
CCS_position == "nw" ~ 350,
CCS_position == "no" ~ 50,
CCS_position == "sw" ~ 250,
CCS_position == "so" ~ 150,
TRUE ~ NA),
# if the max distance of the last plant in the RG CCS is not measured we assume it´s 5m or 500cm
CCS_max_dist_cm = ifelse(CCS_max_dist_cm == -9 | is.na(CCS_max_dist_cm), 500, CCS_max_dist_cm))
# subsetting the HBI_RG_loc dataset by filtering for plots that have only one intersecting edge
HBI_RG_one_edge <- HBI_RG_loc %>%
# filter only for trees that are located in plots with a forest edge
semi_join(forest_edges_HBI.man %>% filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%
select(plot_ID) %>% distinct(), by = "plot_ID") %>%
# filter for trees located in plots htat haev only one forest edge
anti_join(forest_edges_HBI.man %>%
#filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I")  %>%
select(plot_ID, e_ID) %>% group_by(plot_ID) %>% summarise(n = n()) %>% filter(n > 1) %>% select(plot_ID) %>% distinct(), by = "plot_ID") #%>%
all_areas_stands %>%
filter(CCS_r_m == 17.84 & e_ID %in% c("1", "2")) %>%  %>%
select(plot_ID, e_ID) %>%
distinct() %>%
group_by(plot_ID) %>%
summarise(n = n())
all_areas_stands %>%
filter(CCS_r_m == 17.84 & e_ID %in% c("1", "2")) %>%  %>%
select(plot_ID, e_ID) %>%
distinct() %>%
group_by(plot_ID) %>%
summarise(n = n())
all_areas_stands
all_areas_stands %>%
filter(CCS_r_m == 17.84 &
e_ID %in% c("1", "2")) %>%
select(plot_ID, e_ID) %>%
distinct() %>%
group_by(plot_ID) %>%
summarise(n = n())
all_areas_stands %>%
filter(CCS_r_m == 17.84 &
e_ID %in% c("1", "2")) %>%
select(plot_ID, e_ID) %>%
distinct() %>%
group_by(plot_ID) %>%
summarise(n = n()) %>%
filter(n > 1 )
forest_edges_HBI.man %>%
#filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I")  %>%
select(plot_ID, e_ID) %>% group_by(plot_ID) %>% summarise(n = n()) %>% filter(n > 1)
forest_edges_HBI.man %>%
#filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I")  %>%
select(plot_ID, e_ID) %>% group_by(plot_ID) %>% summarise(n = n()) %>% filter(n > 1) %>% select(plot_ID) %>% distinct()
all_areas_stands %>%
filter(CCS_r_m == 17.84 &
e_ID %in% c("1", "2")) %>%
select(plot_ID, e_ID) %>%
distinct() %>%
group_by(plot_ID) %>%
summarise(n = n()) %>%
filter(n > 1 ) %>%
select(plot_ID)

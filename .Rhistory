my.ccs.r <- ( RG_one_edge$CCS_max_dist_cm[ RG_one_edge$plot_ID == my.plot.id &
RG_one_edge$CCS_nr == my.ccs.id &
RG_one_edge$e_ID == my.e.id])/100   # max dist of last plant in the circle to create buffer
## select georefference data
## select UTM coordiantes of BZE (NSI point)
# my.center.easting <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "RW_MED"]
# my.center.northing <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "HW_MED"]
## assign crs
# my.utm.epsg <-  paste0("+proj=utm +zone=", pick_utm(my.center.easting)," ", "+datum=WGS84 +units=m +no_defs +type=crs")
# circle data
c.x0 = 0 # + my.center.easting
c.y0 = 0 # + my.center.northing
c.r3 = 17.84
# determine center corodiantes of the respective regeneration sampling circuit saterilte
ccs.dist <-  RG_one_edge$CCS_dist[ RG_one_edge$plot_ID == my.plot.id &  RG_one_edge$CCS_nr == my.ccs.id]/100
ccs.azi <-  RG_one_edge$CCS_gon[ RG_one_edge$plot_ID == my.plot.id &  RG_one_edge$CCS_nr == my.ccs.id]
x_CCS_center = ccs.dist*sin(ccs.azi * pi/200)  # + my.center.easting
y_CCS_center = ccs.dist*cos(ccs.azi* pi/200)   # + my.center.northing
## create polyones
# create polygone of regeneration sampling circle RG CCS
my.rg.ccs.poly <- sf::st_buffer(
sf::st_as_sf(as.data.frame(cbind("lon" = x_CCS_center,
"lat" = y_CCS_center)),
coords = c("lon", "lat")), # center point df
my.ccs.r)                               # radius
##  assing CRS to points
#sf::st_crs(my.rg.ccs.poly) <- my.utm.epsg
# create polygone of sampling circle
circle.17 <- sf::st_buffer(
sf::st_as_sf(as.data.frame(cbind("lon" = c.x0,
"lat" = c.y0)),
coords = c("lon", "lat")), # center point df
c.r3)                                   # radius of outer 17.84 circle
## assing CRS to circle
#sf::st_crs(circle.17) <- my.utm.epsg
circle.17$stand <- unique(all_rem_circles_coords$stand[all_rem_circles_coords$plot_ID == my.plot.id])
circle.17$plot_ID <- my.plot.id
circle.17$e_ID <- 0
circle.17$e_form <- 0
circle.17$CCS_r_m <- c.r3
# create polygone of edge triangle
edge.poly <- sfheaders::sf_polygon(obj = all_edge_triangles_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id)
, x = "lon"
, y = "lat"
, keep = TRUE)
# create polygon of remaining circle
circle.edge.inter <- sf::st_intersection(edge.poly, st_geometry(circle.17)) # we should set the circle to st_geometry here so we can assure that the inter polygone maintains its stand
# if there is no intersection between the edge and the cirlce,
if(isTRUE(nrow(circle.edge.inter) == 0) == TRUE){
# the whole circle polygon is set as the remaining circle
rem.circle.17 <- circle.17}else{
# else the remaining area/ polyon after the inersection is deducted is passed on as remaining circle
rem.circle.17 <- sf::st_difference(circle.17, st_geometry(circle.edge.inter))
}
## importing the remianing circle polygone directly fro the all_rem_circles_coords.df wouldn not work so well
# since we´d have to find a way to first export and then mport and convert multipolygones
# accurately, which is to much effort given that we can just wirk with the whole cirlce and the edge-intersections
# rem.circle.17 <- sfheaders::sf_polygon(obj = all_rem_circles_coords %>% filter(plot_ID == my.plot.id)
#                                 , x = "X"
#                                 , y = "Y"
#                                 , keep = TRUE)
## check for intersections
# with edge-intersection-polygon
intersection.with.edge <- sf::st_intersection(my.rg.ccs.poly, edge.poly)
# with remaining circle polygon
intersection.with.rem.circle <- sf::st_intersection(my.rg.ccs.poly, rem.circle.17)
## set the stand of the rg circle according to its intersections: https://www.geeksforgeeks.org/nested-if-else-statement-in-r/
my.stand.rg <- list(c(intersection.with.rem.circle$stand, intersection.with.edge$stand))
## determine area of the rg circle (stands) according to it´s intersection
my.rg.A.m2 <- list(c(st_area(intersection.with.rem.circle), st_area(intersection.with.edge)))
## safe intersection info (stand and area) of the RG CCS into dataframe
rg.edge.data <- as.data.frame(cbind(
"plot_ID" = c(rep(my.plot.id, times = length(unlist(my.stand.rg)))),
"CCS_nr" = c(rep(my.ccs.id, times = length(unlist(my.stand.rg)))),
"stand" =  c(unlist(my.stand.rg)),
"area_m2"= c(unlist(my.rg.A.m2))
))
## assign the whole CCS area to the stand that covers 2/3rds of the RG CCS area
# determine 2/3 of the RG CCS area
rg.ccs.A.0.6 <- sf::st_area(my.rg.ccs.poly)*(2/3)
# select the row that includes the stand that covers 2/3 of the RG CCS area,
# by filtering the area fot bigger/ equal 2/3 of the total RG CCS area
rg.0.6.data <- rg.edge.data[as.numeric(rg.edge.data$area_m2) >= rg.ccs.A.0.6, ]
# as we cannot localise the plants in the cirlce, we cannot adjust the refference area (Bezugsfläche) according to the are covered by the respective stand
# thus the whole are of the RG CCS is allocated to the stand that covers most of it´s area, as all plants included in the respective RG CCS are also allocated to this stand
# since we cannot sort them into stands by location as we don´t know their location
if(isTRUE(nrow(rg.0.6.data)== 0)){
# if there is no part of the RG CCS that has min 2/3 of its area covered by 1 stand,
# then only select the first row of the rg dataset, assin the stand to NA and the area to the whole RG CCS area
rg.edge.data <- rg.edge.data[1,]
rg.edge.data[1,]$stand <- NA
rg.edge.data[1,]$area_m2  <- sf::st_area(my.rg.ccs.poly)
}else{
# if there is a part of the RG CCS that haas min 2/3 of its area covered by 1 stand,
# then select this part and arssing the area to the whole RG CCS area
rg.edge.data <- rg.0.6.data
rg.edge.data$area_m2  <- sf::st_area(my.rg.ccs.poly)
}
## put dataframe in export list
RG.CCS.one.edge.list[[i]] <- rg.edge.data
print(ggplot() +
geom_sf(data = ( sf::st_as_sf(as.data.frame(cbind("lon" = c.x0,
"lat" = c.y0)),
coords = c("lon", "lat"))), aes(),fill = NA)+
geom_sf(data = ( sf::st_as_sf(as.data.frame(cbind("lon" = x_CCS_center,
"lat" = y_CCS_center)),
coords = c("lon", "lat"))), aes(),fill = NA)+
geom_sf(data = rem.circle.17, aes(colour = stand),fill = NA)+
geom_sf(data = edge.poly, aes(colour = stand), fill = NA)+
geom_sf(data = my.rg.ccs.poly, aes(colour = rg.edge.data$stand), fill = NA)+
ggtitle(my.plot.id, my.ccs.id)+
xlim(-60,60)+
ylim(-60,60)
)
}
# bind areas and stands in one dataframe with plot_ID, CCS_nr to join stand & area info into  RG dataset later
RG_one_edge_stands_areas <- as.data.frame(rbindlist(RG.CCS.one.edge.list))
# 2.2. plots with 2 edges: sorting sampling circles into stands ---------------------------------
# subsetting data
RG_two_edges <- RG_loc %>%
#filter for plots that we actually have coordiantes and areas for all edges
semi_join(., all_areas_stands %>%
filter(CCS_r_m == 17.84 &
e_ID == 2 &
inter_stat == "partly intersecting" |
CCS_r_m == 17.84 &
e_ID == 1) %>%
select(plot_ID) %>%
distinct(),
by = c("plot_ID")) %>%
# silter for plots that have only one forest edge
semi_join(., all_areas_stands %>%
filter(CCS_r_m == 17.84 &
e_ID %in% c("1", "2")) %>%
select(plot_ID, e_ID) %>%
group_by(plot_ID) %>%
summarise(n = n()) %>%
filter(n > 1 ) %>%
select(plot_ID) %>%
distinct(),
by = "plot_ID")# %>%
# for each plot_id and regeneration circle at plots with one edge only
RG.CCS.two.edges.list <- vector("list", length = nrow(unique(RG_two_edges[c("plot_ID", "CCS_nr")])))
for (i in 1:nrow(unique( RG_two_edges[c("plot_ID", "CCS_nr")]))) {
# i = 13
# i = which(grepl(50132, unique( RG_two_edges[c("plot_ID", "CCS_nr")][, "plot_ID"])))
# assign crs
# my.utm.epsg <- "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs +type=crs"
# regerneation sampling cirlce data
my.plot.id <- unique( RG_two_edges[c("plot_ID", "CCS_nr")])[, "plot_ID"][i]  # plot id of respecctive regereation satelite
my.ccs.id <- unique( RG_two_edges[c("plot_ID", "CCS_nr")])[, "CCS_nr"][i]    # circle id7 number of respecctive regereation satelite
# select edge ID
my.e.id.1 <-  RG_two_edges$e_ID[ RG_two_edges$plot_ID == my.plot.id &  RG_two_edges$CCS_nr == my.ccs.id &   RG_two_edges$e_ID == 1] # edge id of the respective edge, because if we filter for the plot ID it might also pull edges that are double edges but one of them does not intersect
my.e.id.2 <-  RG_two_edges$e_ID[ RG_two_edges$plot_ID == my.plot.id &  RG_two_edges$CCS_nr == my.ccs.id &   RG_two_edges$e_ID == 2] # edge id of the respective edge, because if we filter for the plot ID it might also pull edges that are double edges but one of them does not intersect
## select georefference data
## select UTM coordiantes of BZE (NSI point)
# my.center.easting <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "RW_MED"]
# my.center.northing <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "HW_MED"]
## assign crs
# my.utm.epsg <-  paste0("+proj=utm +zone=", pick_utm(my.center.easting)," ", "+datum=WGS84 +units=m +no_defs +type=crs")
# circle data
c.x0 = 0 # + my.center.easting
c.y0 = 0 # + my.center.northing
c.r3 = 17.84
# spatial data of RG sampling circle
# select regeneration sampling circuit radius
my.ccs.r <- ( RG_two_edges$CCS_max_dist_cm[ RG_two_edges$plot_ID == my.plot.id &
RG_two_edges$CCS_nr == my.ccs.id &
RG_two_edges$e_ID == my.e.id])/100   # max dist of last plant in the circle to create buffer
# determine center corodiantes of the respective regeneration sampling circuit saterilte
ccs.dist <-unique(  RG_two_edges$CCS_dist[ RG_two_edges$plot_ID == my.plot.id &  RG_two_edges$CCS_nr == my.ccs.id]/100)
ccs.azi <- unique( RG_two_edges$CCS_gon[ RG_two_edges$plot_ID == my.plot.id &  RG_two_edges$CCS_nr == my.ccs.id])
x_CCS_center = ccs.dist*sin(ccs.azi* pi/200)  # + my.center.easting
y_CCS_center = ccs.dist*cos(ccs.azi* pi/200)  # + my.center.northing
## create polyones
# create polygone of regeneration sampling circle RG CCS
my.rg.ccs.poly <- sf::st_buffer(
sf::st_as_sf(as.data.frame(cbind("lon" = x_CCS_center,
"lat" = y_CCS_center)),
coords = c("lon", "lat")), # center point df
my.ccs.r)                               # radius
## assign CRS to RG circle
#sf::st_crs(my.rg.ccs.poly) <- my.utm.epsg
# create polygone of sampling circle
circle.17 <- sf::st_buffer(
sf::st_as_sf(as.data.frame(cbind("lon" = c.x0,
"lat" = c.y0)),
coords = c("lon", "lat")), # center point df
c.r3)                                   # radius of outer 17.84 circle
## assign CRS to BZE circle
#sf::st_crs(circle.17) <- my.utm.epsg
circle.17$stand <- unique(all_rem_circles_coords$stand[all_rem_circles_coords$plot_ID == my.plot.id])
circle.17$plot_ID <- my.plot.id
circle.17$e_ID <- 0
circle.17$e_form <- 0
circle.17$CCS_r_m <- c.r3
# create polygone of edge 1 triangle
edge.poly.1 <- sfheaders::sf_polygon(obj = all_edge_intersections_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.1)
, x = "X"
, y = "Y"
, keep = TRUE)
# create polygone of edge 2 triangle
edge.poly.2 <- sfheaders::sf_polygon(obj = all_edge_intersections_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.2)
, x = "X"
, y = "Y"
, keep = TRUE)
## create polygon of remaining circle after circle-edge.1 intersection
circle.edge.1.inter <- sf::st_intersection(edge.poly.1, st_geometry(circle.17))
# if there is no intersection between the edge and the cirlce,
if(isTRUE(nrow(circle.edge.1.inter) == 0)){
# the whole circle polygon is set as the remaining circle
rem.circle.17.1 <- circle.17}else{
# else the remaining area/ polyon after the inersection is deducted is passed on as remaining circle
rem.circle.17.1 <- sf::st_difference(circle.17, st_geometry(circle.edge.1.inter))
}
## create polygon of remaining circle after circle-edge.2 intersection
circle.edge.2.inter <- sf::st_intersection(edge.poly.2, st_geometry(rem.circle.17.1))
# if there is no intersection between the edge and the cirlce,
if(isTRUE(nrow(circle.edge.2.inter) == 0)){
# the previous remaining circle polygon is set as the remaining circle
rem.circle.17.2 <- rem.circle.17.1}else{
# else the remaining area/ polyon after the inersection is deducted is passed on as remaining circle
rem.circle.17.2 <- sf::st_difference(rem.circle.17.1, st_geometry(circle.edge.2.inter))
}
## check for intersections
# with edge-intersection-polygon
intersection.with.edge.1 <- sf::st_intersection(my.rg.ccs.poly, edge.poly.1)
intersection.with.edge.2 <- sf::st_intersection(my.rg.ccs.poly, edge.poly.2)
# with remaining circle polygon
intersection.with.rem.circle <- sf::st_intersection(my.rg.ccs.poly, rem.circle.17.2)
## set the stand of the rg circle according to its intersections: https://www.geeksforgeeks.org/nested-if-else-statement-in-r/
my.stand.rg <- list(c(intersection.with.rem.circle$stand, intersection.with.edge.1$stand, intersection.with.edge.2$stand))
## determine area of the rg circle (stands) according to it´s intersection
my.rg.A.m2 <-  list(c(st_area(intersection.with.rem.circle), st_area(intersection.with.edge.1), st_area(intersection.with.edge.2)))
## safe intersection info (stand and area) of the RG CCS into dataframe
rg.edge.data <- as.data.frame(cbind(
"plot_ID" = c(rep(my.plot.id, times = length(unlist(my.stand.rg)))),
"CCS_nr" = c(rep(my.ccs.id, times = length(unlist(my.stand.rg)))),
"stand" =  c(unlist(my.stand.rg)),
"area_m2"= c(unlist((my.rg.A.m2)))
))
## assign the whole CCS area to the stand that covers 2/3rds of the RG CCS area
# determine 2/3 of the RG CCS area
rg.ccs.A.0.6 <- sf::st_area(my.rg.ccs.poly)*(2/3)
# select the row that includes the stand that covers 2/3 of the RG CCS area,
# by filtering the area fot bigger/ equal 2/3 of the total RG CCS area
rg.0.6.data <- (rg.edge.data[as.numeric(rg.edge.data$area_m2) >= rg.ccs.A.0.6, ] %>% arrange(., desc(area_m2))) %>% slice(1)
# as we cannot localise the plants in the cirlce, we cannot adjust the refference area (Bezugsfläche) according to the are covered by the respective stand
# thus the whole are of the RG CCS is allocated to the stand that covers most of it´s area, as all plants included in the respective RG CCS are also allocated to this stand
# since we cannot sort them into stands by location as we don´t know their location
if(isTRUE(nrow(rg.0.6.data)== 0)){
rg.edge.data <- rg.edge.data[1,]
rg.edge.data[1,]$stand <- NA
rg.edge.data[1,]$area_m2  <- sf::st_area(my.rg.ccs.poly)
}else{
rg.edge.data <- rg.0.6.data
rg.edge.data$area_m2  <- sf::st_area(my.rg.ccs.poly)
}
## put dataframe in export list
RG.CCS.two.edges.list[[i]] <- rg.edge.data
#print(my.plot.id)
print(ggplot() +
geom_sf(data = ( sf::st_as_sf(as.data.frame(cbind("lon" = c.x0,
"lat" = c.y0)),
coords = c("lon", "lat"))), aes(),fill = NA)+
geom_sf(data = ( sf::st_as_sf(as.data.frame(cbind("lon" = x_CCS_center,
"lat" = y_CCS_center)),
coords = c("lon", "lat"))), aes(),fill = NA)+
geom_sf(data = rem.circle.17.2, aes(colour = stand),fill = NA)+
geom_sf(data = edge.poly.1, aes(colour = stand), fill = NA)+
geom_sf(data = edge.poly.2, aes(colour = stand), fill = NA)+
geom_sf(data = my.rg.ccs.poly,aes(colour = rg.edge.data$stand), fill = NA)+
ggtitle(my.plot.id, my.ccs.id)
)
}
RG_loc
RG_two_edges
i = 17
# regerneation sampling cirlce data
my.plot.id <- unique( RG_two_edges[c("plot_ID", "CCS_nr")])[, "plot_ID"][i]  # plot id of respecctive regereation satelite
my.ccs.id <- unique( RG_two_edges[c("plot_ID", "CCS_nr")])[, "CCS_nr"][i]    # circle id7 number of respecctive regereation satelite
# select edge ID
my.e.id.1 <-  RG_two_edges$e_ID[ RG_two_edges$plot_ID == my.plot.id &  RG_two_edges$CCS_nr == my.ccs.id &   RG_two_edges$e_ID == 1] # edge id of the respective edge, because if we filter for the plot ID it might also pull edges that are double edges but one of them does not intersect
my.e.id.2 <-  RG_two_edges$e_ID[ RG_two_edges$plot_ID == my.plot.id &  RG_two_edges$CCS_nr == my.ccs.id &   RG_two_edges$e_ID == 2] # edge id of the respective edge, because if we filter for the plot ID it might also pull edges that are double edges but one of them does not intersect
# circle data
c.x0 = 0 # + my.center.easting
c.y0 = 0 # + my.center.northing
c.r3 = 17.84
# spatial data of RG sampling circle
# select regeneration sampling circuit radius
my.ccs.r <- ( RG_two_edges$CCS_max_dist_cm[ RG_two_edges$plot_ID == my.plot.id &
RG_two_edges$CCS_nr == my.ccs.id &
RG_two_edges$e_ID == my.e.id])/100   # max dist of last plant in the circle to create buffer
# determine center corodiantes of the respective regeneration sampling circuit saterilte
ccs.dist <-unique(  RG_two_edges$CCS_dist[ RG_two_edges$plot_ID == my.plot.id &  RG_two_edges$CCS_nr == my.ccs.id]/100)
ccs.azi <- unique( RG_two_edges$CCS_gon[ RG_two_edges$plot_ID == my.plot.id &  RG_two_edges$CCS_nr == my.ccs.id])
x_CCS_center = ccs.dist*sin(ccs.azi* pi/200)  # + my.center.easting
y_CCS_center = ccs.dist*cos(ccs.azi* pi/200)  # + my.center.northing
## create polyones
# create polygone of regeneration sampling circle RG CCS
my.rg.ccs.poly <- sf::st_buffer(
sf::st_as_sf(as.data.frame(cbind("lon" = x_CCS_center,
"lat" = y_CCS_center)),
coords = c("lon", "lat")), # center point df
my.ccs.r)                               # radius
# create polygone of sampling circle
circle.17 <- sf::st_buffer(
sf::st_as_sf(as.data.frame(cbind("lon" = c.x0,
"lat" = c.y0)),
coords = c("lon", "lat")), # center point df
c.r3)                                   # radius of outer 17.84 circle
## assign CRS to BZE circle
#sf::st_crs(circle.17) <- my.utm.epsg
circle.17$stand <- unique(all_rem_circles_coords$stand[all_rem_circles_coords$plot_ID == my.plot.id])
circle.17$plot_ID <- my.plot.id
circle.17$e_ID <- 0
circle.17$e_form <- 0
circle.17$CCS_r_m <- c.r3
# create polygone of edge 1 triangle
edge.poly.1 <- sfheaders::sf_polygon(obj = all_edge_intersections_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.1)
, x = "X"
, y = "Y"
, keep = TRUE)
# create polygone of edge 2 triangle
edge.poly.2 <- sfheaders::sf_polygon(obj = all_edge_intersections_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.2)
, x = "X"
, y = "Y"
, keep = TRUE)
plot(circle.17$geometry, col = "grey")
plot(edge.poly.1$geometry, col = "blue", add =T)
i = 17
# regerneation sampling cirlce data
my.plot.id <- unique( RG_two_edges[c("plot_ID", "CCS_nr")])[, "plot_ID"][i]  # plot id of respecctive regereation satelite
my.plot.id
i = 13
# regerneation sampling cirlce data
my.plot.id <- unique( RG_two_edges[c("plot_ID", "CCS_nr")])[, "plot_ID"][i]  # plot id of respecctive regereation satelite
my.plot.id
my.plot.id <- unique( RG_two_edges[c("plot_ID", "CCS_nr")])[, "plot_ID"][i]  # plot id of respecctive regereation satelite
my.ccs.id <- unique( RG_two_edges[c("plot_ID", "CCS_nr")])[, "CCS_nr"][i]    # circle id7 number of respecctive regereation satelite
# select edge ID
my.e.id.1 <-  RG_two_edges$e_ID[ RG_two_edges$plot_ID == my.plot.id &  RG_two_edges$CCS_nr == my.ccs.id &   RG_two_edges$e_ID == 1] # edge id of the respective edge, because if we filter for the plot ID it might also pull edges that are double edges but one of them does not intersect
my.e.id.2 <-  RG_two_edges$e_ID[ RG_two_edges$plot_ID == my.plot.id &  RG_two_edges$CCS_nr == my.ccs.id &   RG_two_edges$e_ID == 2] # edge id of the respective edge, because if we filter for the plot ID it might also pull edges that are double edges but one of them does not intersect
## select georefference data
## select UTM coordiantes of BZE (NSI point)
# my.center.easting <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "RW_MED"]
# my.center.northing <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "HW_MED"]
## assign crs
# my.utm.epsg <-  paste0("+proj=utm +zone=", pick_utm(my.center.easting)," ", "+datum=WGS84 +units=m +no_defs +type=crs")
# circle data
c.x0 = 0 # + my.center.easting
c.y0 = 0 # + my.center.northing
c.r3 = 17.84
# spatial data of RG sampling circle
# select regeneration sampling circuit radius
my.ccs.r <- ( RG_two_edges$CCS_max_dist_cm[ RG_two_edges$plot_ID == my.plot.id &
RG_two_edges$CCS_nr == my.ccs.id &
RG_two_edges$e_ID == my.e.id])/100   # max dist of last plant in the circle to create buffer
# determine center corodiantes of the respective regeneration sampling circuit saterilte
ccs.dist <-unique(  RG_two_edges$CCS_dist[ RG_two_edges$plot_ID == my.plot.id &  RG_two_edges$CCS_nr == my.ccs.id]/100)
ccs.azi <- unique( RG_two_edges$CCS_gon[ RG_two_edges$plot_ID == my.plot.id &  RG_two_edges$CCS_nr == my.ccs.id])
x_CCS_center = ccs.dist*sin(ccs.azi* pi/200)  # + my.center.easting
y_CCS_center = ccs.dist*cos(ccs.azi* pi/200)  # + my.center.northing
## create polyones
# create polygone of regeneration sampling circle RG CCS
my.rg.ccs.poly <- sf::st_buffer(
sf::st_as_sf(as.data.frame(cbind("lon" = x_CCS_center,
"lat" = y_CCS_center)),
coords = c("lon", "lat")), # center point df
my.ccs.r)                               # radius
## assign CRS to RG circle
#sf::st_crs(my.rg.ccs.poly) <- my.utm.epsg
# create polygone of sampling circle
circle.17 <- sf::st_buffer(
sf::st_as_sf(as.data.frame(cbind("lon" = c.x0,
"lat" = c.y0)),
coords = c("lon", "lat")), # center point df
c.r3)                                   # radius of outer 17.84 circle
## assign CRS to BZE circle
#sf::st_crs(circle.17) <- my.utm.epsg
circle.17$stand <- unique(all_rem_circles_coords$stand[all_rem_circles_coords$plot_ID == my.plot.id])
circle.17$plot_ID <- my.plot.id
circle.17$e_ID <- 0
circle.17$e_form <- 0
circle.17$CCS_r_m <- c.r3
# create polygone of edge 1 triangle
edge.poly.1 <- sfheaders::sf_polygon(obj = all_edge_intersections_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.1)
, x = "X"
, y = "Y"
, keep = TRUE)
# create polygone of edge 2 triangle
edge.poly.2 <- sfheaders::sf_polygon(obj = all_edge_intersections_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.2)
, x = "X"
, y = "Y"
, keep = TRUE)
## create polygon of remaining circle after circle-edge.1 intersection
circle.edge.1.inter <- sf::st_intersection(edge.poly.1, st_geometry(circle.17))
# if there is no intersection between the edge and the cirlce,
if(isTRUE(nrow(circle.edge.1.inter) == 0)){
# the whole circle polygon is set as the remaining circle
rem.circle.17.1 <- circle.17}else{
# else the remaining area/ polyon after the inersection is deducted is passed on as remaining circle
rem.circle.17.1 <- sf::st_difference(circle.17, st_geometry(circle.edge.1.inter))
}
plot(circle.17$geometry, col = "grey")
plot(edge.poly.1$geometry, col = "blue", add =T)
plot(edge.poly.1$geometry, col = "blue", add =T)
plot(edge.poly.1$geometry, col = "blue", add =T)
plot(edge.poly.2$geometry, col = "blue", add =T)
plot(edge.poly.1$geometry, col = "blue")
plot(circle.17$geometry, col = "grey", add =T)
plot(edge.poly.1$geometry, col = "blue", add =T)
plot(circle.17$geometry, col = "grey", add =T)
plot(edge.poly.2$geometry, col = "blue", add =T)
plot(edge.poly.1$geometry, col = "blue", add =T)
plot(circle.17$geometry, col = "grey", add =T)
plot(edge.poly.1$geometry, col = "blue", add =T)
plot(circle.17$geometry, col = "grey", add =T)
plot(edge.poly.2$geometry, col = "blue", add =T)
# create polygone of edge 1 triangle
edge.poly.1 <- sfheaders::sf_polygon(obj = all_edge_triangles_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.1)
, x = "X"
, y = "Y"
, keep = TRUE)
# create polygone of edge 2 triangle
edge.poly.2 <- sfheaders::sf_polygon(obj = all_edge_triangles_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.2)
, x = "X"
, y = "Y"
, keep = TRUE)
# create polygone of edge 1 triangle
edge.poly.1 <- sfheaders::sf_polygon(obj = all_edge_triangles_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.1)
, x = "lon"
, y = "lat"
, keep = TRUE)
# create polygone of edge 2 triangle
edge.poly.2 <- sfheaders::sf_polygon(obj = all_edge_triangles_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.2)
, x = "lon"
, y = "lat"
, keep = TRUE)
plot(edge.poly.1$geometry, col = "blue", add =T)
plot(circle.17$geometry, col = "grey", add =T)
plot(edge.poly.1$geometry, col = "blue")
plot(circle.17$geometry, col = "grey", add =T)
plot(circle.17$geometry, col = "grey")
plot(edge.poly.1$geometry, col = "blue",  add =T)
plot(edge.poly.2$geometry, col = "red", add =T)
# create polygone of edge 1 triangle
edge.poly.1 <- sfheaders::sf_polygon(obj = all_edge_intersections_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.1)
, x = "lon"
, y = "lat"
, keep = TRUE)
# create polygone of edge 2 triangle
edge.poly.2 <- sfheaders::sf_polygon(obj = all_edge_intersections_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.2)
, x = "lon"
, y = "lat"
, keep = TRUE)
## create polygon of remaining circle after circle-edge.1 intersection
circle.edge.1.inter <- sf::st_intersection(edge.poly.1, st_geometry(circle.17))
# if there is no intersection between the edge and the cirlce,
if(isTRUE(nrow(circle.edge.1.inter) == 0)){
# the whole circle polygon is set as the remaining circle
rem.circle.17.1 <- circle.17}else{
# else the remaining area/ polyon after the inersection is deducted is passed on as remaining circle
rem.circle.17.1 <- sf::st_difference(circle.17, st_geometry(circle.edge.1.inter))
}
plot(circle.17$geometry, col = "grey")
plot(edge.poly.1$geometry, col = "blue",  add =T)
plot(edge.poly.2$geometry, col = "red", add =T)
# create polygone of edge 1 triangle
edge.poly.1 <- sfheaders::sf_polygon(obj = all_edge_intersections_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.1)
, x = "lon"
, y = "lat"
, keep = TRUE)
# create polygone of edge 2 triangle
edge.poly.2 <- sfheaders::sf_polygon(obj = all_edge_intersections_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.2)
, x = "lon"
, y = "lat"
, keep = TRUE)
## create polygon of remaining circle after circle-edge.1 intersection
circle.edge.1.inter <- sf::st_intersection(edge.poly.1, st_geometry(circle.17))
# if there is no intersection between the edge and the cirlce,
if(isTRUE(nrow(circle.edge.1.inter) == 0)){
# the whole circle polygon is set as the remaining circle
rem.circle.17.1 <- circle.17}else{
# else the remaining area/ polyon after the inersection is deducted is passed on as remaining circle
rem.circle.17.1 <- sf::st_difference(circle.17, st_geometry(circle.edge.1.inter))
}
plot(circle.17$geometry, col = "grey")
plot(edge.poly.1$geometry, col = "blue",  add =T)
all_edge_intersections_coords
# create polygone of edge 1 triangle
edge.poly.1 <- sfheaders::sf_polygon(obj = all_edge_intersections_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.1)
, x = "X"
, y = "Y"
, keep = TRUE)
# create polygone of edge 2 triangle
edge.poly.2 <- sfheaders::sf_polygon(obj = all_edge_intersections_coords %>% filter(plot_ID == my.plot.id & e_ID == my.e.id.2)
, x = "X"
, y = "Y"
, keep = TRUE)
## create polygon of remaining circle after circle-edge.1 intersection
circle.edge.1.inter <- sf::st_intersection(edge.poly.1, st_geometry(circle.17))
# if there is no intersection between the edge and the cirlce,
if(isTRUE(nrow(circle.edge.1.inter) == 0)){
# the whole circle polygon is set as the remaining circle
rem.circle.17.1 <- circle.17}else{
# else the remaining area/ polyon after the inersection is deducted is passed on as remaining circle
rem.circle.17.1 <- sf::st_difference(circle.17, st_geometry(circle.edge.1.inter))
}
plot(circle.17$geometry, col = "grey")
plot(edge.poly.1$geometry, col = "blue",  add =T)
plot(edge.poly.2$geometry, col = "red", add =T)

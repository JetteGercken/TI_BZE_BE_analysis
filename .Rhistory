N_mean_gkg <- as.numeric(c(1.335, 7.227, 1.335, 7.227, 4.601,           # BU
1.752, 6.507, 1.752, 6.507, 6.209,           # EI
1.438, 5.348, 1.438, 5.348, 3.721,           # ES
1.465, 7.729, 1.465, 7.729, 4.278,           # AH
1.828, 6.131, 1.828, 6.131, 6.057,           # BI
2.475, 11.028, 2.475, 11.028, 7.214,         # ERL
0.812, 4.84, 0.812, 4.84, 4.343, 12.978,     # FI
0.794, 4.339, 0.794, 4.339, 4.058, 15.201,   # KI
0.701, 3.910, 0.701, 3.910, 4.203, 15.166)), # DGL
data_source <- c("Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018",
"Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018",
"Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018",
"Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018",
"Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018",
"Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018",
"Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018",
"Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018",
"Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018", "Rumpf et al. 2018")))
colnames(N_con_w) <- c("SP_BWI", "compartiment", "N_mean_gkg", "reference")
N_con_w <- N_con_w %>%
# transforming concentration of N in g/kg = g/1000g into percent or decimal numberby dividing by 1000
mutate(N_con = as.numeric(N_mean_gkg)/1000) %>%
unite(SP_com, SP_BWI:compartiment, remove = FALSE)
# modifying N content foliage dataset
N_con_f <- N_con_f %>%
mutate(N_mean_gkg = as.numeric(N_mean_gkg),                             # transfor N content in numeric values --> creates NAs where N content == NULL in original dataset
N_con = (as.numeric(N_mean_gkg)/1000),                                   # calculate N content xg per 1kg = x g per 1000g --> divided by 1000 --> content of nitrogen per weight unit
compartiment = "f") %>%                                                  # assign compartiment "f"
left_join(., SP_names_com_ID_tapeS %>% select(name, N_f_SP_group_MoMoK, LH_NH), # join in NH_LH category to build groups
by = "name") %>%
select(plot_ID, site, name, LH_NH, N_f_SP_group_MoMoK, compartiment, N_mean_gkg, N_con) %>%
unite(SP_com, N_f_SP_group_MoMoK:compartiment, remove = FALSE) %>%
group_by(name, N_f_SP_group_MoMoK, compartiment, SP_com, LH_NH) %>%                    # group by species group and compartiment
filter(!is.na(N_mean_gkg)) %>%
summarize(N_mean_gkg = mean(as.numeric(N_mean_gkg)),
N_con = mean((N_con)))
# mean N content of all coniferous and broadleafed trees
N_con_f <- rbind(N_con_f,
N_con_f %>%
group_by(LH_NH) %>%                                    # group by broadleafed vs. coniferous
summarise(N_mean_gkg = mean(N_mean_gkg),
N_con = mean(N_con)) %>%
mutate(name = ifelse(LH_NH == "NB", "NB", "LB"),
N_f_SP_group_MoMoK = ifelse(LH_NH == "NB", "aNB", "aLB"),
compartiment = "f") %>%
unite(SP_com, N_f_SP_group_MoMoK:compartiment, remove = FALSE) %>%
select(name, N_f_SP_group_MoMoK, compartiment, SP_com, LH_NH, N_mean_gkg, N_con)) # establish correct order for rbind
write.csv(N_con_f, paste0(momok.out.home, "N_con_foliage_MOMOK.csv"))
write.csv(N_con_w, paste0(momok.out.home, "N_con_wood_Rumpf.csv"))
# ----- 1.4.5. MoMoK site info dataset data wrangling ----------------------------------------
# assign expected growth bahaviour according to species and hydrological status
# if its a peatland adapted species like Betula pubescens or Alnus glutionosa
# -> we expect normal growth ("n" = 1) even on regenerated sites (naturnah)
# if its a not peatland adapted species like Picea abies, Abies alba, Pinus mungo
# -> we expect hampered ("h" = 0) growth on regenerated sites and normal growth on not regenated sites
# thus we have to assign a column with expected growth behavior depending on the species and hydrological status
# whereby every hydr_status that does not start with "naturnah" is categorized as not regenerated
site_info <- site_info %>%
select(plot_ID, peat_type, hydro_status, SP_name) %>%
# creating a column with the dominant species per plot
# a) therefore i need the BA of ever species per plot
# b) and set it in relation to the total BA per plot
# c) and the select the species per plot which contributes most to the total BA
left_join(., left_join(
dom_SP_plot <- left_join(
# a) data set with BA per species
trees_total %>%
group_by(plot_ID, SP_code) %>%       # group by plot and species to calculate BA per species
summarise(SP_BA_plot = sum(BA_m2),             # calculate BA per species per canopy layer per plot in m2
plot_A_ha = mean(plot_A_ha)) %>%     # plot area in hectare to calculate BA per ha
mutate(SP_BA_m2ha = SP_BA_plot/plot_A_ha), # calculate BA per species per plot in m2/ ha
# b) dataset with total BA per plot
trees_total %>%
group_by(plot_ID) %>%                         # group by plot to calculate total BA per plot
summarise(tot_BA_plot = sum(BA_m2),           # calculate total BA per plot in m2 by summarizing the BA of individual trees after grouping the dataset by plot
plot_A_ha = mean(plot_A_ha)) %>%    # plot area in hectare to calculate BA per ha
mutate(tot_BA_m2ha = tot_BA_plot/plot_A_ha), # calculate total BA per plot in m2 per hectare by dividing total BA m2/plot by area plot/ha
by=c("plot_ID", "plot_A_ha")) %>%
select(- c(plot_A_ha, tot_BA_plot)) %>%  # remove unnecessary variables
mutate(BA_SP_per = (SP_BA_m2ha/tot_BA_m2ha)*100),   # calculate proportion of each species to total BA in percent,
# c) code selecting dominant species from the previous created dataset with the contribution of every species to the total basal area
as.data.table(dom_SP_plot)[as.data.table(dom_SP_plot)[, .I[BA_SP_per == max(BA_SP_per)], by= plot_ID]$V1] %>%
rename(., dom_SP = SP_code) %>%
select(plot_ID, dom_SP),
by = "plot_ID") %>%
select(plot_ID, dom_SP) %>%
distinct(),
by = "plot_ID") %>%
# translating the species names into BWI codes in capital letters to make joins more easy
mutate(SP_ger_char_code = case_when(SP_name == "Erle" |
SP_name == "Roterle"|
startsWith(SP_name, "Erl") |
startsWith(SP_name, "diverse, Erle") |
startsWith(SP_name, "diverse, Laubbäume") ~ "SER",
SP_name == "Fichte" |
startsWith(SP_name, "Fichte") |
startsWith(SP_name, "diverse, Fichte") |
startsWith(SP_name, "diverse, Nadelbäume") ~ "FI",
SP_name == "Kiefer" |
startsWith(SP_name, "Kiefer") |
startsWith(SP_name, "diverse, Kiefer") ~ "KI",
SP_name == "Birke" |
startsWith(SP_name, "diverse, Birke") ~ "MBI",
SP_name == " " | SP_name == "" | SP_name == "k.A."~ NA,
TRUE ~ NA)) %>%
mutate(dom_SP = ifelse(is.na(dom_SP), SP_ger_char_code, dom_SP)) %>%
left_join(., SP_names_com_ID_tapeS %>%
select(Chr_code_ger, LH_NH) %>%
mutate(Chr_code_ger = toupper(Chr_code_ger)),
by = c("dom_SP" = "Chr_code_ger")) %>%
# normal growth for broad leafed trees no matter the site
mutate(growth = case_when(LH_NH == "LB" &
hydro_status != "k.A" ~ 1,
# normal growth for conifers trees on not regenerated  sites
LH_NH == "NB" &
!(startsWith(hydro_status, "naturnah")) &
hydro_status != "k.A" ~ 1,
# hampered growth for conifers on regenerated sites
LH_NH == "NB" &
startsWith(hydro_status, "naturnah") &
hydro_status != "k.A" ~ 0,
TRUE ~ NA))
# these are the species names and the SP_code i selected for them
# if theres´s mixed species stand i assing the first mentioned species as the domiannt species
site_info %>% select(SP_name) %>% distinct()
# SP_name                                         SP_code
# 1                                        Erle   SER
# 2                          Erle (Esche, Ulme)   SER
# 3                                      Fichte   FI
# 4                                       Erl +   SER
#   5                                     Roterle SER
# 6  diverse, Fichte, Erle, Moorbirke, waldfrei   FI
# 7                     diverse, Kiefer, Fichte   KI
# 8          diverse, Fichte, Kiefer, Moorbirke   FI
# 9                                      Kiefer   KI
# 10                                    Fichte    FI
# 11                                      Birke   MBI
# 12                      diverse, Erle / Birke   SER
# 13                                              NA
# 14                     diverse, Kiefer, Birke   KI
# 15                         diverse, Laubbäume   SER
# 16                                       k.A.   NA
# 17           Fichte, größtenteils abgestorben   FI
# 18                     diverse, Erle, Birke,…   SER
# ----- 2. CALCULATIONS --------------------------------------------------------
# ----- 2.1. LIVING TREES -----------------------------------------------------------------
# ----- 2.1.1. heights: regression models for missing tree heights ---------------------------------
# find the plots and species that won´t have a height regression model because
# there are less then 3 measurements per plot
# ---> think about way to deal with them !!!!
trees_total %>%
select(plot_ID, SP_code, H_dm, DBH_mm, Kraft) %>%
filter(!is.na(H_dm) & !is.na(DBH_mm)) %>%
group_by(plot_ID, SP_code) %>%
filter(n() < 3)%>%    # filter for plots where there are less then 3 heights measured for each species
#group_by(plot_ID, SP_code) %>%
#lm_table(H_m ~ DBH_cm) %>%
arrange(plot_ID, SP_code)
# ----- 2.1.1.1. coefficents dataframe per SP and plot when >= 3 heights measured --------
# to calculate individual tree heights for trees of the samme species and plot
# where the height has not been sampled we create a non-linear regression for the heights
# in the following a dataframe with regression coefficients per
# species per plot is created if there are more then 3 heights measured per species and plot
# coefficents of non-linear height model per species and plot
# https://rdrr.io/cran/forestmangr/f/vignettes/eq_group_fit_en.Rmd
coeff_H_SP_P <- left_join(trees_total %>%
select(plot_ID, SP_code, H_m, DBH_cm, DBH_class) %>%
filter(!is.na(H_m) & !is.na(DBH_cm) & !is.na(DBH_class)) %>%
group_by(plot_ID, SP_code) %>%
filter(n() >= 3),
# coeff_H_SP_P dataset
trees_total %>%
select(plot_ID, SP_code, H_m, DBH_cm, DBH_class) %>%
filter(!is.na(H_m) & !is.na(DBH_cm) & !is.na(DBH_class) ) %>%
#filter(DBH_cm <= 150) %>%
group_by(plot_ID, SP_code) %>%
# filter for plots where there is at least 3 heights measured for each species
#https://stackoverflow.com/questions/20204257/subset-data-frame-based-on-number-of-rows-per-group
filter(n() >= 3)%>%
group_by(plot_ID, SP_code) %>%
nls_table( H_m ~ b0 * (1 - exp( -b1 * DBH_cm))^b2,
mod_start = c(b0=23, b1=0.03, b2 =1.3),
output = "table") %>%
arrange(plot_ID, SP_code),
by = c("plot_ID", "SP_code"))%>%
# mutating statistical precictors
mutate(H_est = b0 * (1 - exp( -b1 * DBH_cm))^b2) %>%
group_by(plot_ID, SP_code) %>%
summarise( b0 = mean(b0),
b1 = mean(b1),
b2 = mean(b2),
#https://rdrr.io/cran/forestmangr/f/vignettes/eq_group_fit_en.Rmd
bias = bias_per(y = H_m, yhat = H_est),
rsme = rmse_per(y = H_m, yhat = H_est),
#https://stackoverflow.com/questions/14530770/calculating-r2-for-a-nonlinear-least-squares-fit
R2 = max(cor(H_m, H_est),0)^2,
#https://stats.stackexchange.com/questions/11676/pseudo-r-squared-formula-for-glms
mean_h = mean(H_m),
N = length(H_m),
SSres = sum((H_m-H_est)^2),
SStot = sum((H_m-mean_h)^2),
pseu_R2 = 1-(SSres/SStot),
diff_h = mean(H_m - H_est))
# ----- 2.1.1.2. coefficents dataframe per SP over all plots when >= 3 heights measured --------
# coefficents of non-linear height model per species but over all plots:
# https://rdrr.io/cran/forestmangr/f/vignettes/eq_group_fit_en.Rmd
#  building separate dataframe for speicies soecific models adding adding bias, rmse and rsqrd
coeff_H_SP <- left_join(trees_total %>%
select(SP_code, H_m, DBH_cm, DBH_class) %>%
filter(!is.na(H_m) & !is.na(DBH_cm) & !is.na(DBH_class)) %>%
group_by(SP_code) %>%
filter(n() >= 3),
trees_total %>%
select(SP_code, H_m, DBH_cm, DBH_class) %>%
filter(!is.na(H_m) & !is.na(DBH_cm) & !is.na(DBH_class) ) %>%
#filter(DBH_cm <= 150) %>%
group_by(SP_code) %>%
# filter for plots where there is at least 3 heights measured for each species
#https://stackoverflow.com/questions/20204257/subset-data-frame-based-on-number-of-rows-per-group
filter(n() >= 3)%>%
group_by(SP_code) %>%
nls_table( H_m ~ b0 * (1 - exp( -b1 * DBH_cm))^b2,
mod_start = c(b0=23, b1=0.03, b2 =1.3),
output = "table"),
by = c("SP_code"))%>%
mutate(H_est = b0 * (1 - exp( -b1 * DBH_cm))^b2) %>%
group_by(SP_code) %>%
summarise( b0 = mean(b0),
b1 = mean(b1),
b2 = mean(b2),
#https://rdrr.io/cran/forestmangr/f/vignettes/eq_group_fit_en.Rmd
bias = bias_per(y = H_m, yhat = H_est),
rsme = rmse_per(y = H_m, yhat = H_est),
#https://stackoverflow.com/questions/14530770/calculating-r2-for-a-nonlinear-least-squares-fit
R2 = max(cor(H_m, H_est),0)^2,
#https://stats.stackexchange.com/questions/11676/pseudo-r-squared-formula-for-glms
mean_h = mean(H_m),
N = length(H_m),
SSres = sum((H_m-H_est)^2),
SStot = sum((H_m-mean_h)^2),
pseu_R2 = 1-(SSres/SStot),
diff_h = mean(H_m - H_est)) %>%
mutate(plot_ID = as.factor('all')) %>%
select(plot_ID, SP_code, b0, b1, b2, bias, rsme, R2, mean_h, N, SSres, SStot, pseu_R2, diff_h)
# ----- 2.1.1.3. combined coefficients of height models ---------------------
coeff_H_comb <- rbind(coeff_H_SP_P %>% mutate(plot_ID = as.factor(plot_ID)), coeff_H_SP)
# ----- 2.1.1.4. have a look at the quality of the models  ------------------------------
# from my previous attempts to fit and validate species specific but also total
# dataset including regression models for the height, I know that actually the
# DBH class is the better predictor
# but on the other hand the diameter class is also less precise
summary(coeff_H_SP)
# the R2 is pretty poor for some plots
coeff_H_comb %>% filter(R2 <= 0.3)
#view(trees_total %>% filter(plot_ID == 32080))
summary(coeff_H_SP_P)
coeff_H_comb %>% filter(diff_h >= 0.75)
#view(coeff_H_SP_P %>% filter(rsqrd<=0.5))
# ----- 2.1.1.5. join coefficients to the tree data set & calculate missing heights  ----------------------------
# estimating height by using different functions, depending on the models R2
trees_total_5 <- trees_total %>%
unite(SP_P_ID, plot_ID, SP_code, sep = "", remove = FALSE) %>%            # create column matching vectorised coefficients of coeff_SP_P (1.3. functions, h_nls_SP_P, dplyr::pull)
left_join(.,coeff_H_SP_P %>%                                              # joining R2 from coeff_SP_P -> R2.x
select(plot_ID, SP_code, R2) %>%
unite(SP_P_ID, plot_ID, SP_code, sep = "", remove = FALSE),   # create column matching vectorised coefficients of coeff_SP_P (1.3. functions, h_nls_SP_P, dplyr::pull)
by = c("plot_ID", "SP_code", "SP_P_ID")) %>%
left_join(., coeff_H_SP %>% select(SP_code, R2),               # joing R2 from coeff_SP data set -> R2.y
by = "SP_code") %>%
left_join(., trees_total %>%                                  # this is creates a tree dataset with mean BHD, d_g, h_g per species per plot per canopy layer wich we need for SLOBODA
group_by(plot_ID, C_layer, SP_code) %>%             # group by plot and species and canopy layer to calcualte dg, hg
summarise(H_g = sum(mean(na.omit(H_m))*BA_m2)/sum(BA_m2),    # Hoehe des Grundflächemittelstammes, calculation according to S. Schnell
mean_DBH_mm = mean(DBH_mm),               # mean diameter per species per canopy layer per plot
D_g = ((sqrt((mean(BA_m2)/pi)))*2)*100),   # Durchmesser des Grundflächenmittelstammes; *100 to get from 1m -> 100cm
by = c("plot_ID", "SP_code", "C_layer")) %>%
left_join(., trees_total %>%                                 # dataset with mean sampled height per plot and species, to assign it to trees that don´t have a proper estimated height
filter(!is.na(H_m)) %>%                              # filter for trees with measured height, so trees where H_m != NA
group_by(plot_ID, SP_code) %>%                       # group by plot and species
summarise(mean_H_m = mean(H_m)),                     # calculate mean height in m
by = c("plot_ID", "SP_code")) %>%                      # join in by plot_ID and SP_code
mutate(R2_comb = f(R2.x, R2.y, R2.y, R2.x),                               # if R2 is na, put R2 from coeff_SP_P unless R2 from coeff_SP is higher
H_method = case_when(is.na(H_m) & !is.na(R2.x) & R2.x > 0.70 | is.na(H_m) & R2.x > R2.y & R2.x > 0.7 ~ "coeff_SP_P",
is.na(H_m) & is.na(R2.x) & R2.y > 0.70| is.na(H_m) & R2.x < R2.y & R2.y > 0.70 ~ "coeff_sp",
is.na(H_m) & is.na(R2_comb) & !is.na(H_g)| is.na(H_m) & R2_comb < 0.70 & !is.na(H_g) ~ "ehk_sloboda",
is.na(H_m) & is.na(R2_comb) & is.na(H_g)| is.na(H_m) & R2_comb < 0.70 & is.na(H_g) ~ "h_curtis",
TRUE ~ "sampled")) %>%
# When h_m is na but there is a plot and species wise model with R2 above 0.7, use the model to predict the height
mutate(H_m = case_when(is.na(H_m) & !is.na(R2.x) & R2.x > 0.70 | is.na(H_m) & R2.x > R2.y & R2.x > 0.7 ~ h_nls_SP_P(SP_P_ID, DBH_cm),
# if H_m is na and there is an R2 from coeff_SP_P thats bigger then 0.75 or of theres no R2 from
# coeff_SP_plot that´s bigger then R2 of coeff_SP_P while the given R2 from coeff_SP_P is above
# 0.75 then use the SP_P models
is.na(H_m) & is.na(R2.x) & R2.y > 0.70 | is.na(H_m) & R2.x < R2.y & R2.y > 0.70 ~ h_nls_SP(SP_code, DBH_cm),
# when there´s still no model per species or plot, or the R2 of both self-made models is below 0.7
# and hm is na but there is a h_g and d_G
is.na(H_m) & is.na(R2_comb) & !is.na(H_g)| is.na(H_m) & R2_comb < 0.70 & !is.na(H_g) ~ ehk_sloboda(H_SP_group, DBH_mm, mean_DBH_mm, D_g, H_g),
# when there´s still no model per species or plot, or the R2 of both self-made models is below 0.7
# and hm is na and the Slobody function cannot eb applied because there is no h_g calculatable use the curtis function
is.na(H_m) & is.na(R2_comb) & is.na(H_g)| is.na(H_m) & R2_comb < 0.70 & is.na(H_g) ~ h_curtis(H_SP_group, DBH_mm),
TRUE ~ H_m),
HD_value = (H_m*100)/DBH_cm,      # this is meant for a plausability check so we can filter for trees with an inplausible height/ diameter ratio
# here we correct the estimated height if it happens to be below the height of diameter measurement
H_m = case_when(H_method != "sampled" & is.na(H_m) | H_method != "sampled" & H_m < (DBH_h_cm/100) ~ mean_H_m,
TRUE ~ H_m)
)
# ----- 2.1.2.6. exclude plots with mistaken heights ----------------------
# there were trees where the estimated height is below the diameter measurement height:
# those plots are going to be excluded from the calculation for now
LT_P_to_exclude_H <- trees_total_5 %>% filter(H_m < (DBH_h_cm/100))
# export problematic plots
write.csv(LT_P_to_exclude_H, paste0(momok.out.home,"LT_P_to_exclude_H.csv"))
# 33010, 25100
# remove whole plots with implausbible heights from the dataset by anti joining exclude dataset with trees dataset
trees_total_5 <- trees_total_5 %>% anti_join(LT_P_to_exclude_H, trees_total_5, by = "plot_ID")
# ----- 2.1.2. living tree biomass --------------------------------------------------------------
# input vairbales for the biomass models for the trees aboveground biomass without canopy are:
# DBH, diameter at 1/3 of the tree height, species, tree height
# ----- 2.1.2.1 dominant height -----------------------------------------------------------
# ----- 2.1.2.1.1. my idea ----------------------------------------------------------------
# necesaryy as side index for the better broadleved models
# Arithmetisches Mittel der Hoehe der 100 stärksten Bäume je ha. (In Deutschland auch als Spitzenhoehe h100 oder h200 bezeichnet; die WEISE�sche Oberhoehe [ho] entspricht der Hoehe des Grundflächen- Mittelstammes der 20 % stärksten Bäume eines Bestandes).
# Wichtig: Die Art der Oberhoehe muss jeweils definiert werden.
# my problem: there are no 100 trees per plot and I don´t know how to estimate the height of the top 100
# https://statisticsglobe.com/select-top-n-highest-values-by-group-in-r#example-2-extract-top-n-highest-values-by-group-using-dplyr-package
# data %>%                                      # Top N highest values by group
#   arrange(desc(value)) %>%
#   group_by(group) %>%
#   slice(1:3)
# https://rdrr.io/cran/dplyr/man/top_n.html
#df %>% top_n(2)  # highest values
# https://statisticsglobe.com/select-top-n-highest-values-by-group-in-r
# https://stackoverflow.com/questions/1563961/how-to-find-top-n-of-records-in-a-column-of-a-dataframe-using-r filter ..% of observations that represent top 100 trees
# top100 <- function(df, p_ID, plot_A){
#   df <- trees_total_5;                      # the dataframe I´m working with
#   p_ID <- df %>% dplyr::pull(plot_ID)       # the plot ID
#   n_plot <- df %>% group_by(plot_ID) %>%  count() %>% dplyr::pull(n, plot_ID);  # number of trees per plot
#   plot_A <- df %>% dplyr::pull(plot_A_ha);  # plot area in hectare
#   n_ha  <- n_plot/mean(plot_A);             # number of trees per hectare by dividing number of trees per plot by pplot area in hectare
#   p <- 100/n_ha;                            # percentage  representing 100 trees of the total number of trees per hectare for each plot
#   return(as.integer(floor(n_plot[p_ID]*p[p_ID])))              # number of rows to select from each
# }
#
# trees_total_5 %>%
#   group_by(plot_ID) %>%
#   slice_max(., DBH_cm, n = top100(trees_total_5, plot_ID, plot_A_ha):n()) %>%
#   mutate(H_o = mean(H_m))
# ----- 2.1.2.1.2. dominant height for loop by Alex Cheypowski ----------------------------------------------------------------
#calculate the number of each plot to be selected and write them in vector
# n_t100 <- trees_total_5 %>%
# group_by(plot_ID) %>%
# summarize(N_trees_plot = n(),
#           plot_A_ha = mean(plot_A_ha)) %>%
# mutate(N_trees_ha = N_trees_plot/plot_A_ha,
#        percent_t100 = as.numeric((100/N_trees_ha))) %>%
# mutate(percent_t100_corrected = as.numeric(ifelse(percent_t100 < 1.0, percent_t100, 1.0)),
#        n_rows_t100 = as.integer(N_trees_plot*percent_t100_corrected)) %>% # if the proportion woul dbe higher then the total amount of rows because there are so few trees per hectare calcuate with all the trees per plot (1)
# select(n_rows_t100, plot_ID)
#calculate the fraction of each plot to be selected and write them in vector
# p_t100 <- trees_total_5 %>%
#   group_by(plot_ID) %>%
#   summarize(N_trees_plot = n(),
#             plot_A_ha = mean(plot_A_ha)) %>%
#   mutate(N_trees_ha = N_trees_plot/plot_A_ha,
#          percent_t100 = as.numeric((100/N_trees_ha))) %>%
#   mutate(percent_t100_corrected = as.numeric(ifelse(percent_t100 < 1.0, percent_t100, as.numeric(1.0))),
#          n_rows_t100 = as.integer(N_trees_plot*percent_t100_corrected)) %>% # if the proportion woul dbe higher then the total amount of rows because there are so few trees per hectare calcuate with all the trees per plot (1)
#   dplyr::pull(as.numeric(percent_t100_corrected))
#create a vector to store final result(mean hight)
#set its length to number of unique plots
mean100top <- numeric(nrow(trees_total_5 %>%
dplyr::select(plot_ID) %>%
distinct()))
#make a for loop to do slice_max for each plot with it's corresponding proportion
# and write results in mean100top vector
for(id in unique(trees_total_5$plot_ID)){
# calcuate number of rows to extract per plot
n_t100 = trees_total_5 %>%
filter(plot_ID == id) %>%
summarize(plot_ID = mean(plot_ID),
N_trees_plot = n(),
plot_A_ha = mean(plot_A_ha)) %>%
mutate(N_trees_ha = N_trees_plot/plot_A_ha,
percent_t100 = as.numeric((100/N_trees_ha))) %>%
mutate(percent_t100_corrected = as.numeric(ifelse(percent_t100 < 1.0, percent_t100, 1.0)),
n_rows_t100 = as.integer(N_trees_plot*percent_t100_corrected)) %>% # if the proportion would be higher then the total amount of rows because there are so few trees per hectare calcuate with all the trees per plot (1)
dplyr::pull(n_rows_t100)
# dataframe with mean height of top n rows
sliced_plot <- trees_total_5 %>%
#group_by(plot_ID) %>%
filter(plot_ID == id) %>%
slice_max(DBH_cm, n = n_t100, with_ties = FALSE) %>% # select top 100 representing rows
summarise(plot_ID = mean(plot_ID),
H_g_top = sum(mean(na.omit(H_m))*BA_m2)/sum(BA_m2),    # Hoehe des Grundflächemittelstammes, calculation according to S. Schnell
top_H = mean(H_m))                         # calculate mean height
mean100top[id] <- sliced_plot[1,2]
}
# ----- 2.1.2.1.3. dominant height dreisatz Lukas Mörler ----------------------------------------------------------------
# new idea by Lukas Mörler 31.04.2023:
#                               10 000 m2 --> 100 Bäume
#                                    1 ha --> 100 Bäume
#   1 /(1/0.05003) =  0.05003(plot area) --> 100/(1/0.05003) Bäume
#                                0.05003 --> 5 Bäume pro plot
# mean100top.1 <- numeric(nrow(trees_total_5 %>%
#                              dplyr::select(plot_ID) %>%
#                              distinct()))
#
# for(id in unique(trees_total_5$plot_ID)){
#   # calcuate number of rows to extract per plot
#   # id = 26030
#
#   n_t100 = as.numeric(trees_total_5 %>%
#     filter(plot_ID == id) %>%
#     mutate(n_t100 = as.numeric(ceiling(100/(1/plot_A_ha)))) %>%
#     select(n_t100) %>%
#     distinct() %>%
#     dplyr::pull(n_t100))
#
#   # dataframe with mean height of top n rows
#   sliced_plot <- trees_total_5 %>%
#     #group_by(plot_ID) %>%
#     filter(plot_ID == id) %>%
#     slice_max(DBH_cm, n = n_t100, with_ties = FALSE) %>% # select top 100 representing rows
#     summarise(plot_ID = mean(plot_ID),
#               H_g_top = sum(mean(na.omit(H_m))*BA_m2)/sum(BA_m2),    # Hoehe des Grundflächemittelstammes, calculation according to S. Schnell
#               top_H = mean(H_m))                         # calculate mean height
#
#   mean100top.1[id] <- sliced_plot[1,2]
# }
# ----- 2.1.2.1.3. dominant height # dominant height without loop basen on Lukas Mörler ----------------------------------------------------------------
# based on:  new idea by Lukas Mörler 31.04.2023:
#                               10 000 m2 --> 100 Bäume
#                                    1 ha --> 100 Bäume
# 1 ha divided by 1: plot size so the resul will be the plot size --> the same has to be applied to the other side of the fomula
#   1 /(1/0.05003) =  0.05003(plot area) --> 100/(1/0.05003) Bäume
#                                0.05003 --> 5 Bäume pro plot
# x = floor(100/(1/trees_total_5$plot_A_ha));
#
# H_o <- trees_total_5 %>%
#   group_by(plot_ID, CCS_nr, C_layer, SP_code) %>%
#   slice_max(DBH_cm, n = unique(floor(100/(1/trees_total_5$plot_A_ha))), with_ties = FALSE) %>%                  # select top 100 representing rows --> 5 per plot (actually per sampling circuit)
#   summarise(H_g_top = sum(mean(na.omit(H_m))*c_A((DBH_cm/2)/100))/sum(c_A((DBH_cm/2)/100)),    # Hoehe des Grundflächemittelstammes der 100 stärksten Bäume, calculation according to S. Schnell
#             top_H = mean(H_m))
#
# ----- 2.1.2.2. estimated biomass & carbon living trees -----------------------------------------------------------
trees_total_5 <-  trees_total_5 %>%
# joining H_o100 in
left_join(., trees_total_5 %>%
group_by(plot_ID, CCS_nr, C_layer, SP_code) %>%     # top 100 are setermined per plot, smaöing corcuit, canopy layer and species
slice_max(DBH_cm, n = unique(floor(100/(1/trees_total_5$plot_A_ha))), with_ties = FALSE) %>%                     # select top 100 representing rows --> 5 per plot basen on dreisatz (actually per sampling circuit)
summarise(H_g_top = sum(mean(na.omit(H_m))*c_A((DBH_cm/2)/100))/sum(c_A((DBH_cm/2)/100))),    # Hoehe des Grundflächemittelstammes der 100 stärksten Bäume, calculation according to S. Schnell
by = c("plot_ID", "CCS_nr", "C_layer", "SP_code")) %>%
# TapeS : aing diameter at 0.3 tree height to trees_total dataframe
#https://gitlab.com/vochr/tapes/-/blob/master/vignettes/tapes.rmd
mutate(DBH_h_m = ifelse(is.na(DBH_h_cm), 1.3, DBH_h_cm/100),
D_03_cm = tprDiameter(tprTrees(spp = tpS_ID, Dm = as.list(DBH_cm), Hm = as.list(DBH_h_m), Ht = H_m, inv = 4), Hx = 1/3*H_m, cp=FALSE),
)
# ----- 0.4.1. diameter correction Dahm parameters ------------------------
DBH_region <- read.delim(file = here("data/input/BZE2_HBI/DBH_dahm_region.csv"), sep = ",", dec = ",")
DBH_region
# ----- 0.4.1. diameter correction Dahm parameters ------------------------
DBH_region <- read.delim(file = here("data/input/BZE2_HBI/DBH_dahm_region.csv"), sep = ";", dec = ",")
DBH_region
HBI_trees
HBI_loc
# HBI_trees_update <- read.delim(file = here("output/out_data/out_data_BZE/HBI_trees_update_1.csv"), sep = ",", dec = ",")
# HBI BE locations dataset: this dataset contains the coordinates of the center point of the tree inventory accompanying the second national soil inventory
HBI_loc <- read.delim(file = here("data/input/BZE2_HBI/location_HBI.csv"), sep = ";", dec = ",")
HBI_loc
# HBI point info
HBI_inv_info <- read.delim(file = here("data/input/BZE2_HBI/be.csv"), sep = ",", dec = ",", stringsAsFactors=FALSE)
HBI_inv_info
DBH_SP <- read.delim(file = here("data/input/BZE2_HBI/DBH_dahm_species.csv"), sep = ";", dec = ",")
DBH_SP
DBH_tan <- read.delim(file = here("data/input/BZE2_HBI/DBH_dahm_species.csv"), sep = ";", dec = ",")
DBH_tan
DBH_tan <- read.delim(file = here("data/input/BZE2_HBI/DBH_dahm_tangenz.csv"), sep = ";", dec = ",")
DBH_tan
DBH_region
colnames(DBH_region%>%
select(ï..ICode, KurzD,  LangD, Region))<- c("icode_reg", "reg_shortG", "reg_longG", "region")
colnames(DBH_region <- DBH_region %>% select(ï..ICode, KurzD,  LangD, Region)) <- c("icode_reg", "reg_shortG", "reg_longG", "region")
DBH_region <- DBH_region %>% select(ï..ICode, KurzD,  LangD, Region)
colnames(DBH_region) <- c("icode_reg", "reg_shortG", "reg_longG", "region")
DBH_region
DBH_SP
DBH_SP<- DBH_SP %>% select("ï..ICode", "KurzD", "Gattung", "Art", "ba_BWI1")
colnames(DBH_SP) <- c("icode_spec", "Chr_code_ger", "bot_genus", "bot_species", "ba_BWI1")
colnames(DBH_tan)
DBH_tan <- read.delim(file = here("data/input/BZE2_HBI/DBH_dahm_tangenz.csv"), sep = ";", dec = ",")
colnames(DBH_tan) <- c("SP_BWI1", "icode", "region", "tangenz")
HBI_inv_info
HBI_loc
HBI_trees
HBI_inv_info
DBH_region
DBH_region <- read.delim(file = here("data/input/BZE2_HBI/DBH_dahm_region.csv"), sep = ";", dec = ",")
DBH_region
HBI_inv_info <- read.delim(file = here("data/input/BZE2_HBI/be.csv"), sep = ",", dec = ",", stringsAsFactors=FALSE)
HBI_inv_info
DBH_region
HBI_inv_info
DBH_region$Region[which(grepl("SH", DBH_region$KurzD))]
DBH_region$Region[which(grepl("NRW", DBH_region$KurzD))]
DBH_region
DBH_region$Region[which(grepl("NW", DBH_region$KurzD))]
DBH_species
DBH_SP
DBH_SP$ba_BWI1[which(grepl("AH", DBH_SP$Chr_code_ger))]
DBH_SP$ba_BWI1[which(DBH_SP$Chr_code_ger == "AH")]
sp_tan = "AH"
reg_tan = 1
tangenz <- DBH_tan$tangenz[which(DBH_tan$SP_BWI1 == sp_tan & DBH_tan$region == reg_tan)]
tangenz
DBH_tan

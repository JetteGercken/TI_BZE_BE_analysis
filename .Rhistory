# intersection of trees with 2 edges
trees.two.edges.nogeo <- trees_data %>%
# filter only for trees that are located in plots with a forest edge
semi_join(forest_edges.man %>% filter(e_form == 1 | e_form == 2) %>%
#& inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%
select(plot_ID) %>% distinct(), by = "plot_ID") %>%
# filter for trees located in plots htat haev only one forest edge
semi_join(forest_edges.man %>% filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%
group_by(plot_ID) %>% summarise(n = n()) %>% filter(n > 1) %>% select(plot_ID), by = "plot_ID") #%>%
## remove plots that do now have a corresponding center coordiante in the HBI loc document
# semi_join(geo_loc %>% filter(!is.na( RW_MED) & !is.na(HW_MED)) %>%  select(plot_ID)  %>% distinct(), by = "plot_ID")
tree.status.two.edges.list.nogeo <- vector("list", length = length(trees.two.edges.nogeo$tree_ID))
tree.points.two.edges.list.nogeo <- vector("list", length = length(trees.two.edges.nogeo$tree_ID))
for (i in 1:length(trees.two.edges.nogeo$tree_ID)){
# i = 1
# i = which(grepl(50122, (trees.two.edges.nogeo$plot_ID)))[2]
# select plot ID accordint to positioin in the list
my.plot.id <- trees.two.edges.nogeo[i, "plot_ID"]
my.tree.id <- trees.two.edges.nogeo[i, "tree_ID"]
my.inv.year <- trees.two.edges.nogeo[i, "inv_year"]
## select the UTM coordiantes of the center of the cirlce corresponding with the plot ID
# my.center.easting <- geo_loc[geo_loc$plot_ID == my.plot.id, "RW_MED"]
# my.center.northing <- geo_loc[geo_loc$plot_ID == my.plot.id, "HW_MED"]
## select crs
# my.utm.epsg <-  paste0("+proj=utm +zone=", pick_utm(my.center.easting)," ", "+datum=WGS84 +units=m +no_defs +type=crs")
# select the remaining cirlce we want to intersect the tree with
my.rem.circle <- sf::st_as_sf(rem.circle.two.edges.df.nogeo %>% filter(plot_ID == my.plot.id) %>% distinct())
my.edges.df <- inter.poly.two.edges.df.nogeo %>% filter(plot_ID == my.plot.id) %>% distinct() %>% arrange(e_ID)
my.inter.1 <- sf::st_as_sf(my.edges.df[1,])
my.inter.2 <- sf::st_as_sf(my.edges.df[2,])
# assign stand category to the polygones depending on which one is bigger/ smaller:
# bigger polygone/ polygone with greater area is assigned to category A, smaller area polygone is assigned to B
area.plot.df <- edges.area.two.edges.df.nogeo %>% filter(plot_ID == my.plot.id & CCS_r_m == 17.84) %>%
arrange(as.numeric(area_m2)) %>%
mutate(stand = case_when(
row_number()== 1 ~ "C",
row_number()== 2 ~ "B",
row_number()== 3 ~ "A",
TRUE ~ NA))
# assign stand category to the polygones depending on which one is bigger/ smaller
my.rem.circle$stand <- area.plot.df$stand[area.plot.df$e_ID == 0]
my.inter.1$stand <- area.plot.df$stand[area.plot.df$e_ID == 1]
my.inter.2$stand <- area.plot.df$stand[area.plot.df$e_ID == 2]
# extract polar coordiantes of forest edge
# point A
dist.tree <- trees.two.edges.nogeo[i, "dist_cm"]/100
azi.tree <- trees.two.edges.nogeo[i, "azi_gon"]
x.tree <- dist.tree*sin(azi.tree)   # longitude, easting, RW, X
y.tree <- dist.tree*cos(azi.tree)   # latitude, northing, HW, y
# transform polar into cartesian coordiantes
tree.east <- x.tree  # + my.center.easting
tree.north <- y.tree # + my.center.northing
# save cartesian coordiantes in dataframe
tree.coord.df <- as.data.frame(cbind(
"plot_ID" = c(as.integer(my.plot.id)),
"tree_ID" = c(as.integer(my.tree.id)),
"inv_year" = c(my.inv.year),
"lon" = c(tree.east),
"lat" = c(tree.north)
))
# create sf point object from dataframe
#https://stackoverflow.com/questions/52551016/creating-sf-points-from-multiple-lat-longs
tree.sf <-  sf::st_as_sf(tree.coord.df, coords = c("lon", "lat"), remove = FALSE)
## assing CRS to points
#sf::st_crs(tree.sf) <- my.utm.epsg
# print(plot(my.rem.circle$geometry, col = "red"),
#       plot(my.inter.2$geometry, add = T),
#       plot(my.inter.1$geometry, add = T),
#       plot(tree.sf$geometry, add = T)
#       )
inter.tree.circle <- sf::st_intersection(tree.sf, my.rem.circle)
inter.tree.edge.1 <- sf::st_intersection(tree.sf, my.inter.1)
inter.tree.edge.2 <- sf::st_intersection(tree.sf, my.inter.2)
tree_status <- ifelse(nrow(inter.tree.edge.1)!= 0 & nrow(inter.tree.edge.2)== 0 & nrow(inter.tree.circle)== 0,  my.inter.1$stand,                     # if tree is in edge 1
ifelse(nrow(inter.tree.edge.2)!= 0 & nrow(inter.tree.edge.1)== 0 & nrow(inter.tree.circle)== 0,  my.inter.2$stand,              # if tree is in edge 2
ifelse(nrow(inter.tree.circle)!= 0 & nrow(inter.tree.edge.1)== 0 & nrow(inter.tree.edge.2)== 0,  my.rem.circle$stand,    # if tree is in circle
#ifelse(nrow(inter.tree.circle)== 0 & nrow(inter.tree.edge.1)!= 0 & nrow(inter.tree.edge.2)!= 0,  "warning",       # if tree is in two edges
"warning")))                                                                                             # if tree is nowhere
tree.status.two.edges.list.nogeo[[i]] <- as.data.frame(cbind(
"plot_ID" = c(as.integer(my.plot.id)),
"tree_ID" = c(as.integer(my.tree.id)),
"inv_year" = c(my.inv.year),
"lon" = c(as.numeric(tree.coord.df$lon)),
"lat" = c(as.numeric(tree.coord.df$lat)),
"t_stat" = c(tree_status)))
tree.points.two.edges.list.nogeo[[i]] <- c("t_stat" = tree_status, tree.sf)
}
# save tree corodiantes and status into dataframe
tree.status.list.two.edges.final.nogeo <- rbindlist(tree.status.two.edges.list.nogeo)
tree.status.two.edges.df.nogeo <- as.data.frame(tree.status.list.two.edges.final.nogeo)
# save tree sf into dataframe
tree.points.list.two.edges.final.nogeo <- rbindlist(tree.points.two.edges.list.nogeo)
tree.points.two.edges.df.nogeo <- as.data.frame(tree.points.list.two.edges.final.nogeo)
# bind the tree point datafarmes of one and two edges plots together
# bind the tree point datafarmes of one and two edges plots together
two.and.one.edge.trees.points.df.nogeo <- rbind(tree.points.one.edge.df.nogeo,tree.points.two.edges.df.nogeo)
# this step i separated in case both of the rbinded dfs are empty and the mutate wouldn´t grip
two.and.one.edge.trees.points.df.nogeo <- two.and.one.edge.trees.points.df.nogeo %>% mutate(plot_ID = as.integer(plot_ID))
# 3.2.2.3 plots with no edge edge: sorting trees into circle ---------
trees.no.edge.nogeo <- anti_join(trees_data, two.and.one.edge.trees.points.df.nogeo %>%
select(plot_ID) %>%
distinct(), by = "plot_ID")#%>%
# remove plots that do now have a corresponding center coordiante in the HBI loc document
# semi_join(geo_loc %>% filter(!is.na( RW_MED) & !is.na(HW_MED)) %>%  select(plot_ID)  %>% distinct(), by = "plot_ID")
# there may be no egdges or edges with no trees in this case only the last loop will run:
# so what we need are 3 versions of the final dataset:
# 1. there are no edges --> if forest_edges.man is epmty, we don´t filter the trees at all
# 2. there are only plots with 1 edge --> the forest_edges.man.sub.one.edge.df is not empty so that this loop ran
# 3. there are only plots with 2 edges --> the forest_edges.man.sub.two.edges.df is not empty so that this loop ran
# this should work because the forest_edges.man.sub are filtered by forest_edges_man and don´t depend on each other
# https://www.learnbyexample.org/r-if-else-elseif-statement/
## there are no edges
if(nrow(forest_edges) == 0){
trees.no.edge.nogeo <- trees_data#%>%
# remove plots that do now have a corresponding center coordiante in the BZE3 loc document
# semi_join(geo_loc %>% filter(!is.na( RW_MED) & !is.na(HW_MED)) %>%  select(plot_ID)  %>% distinct(), by = "plot_ID")
## there are no trees in plots with two edges
} else if (nrow(tree.status.one.edge.df.nogeo) == 0 && nrow(tree.status.two.edges.df.nogeo) != 0){
trees.no.edge.nogeo <- trees_data %>%
anti_join(., tree.status.two.edges.df.nogeo %>%
select(plot_ID) %>%
distinct(), by = "plot_ID")#%>%
# remove plots that do now have a corresponding center coordiante in the BZE3 loc document
# semi_join(geo_loc %>% filter(!is.na( RW_MED) & !is.na(HW_MED)) %>%  select(plot_ID)  %>% distinct(), by = "plot_ID")
## there are no trees in plots with one edge
}else if(nrow(tree.status.one.edge.df.nogeo) != 0 && nrow(tree.status.two.edges.df.nogeo) == 0){
trees.no.edge.nogeo <- trees_data %>%
anti_join(., tree.status.one.edge.df.nogeo %>%
select(plot_ID) %>%
distinct(), by = "plot_ID")#%>%
# remove plots that do now have a corresponding center coordiante in the BZE3 loc document
# semi_join(geo_loc %>% filter(!is.na( RW_MED) & !is.na(HW_MED)) %>%  select(plot_ID)  %>% distinct(), by = "plot_ID")
## there are plots with two and one edges and trees inside it
}else if(nrow(tree.status.one.edge.df.nogeo) != 0 && nrow(tree.status.two.edges.df.nogeo) != 0){
trees.no.edge.nogeo <- trees_data %>%
anti_join(., tree.status.one.edge.df.nogeo %>%
select(plot_ID) %>%
distinct(), by = "plot_ID") %>%
anti_join(., tree.status.two.edges.df.nogeo %>%
select(plot_ID) %>%
distinct(), by = "plot_ID")#%>%
# remove plots that do now have a corresponding center coordiante in the BZE3 loc document
# semi_join(geo_loc %>% filter(!is.na( RW_MED) & !is.na(HW_MED)) %>%  select(plot_ID)  %>% distinct(), by = "plot_ID")
## this is if there are edges but they don´t have trees
}else{
trees.no.edge.nogeo <- trees_data#%>%
# remove plots that do now have a corresponding center coordiante in the BZE3 loc document
# semi_join(geo_loc %>% filter(!is.na( RW_MED) & !is.na(HW_MED)) %>%  select(plot_ID)  %>% distinct(), by = "plot_ID")
}
tree.status.no.edge.list.nogeo <- vector("list", length = length(trees.no.edge.nogeo$tree_ID))
tree.points.no.edge.list.nogeo <- vector("list", length = length(trees.no.edge.nogeo$tree_ID))
for (i in 1:length(trees.no.edge.nogeo$tree_ID)){
#i = 2173
#i = which(grepl(50146, unique(trees.no.edge.nogeo$plot_ID)))
# select plot ID accordint to positioin in the list
my.plot.id <- trees.no.edge.nogeo[i, "plot_ID"]
my.tree.id <- trees.no.edge.nogeo[i, "tree_ID"]
my.inv.year <- trees.no.edge.nogeo[i, "inv_year"]
## georeference
## select UTM corrdinates of the plot center
# my.center.easting <- geo_loc[geo_loc$plot_ID == my.plot.id, "RW_MED"]
# my.center.northing <- geo_loc[geo_loc$plot_ID == my.plot.id, "HW_MED"]
## select crs
# my.utm.epsg <-  paste0("+proj=utm +zone=", pick_utm(my.center.easting)," ", "+datum=WGS84 +units=m +no_defs +type=crs")
# extract polar coordiantes of forest edge
# point A
dist.tree <- trees.no.edge.nogeo[i, "dist_cm"]/100
azi.tree <- trees.no.edge.nogeo[i, "azi_gon"]
x.tree <- dist.tree*sin(azi.tree)   # longitude, easting, RW, X
y.tree <- dist.tree*cos(azi.tree)   # latitude, northing, HW, y
# transform polar into cartesian coordiantes
tree.east <- x.tree  # + my.center.easting
tree.north <- y.tree # + my.center.northing
# save cartesian coordiantes in dataframe
tree.coord.df <- as.data.frame(cbind(
"plot_ID" = c(as.integer(my.plot.id)),
"tree_ID" = c(as.integer(my.tree.id)),
"inv_year" = c(my.inv.year),
"lon" = c(as.numeric(tree.east)),
"lat" = c(as.numeric(tree.north))
))
# create sf point object from dataframe
#https://stackoverflow.com/questions/52551016/creating-sf-points-from-multiple-lat-longs
tree.sf <-  sf::st_as_sf(tree.coord.df, coords = c("lon", "lat"), remove = FALSE)
## assing CRS to points
#sf::st_crs(tree.sf) <- my.utm.epsg
#### build circle
# circle data
c.x0 = 0  # + my.center.easting
c.y0 = 0  # + my.center.northing
c.r3 = 17.84
c.r2 = 12.62
c.r1 = 5.64
# build polygon (circlular buffer) around center point
center.df<- as.data.frame(cbind("lon" = c.x0, "lat" = c.y0))
circle.pt <- sf::st_as_sf(center.df, coords = c("lon", "lat"))
## assing crs to cirlce corodiantes
# sf::st_crs(circle.pt) <- my.utm.epsg
circle.17 <- sf::st_buffer(circle.pt, c.r3)
circle.12 <- sf::st_buffer(circle.pt, c.r2)
circle.5 <- sf::st_buffer(circle.pt, c.r1)
inter.tree.circle.17 <- sf::st_intersection(tree.sf, circle.17)
# if a tree is not intersecting with the circle or its exactly at the edge of the cirlce the inter.tree.circle.17 will be empty,
# however, trees that are exactly 17.84 meters apart from the circle center would still be part of the plot, tho the polygones won´t detect and intersection
# which is why trees only receive the status "warning" if they are acturally situated outside of the circle
tree_status <- ifelse(nrow(inter.tree.circle.17) == 0 & dist.tree > 17.84,  "warning", "A")                                                                                            # if tree is nowhere
tree.status.no.edge.list.nogeo[[i]] <- as.data.frame(cbind(
"plot_ID" = c(as.integer(my.plot.id)),
"tree_ID" = c(as.integer(my.tree.id)),
"inv_year" = c(my.inv.year),
"lon" = c(as.numeric(tree.coord.df$lon)),
"lat" = c(as.numeric(tree.coord.df$lat)),
"t_stat" = c(tree_status))
)
tree.points.no.edge.list.nogeo[[i]] <- c("t_stat" = tree_status, tree.sf)
}
# save tree corodiantes and status into dataframe
tree.status.no.edges.df.nogeo <- as.data.frame(rbindlist(tree.status.no.edge.list.nogeo))
# save tree sf into dataframe
tree.points.no.edges.df.nogeo <- as.data.frame(rbindlist(tree.points.no.edge.list.nogeo))
# bind all tree point.sf dataframes (with & without edges together)
all.trees.points.df.nogeo <-
rbind(tree.points.one.edge.df.nogeo ,
tree.points.two.edges.df.nogeo,
tree.points.no.edges.df.nogeo) %>%
mutate(across(plot_ID:tree_ID, ~ as.integer(.x))) %>%
left_join(., trees_data %>%
select(plot_ID, tree_ID, inv_year, DBH_cm),
by = c("plot_ID", "tree_ID", "inv_year"),
multiple = "all")
# bind all tree status dataframes together (one edge, two edges, no edge plots)
all.trees.status.df <-
rbind(tree.status.no.edges.df.nogeo,
tree.status.one.edge.df.nogeo,
tree.status.two.edges.df.nogeo)
# 3.3. data export ---------------------------------------------------------------------------------------------------------
# 3.3.1. data prep for export -----------------------------------------------------------------------------------------------
# 3.3.1.1. harmonzing strings for join --------------------------------------------------------
# harmonize strings of all.trees.status.df and
# https://stackoverflow.com/questions/20637360/convert-all-data-frame-character-columns-to-factors
all.trees.status.df[,c(1,2,3, 4, 5)] <- lapply(all.trees.status.df[,c(1,2, 3, 4, 5)], as.numeric)
all.edges.area.df.nogeo[,c(1,2, 3,4, 6)] <- lapply(all.edges.area.df.nogeo[,c(1,2, 3, 4, 6)], as.numeric)
# 3.3.1.2. join tree stand status and plot areas into trees dataset  --------------------------------------------------------
trees_update_1 <-trees_data%>%
# join in stand of each tree
left_join(., all.trees.status.df %>%
select(plot_ID, tree_ID, inv_year, t_stat) %>%
distinct(),
by = c("plot_ID", "tree_ID", "inv_year")) %>%
rename(stand = t_stat) %>%
# join in the area that belongs to the tree according to the CCS the tree was measured in/ belongs to
left_join(., all.edges.area.df.nogeo %>%
select(plot_ID, inter_stat, CCS_r_m, stand, area_m2),
by = c("plot_ID", "CCS_r_m", "stand")) %>%
# if there was no plot area claualted due to the fact that there is no edger at the plot,
# we calcualte the area from the sampling circuit diameter assign under CCD_r_m
mutate(area_m2 = ifelse(is.na(e_ID) & is.na(area_m2) |
# for trees alloceted to a in a cirlce without intersections wil not run throuhg the loops
# thus they do  have an edge ID but no calcualted areas or assigned intersection status
# therefore we have to calculate their area manually subsequently
# trees with the status "warning" will not have any stand and area from the dataset "all.edges.area.df.nogeo" assigned
# as this stand category doesn´t exist
# trees with the status "warning" will be excluded from the analysis
stand == "A" & inter_stat != "partly intersecting" & is.na(area_m2) |
stand == "A" & is.na(inter_stat) & is.na(area_m2), c_A(CCS_r_m), area_m2),
# this column is for stand-wise analysis and contains the plot area per tree according to the stand and the sampling circuit it is located in according to its diameter
stand_plot_A_ha = as.numeric(area_m2)/10000,# dividedd by 10 000 to transform m2 into hectar
# this column is for not stand wise analysis and contains the plot area per ptree according to the sampling circiont it is located in according to its diameter
plot_A_ha = c_A(CCS_r_m)/10000)# %>%   # dividedd by 10 000 to transform m2 into hectar
# left_join(geo_loc %>% select(plot_ID, RW_MED, HW_MED), by = "plot_ID") %>%
# mutate(east_tree =  X_tree + RW_MED,
#        north_tree = Y_tree + HW_MED)
# 3.3.1.3. sort trees into remove and process on datasets by status "warning" --------------------------------------------------------
trees_removed_1 <- trees_update_1 %>% filter(stand == "warning")
trees_update_1 <- trees_update_1 %>% filter(stand != "warning")
# 3.3.1.4.  binding datasets together ----------------------------------------------------------
all.triangle.polys.df.nogeo <- rbind(triangle.e1.poly.df.nogeo, triangle.e2.poly.df.nogeo)
all.edge.intersections.poly  <- rbind(inter.poly.one.edge.df.nogeo , inter.poly.two.edges.df.nogeo)#%>% nest("geometry" = geometry)
all.remaning.circles.poly <- rbind(rem.circle.one.edge.df.nogeo, rem.circle.two.edges.df.nogeo) #%>% nest("geometry" = geometry)
all.triangle.coords.df.nogeo <- rbind(triangle.e1.coords.df.nogeo, triangle.e2.coords.df.nogeo) %>%
# the exportet polygones only include the widest cirlce intersection at 17.84m radius
mutate(CCS_r_m = 17.84) %>%
# join in the stand info by plot_ID, e_ID, CCS_r_M
left_join(., all.edges.area.df.nogeo %>% select(plot_ID, e_ID, CCS_r_m, stand),
by = c("plot_ID", "e_ID", "CCS_r_m"))
for(i in 1:(nrow(trees_data %>% select(plot_ID) %>% distinct()))){
# https://ggplot2.tidyverse.org/reference/ggsf.html
#i = 2
# i = which(grepl(50005, unique(trees_data$plot_ID)))
my.plot.id = unique(trees_data$plot_ID)[i]
#print(my.plot.id)
c.df <- as.data.frame(cbind("lon" = 0, "lat" = 0))
c.pt <- sf::st_as_sf(c.df, coords = c("lon", "lat"))
c.poly.17 <- sf::st_buffer(c.pt, 17.84)
c.poly.12 <- sf::st_buffer(c.pt, 12.62)
c.poly.5 <- sf::st_buffer(c.pt, 5.64)
all.trees.points.df.nogeo.sp <- all.trees.points.df.nogeo %>%
filter(plot_ID == my.plot.id) %>%
left_join(trees_data %>%
filter(plot_ID == my.plot.id) %>%
select(plot_ID, tree_ID, SP_code), by = c("plot_ID", "tree_ID"))
print(ggplot() +
ggtitle(my.plot.id)+
geom_sf(data = c.poly.17, aes(alpha = 0))+
geom_sf(data = c.poly.12, aes(alpha = 0))+
geom_sf(data = c.poly.5, aes(alpha = 0))+
geom_sf(data = triangle.e1.poly.df.nogeo$geometry[triangle.e1.poly.df.nogeo$plot_ID == my.plot.id], aes(alpha = 0))+
geom_sf(data = triangle.e2.poly.df.nogeo$geometry[triangle.e2.poly.df.nogeo$plot_ID == my.plot.id], aes(alpha = 0))+
geom_sf(data = all.trees.points.df.nogeo.sp$geometry[all.trees.points.df.nogeo.sp$plot_ID == my.plot.id],
aes(color = all.trees.points.df.nogeo.sp$t_stat[all.trees.points.df.nogeo.sp$plot_ID == my.plot.id],
size =  all.trees.points.df.nogeo.sp$DBH_cm[all.trees.points.df.nogeo.sp$plot_ID == my.plot.id]))+
guides(color=guide_legend(title="tree status"))+
guides(size=guide_legend(title="DBH cm"))+
geom_sf_text(data = all.trees.points.df.nogeo.sp$geometry[all.trees.points.df.nogeo.sp$plot_ID == my.plot.id],
aes(label = all.trees.points.df.nogeo.sp$tree_ID[all.trees.points.df.nogeo.sp$plot_ID == my.plot.id]))+
xlim(-30, 30)+
ylim(-30, 30)
)
}
BWI_LT_stocks %>%
rename("BA_percent_BWI" = "BA_percent") %>%
rename("n_ha_BWi" = "n_ha") %>%
mutate(across(c("B_t_ha", "C_t_ha",  "N_t_ha"), ~ tons(x.)))
# Thuenen Institute - Bodenschutz und Waldzustand
# Analysis of the forest inventory accompanying the  national soil inventory
# cheking plausibility of the data
# ----- 0. SETUP --------------------------------------------------------------------------------------------------------------------
# ----- 0.1. packages and functions -------------------------------------------------------------------------------------------------
source(paste0(getwd(), "/scripts/00_00_functions_library.R"))
# ----- 0.2. working directory ------------------------------------------------------------------------------------------------------
here::here()
getwd()
out.path.BZE3 <- ("output/out_data/out_data_BZE/")
# 0.3 import data --------------------------------------------------------------------------------------------------------------
trees_data <- read.delim(file = here(paste0(out.path.BZE3,"HBI_LT_update_4.csv")), sep = ";", dec = ",")
trees_stat_2 <- read.delim(file = here("output/out_data/out_data_BZE/HBI_LT_stat_2.csv"), sep = ";", dec = ",") %>% select(-X)
HBI_summary <- read.delim(file = here(paste0(out.path.BZE3,"HBI_LT_stocks_ha_P_SP_TY.csv")), sep = ";", dec = ",")
BWI_LT_stocks <- read.delim(file = here("data/input/General/BWI_LT_stocks_zielmerkmale.csv"), sep = ";", dec = ",")
# create pseudo monocultures:
# carbon stock of species per hectar divided by 1 Hektar mulitplied with the actual area covered by the species according to basal area
# mutate(C_t_ha_mono = C_t_P_SP_ha/(1*(SP_BA_m2ha/tot_BA_m2ha)),
# 0.4. colnames, hamonising strings --------------------------------------------------------------------------------------------
colnames(BWI_LT_stocks) <- c("variable", "unit_BWI", "ei", "bu", "aLh", "aLn", "LB","fi", "ta", "dgl", "ki", "lae", "NB", "all")
# 1. data preparation ----------------------------------------------------------------------------------------------------------
# introduce the BWI Kohlentoffinventur species names/ groups listed in BWI_LT_stocks
SP_names_com_ID_tapeS <- SP_names_com_ID_tapeS %>%
mutate(BWI_comparisson_group = case_when(LH_NH == "LB" & bot_genus == "Quercus"~ 'ei',
LH_NH == "LB" & bot_genus == "Fagus"~ 'bu',
LH_NH == "LB" & bot_genus %in% c("Acer",
"Platanus",
"Fraxinus",
"Tilia",
"Juglans",
"Corylus",
"Robinia",
"Castanea",
"Carpinus",
"Aesculus",
"Sorbus",
"Ulmus",
"Rhamnus") | LH_NH == "LB" & bot_name == "Prunus dulcis" ~ 'aLh',
LH_NH == "LB" & !(bot_genus %in% c("Quercus",
"Fagus",
"Acer",
"Platanus",
"Fraxinus",
"Tilia",
"Juglans",
"Corylus",
"Robinia",
"Castanea",
"Carpinus",
"Aesculus",
"Sorbus",
"Ulmus",
"Rhamnus")) | LH_NH == "LB" & bot_name != "Prunus dulcis" ~ 'aLn',
LH_NH == "NB" & bot_genus %in% c("Pinus") ~ 'ki',
LH_NH == "NB" & bot_genus %in% c("Pseudotsuga") ~ 'dgl',
LH_NH == "NB" & bot_genus %in% c("Abies") ~ 'ta',
LH_NH == "NB" & bot_genus %in% c("Larix") ~ 'lae',
LH_NH == "NB" & bot_genus %in% c("Picea") |
LH_NH == "NB" & !(bot_genus %in% c("Pinus",
"Pseudotsuga", "Abies",
"Larix")) ~ 'fi',
TRUE ~ 'other'))
# 1.2. BWI LT summary data wrangling ----------------------------------------------------------------------------------------------------------
BWI_LT_stocks <- BWI_LT_stocks %>%
# pivot all species names in one column
pivot_longer(c(ei:all), names_to = "BWI_comparisson_group", values_to = "values") %>%
# filter for hectar values and percent
filter(endsWith(unit_BWI, "ha]") | endsWith(unit_BWI, "%]")) %>%
# remove unit
select(- unit_BWI) %>%
# rename variables from german to english
mutate(variable = case_when(variable == "absorbiertes Kohlendioxid [kg/ha]" ~ "CO2_kg_ha",
variable == "Anteil an der HolzbodenflÃ¤che [%]" ~ "BA_percent",
variable == "Biomasse [kg/ha]" ~ "B_kg_ha",
variable == "GrundflÃ¤che [mÂ²/ha]" ~ "BA_m2_ha",
variable == "Kohlenstoffmasse [kg/ha]" ~ "C_kg_ha",
variable == "oberirdische Biomasse [kg/ha]" ~ "ag_B_kg_ha",
variable == "oberirdische Kohlenstoffmasse [kg/ha]" ~ "ag_C_kg_ha",
variable == "Stammzahl [1/ha]" ~ "n_ha",
variable == "unterirdische Biomasse [kg/ha]" ~ "bg_B_kg_ha",
variable == "unterirdische Kohlenstoffmasse [kg/ha]" ~ "bg_C_kg_ha",
variable == "Vorrat [mÂ³/ha]" ~ "V_m3_ha",
variable == "Vorrat (FAO-Definition) [mÂ³/ha]" ~ "FAO_V_m3_ha",
variable == "WaldflÃ¤che (gemÃ¤ÃŸ StandflÃ¤chenanteil) [ha]" ~ "SP_forest_A_ha",
variable == "ZugehÃ¶rige HolzbodenflÃ¤che des Auswertungsgebietes [ha]" ~ "forest_A_ha",
TRUE ~ NA)) %>%
# pivot variables into different columns
pivot_wider(names_from = "variable", values_from = "values") %>%
##reorder columns to pivot it lateron
select(BWI_comparisson_group, BA_percent, BA_m2_ha, n_ha, B_kg_ha, ag_B_kg_ha, bg_B_kg_ha,
C_kg_ha, ag_C_kg_ha,bg_C_kg_ha)   %>%
# pivoting B, C: https://stackoverflow.com/questions/70700654/pivot-longer-with-names-pattern-and-pairs-of-columns
to_long(keys = c("B_compartiment",  "C_compartiment"),
values = c("B_kg_ha", "C_kg_ha"),
names(.)[5:7], names(.)[8:10]) %>%
# hanging the compartiments names and deselect the other compartiment columns: https://stackoverflow.com/questions/61425318/using-mutate-and-starts-with
mutate(B_compartiment = case_when(startsWith(B_compartiment, "bg") ~ "bg",
startsWith(B_compartiment, "ag") ~ "ag",
TRUE ~ "total")) %>%
select(-C_compartiment) %>%
rename(compartiment = B_compartiment) %>%
mutate(stand_component = "LT")
#,inv_year = 2017)
# 1.3. calculating HBI stocks in BWI groups ---------------------------------------------------------------------------------------------------------
# 1.3.1. introducing BWI species group --------------------------------------------------------------------------------------------------------------
# introduce BWI comparisson species groups to trees_data dataset so we can summariye all hectar values according to it
trees_data <- trees_data %>%
left_join(., SP_names_com_ID_tapeS %>%
select(Chr_code_ger, BWI_comparisson_group),
by = "Chr_code_ger")
# 1.3.2. stocks per ha per plot ----------------------------------------------------------------------------------------------------------------
if(exists('trees_stat_2') == TRUE && nrow(trees_stat_2)!= 0){
LT_BCNBAn_ha <- rbind(trees_data  %>%
group_by(plot_ID, plot_A_ha, CCS_r_m, inv_year, compartiment) %>%
# convert Biomass into tons per hectar and sum it up per sampling circuit
reframe(B_CCS_t_ha = sum(ton(B_kg_tree))/plot_A_ha, # plot are is the area of the respecitve samplign circuit in ha
C_CCS_t_ha = sum(ton(C_kg_tree))/plot_A_ha,
N_CCS_t_ha = sum(ton(N_kg_tree))/plot_A_ha,
BA_CCS_m2_ha = sum(BA_m2)/plot_A_ha,
n_trees_CCS_ha = n()/plot_A_ha) %>%
distinct(),
trees_stat_2)%>%
# now we summarise all the t/ha values of the cirlces per plot
group_by(plot_ID, inv_year, compartiment) %>%
summarise(B_t_ha = sum(B_CCS_t_ha),
C_t_ha = sum(C_CCS_t_ha),
N_t_ha = sum(N_CCS_t_ha),
BA_m2_ha = sum(BA_CCS_m2_ha),
n_ha = sum(n_trees_CCS_ha)) %>%
mutate(stand_component = "LT")}else{
LT_BCNBAn_ha <- trees_data %>%
group_by(plot_ID, CCS_r_m, inv_year, compartiment) %>%
# convert Biomass into tons per hectar and sum it up per sampling circuit
reframe(B_CCS_t_ha = sum(ton(B_kg_tree))/plot_A_ha, # plot are is the area of the respecitve samplign circuit in ha
C_CCS_t_ha = sum(ton(C_kg_tree))/plot_A_ha,
N_CCS_t_ha = sum(ton(N_kg_tree))/plot_A_ha,
BA_CCS_m2_ha = sum(BA_m2)/plot_A_ha,
n_trees_CCS_ha = n()/plot_A_ha) %>%
distinct()%>%
# now we summarise all the t/ha values of the cirlces per plot
group_by(plot_ID, inv_year, compartiment) %>%
summarise(B_t_ha = sum(B_CCS_t_ha),
C_t_ha = sum(C_CCS_t_ha),
N_t_ha = sum(N_CCS_t_ha),
BA_m2_ha = sum(BA_CCS_m2_ha),
n_ha = sum(n_trees_CCS_ha)) %>%
mutate(stand_component = "LT")
}
BWI_LT_stocks %>%
rename("BA_percent_BWI" = "BA_percent") %>%
rename("n_ha_BWi" = "n_ha") %>%
mutate(across(c("B_t_ha", "C_t_ha",  "N_t_ha"), ~ ton(x.)))
BWI_LT_stocks
BWI_LT_stocks %>%
rename("BA_percent_BWI" = "BA_percent") %>%
rename("n_ha_BWi" = "n_ha") %>%
mutate(across(c("B_kg_ha", "C_kg_ha"), ~ ton(x.)))
BWI_LT_stocks %>%
rename("BA_percent_BWI" = "BA_percent") %>%
rename("n_ha_BWi" = "n_ha") %>%
mutate(across(c("B_kg_ha", "C_kg_ha"), ~ x., ton()))
BWI_LT_stocks %>%
rename("BA_percent_BWI" = "BA_percent") %>%
rename("n_ha_BWi" = "n_ha") %>%
mutate(across(c("B_kg_ha", "C_kg_ha"), ~ x, ton(.)))
BWI_LT_stocks %>%
rename("BA_percent_BWI" = "BA_percent") %>%
rename("n_ha_BWi" = "n_ha") %>%
mutate(across(c("B_kg_ha", "C_kg_ha"), ~ ton(.x)))
BWI_LT_stocks %>%
rename("BA_percent_BWI" = "BA_percent") %>%
rename("n_ha_BWi" = "n_ha") %>%
mutate(across(c("B_kg_ha", "C_kg_ha"), ~ ton(.x))) %>%
rename_with(., paste0(str_sub(c("B_kg_ha", "C_kg_ha"), end=-6), "_t_ha_BWI"), c("B_kg_ha", "C_kg_ha"))
BWI_LT_stocks %>%
rename("BA_percent_BWI" = "BA_percent") %>%
rename("n_ha_BWi" = "n_ha") %>%
mutate(across(c("B_kg_ha", "C_kg_ha"), ~ ton(.x))) %>%
rename_with(., paste0(str_sub(c("B_kg_ha", "C_kg_ha"), end=-6), "_t_ha_BWI"), .cols("B_kg_ha", "C_kg_ha"))
BWI_LT_stocks %>%
rename("BA_percent_BWI" = "BA_percent") %>%
rename("n_ha_BWi" = "n_ha") %>%
mutate(across(c("B_kg_ha", "C_kg_ha"), ~ ton(.x))) %>%
rename_with(., ~ paste0(str_sub(c("B_kg_ha", "C_kg_ha"), end=-6), "_t_ha_BWI"), c("B_kg_ha", "C_kg_ha"))
BWI_LT_stocks %>%
rename("BA_percent_BWI" = "BA_percent") %>%
rename("n_ha_BWi" = "n_ha") %>%
mutate(across(c("B_kg_ha", "C_kg_ha"), ~ ton(.x))) %>%
rename_with(., ~ paste0(str_sub(c("B_kg_ha", "C_kg_ha"), end=-6), "t_ha_BWI"), c("B_kg_ha", "C_kg_ha"))

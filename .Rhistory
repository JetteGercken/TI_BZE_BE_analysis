DW_data <-  read.delim(file =  here(paste0(out.path.BZE3,"HBI_DW_update_1.csv")), sep = ";", dec = ",")
# HBI forest type info per plot  (Bestandestyp)
# this i deed to later say "if the stocking species are mainly coniferous i need this secies group from tapeS
# and if th estocking species fall in the category broadleafes the other tapes species code"
forest_info <- read.delim(file = here("data/input/BZE2_HBI/be.csv"), sep = ",", dec = ",", stringsAsFactors=FALSE)
# 0.4 dataprep  -----------------------------------------------------------
# 0.4.2. species names -------------------------------------------------------------
# 1 Nadelholz
# 2 Laubholz (außer Eiche)
# 3 Eiche
# 4 unbekannt
DW_data <- DW_data %>%
# join in forest type from HBI forst.csv
left_join(.,
forest_info %>%
# assign forest types into coniferus vs broadleaved categories based on x_forest code table
mutate(LH_NH_stand = case_when(besttyp %in% c(4, 5, 7, 8, 10, 91 ) ~ "LB",
besttyp %in% c(92, 1, 2, 3, 6, 9 ) ~ "NB",
TRUE ~ NA)) %>%
select(bund_nr, LH_NH_stand),
by = c("plot_ID" = "bund_nr")) %>%
mutate(SP_code =  case_when(dw_sp == 1 | (dw_sp == 4 & LH_NH_stand == "NB") ~ "gfi",  # Fi
dw_sp == 2 | (dw_sp == 4 & LH_NH_stand == "LB") ~ "rbu", # BU
dw_sp == 3 ~ "sei",                                   # EI
TRUE ~ NA) ) %>%
left_join(., SP_names_com_ID_tapeS %>%
mutate(char_code_ger_lowcase = tolower(Chr_code_ger)),
by = c("SP_code" = "char_code_ger_lowcase")) %>%
# transforming Biosoil decay types into BWI decay types by joining Biosoil decay type 1 & 2
mutate(dec_type_BWI = case_when(decay == 1 | decay == 2 ~ 1,
decay == 3 ~ 2,
decay == 4 ~ 3,
TRUE ~ 4),
# assigning deadwood types into groups of standing / lying deadwood (S/L)
ST_LY_type = case_when(decay %in% c(2, 3, 4) ~ "S",
TRUE ~ "L"))
# 1. calculations ---------------------------------------------------------------
# 1 liegend; starkes Totholz; umfasst Stamm, Äste, Zweige,  abgebrochene Kronen, D ≥ 10 cm am dickeren Ende
# 2 stehend, ganzer Baum; stehendes Totholz mit Ästen BHD ≥ 10 cm
# 3 stehend, Bruchstück; Baumstumpf ohne Äste BHD ≥ 10 cm, Höhe ≥ 13 dm
# 4 Wurzelstock Ø Schnittflächendurchmesser ≥ 10 cm, Höhe < 13 dm
# 5 liegend; ganzer Baum BHD ≥ 10 cm
# 6 in Haufen vorkommendes Totholz D ≥ 10 cm am dickeren Ende
# 1.3 biomass -------------------------------------------------------------------------------
# 1.3.1 biomass whole deadwood trees (ganzer Baum stehend 2/ liegend 5) ------------------------------------------------------------------------
# for whole standing or laying deadwood trees all compartiments except foliage ("ndl" ) are calculated via TapeS
DW_data_whole <- DW_data[DW_data$dw_type %in% c(2, 5) & DW_data$decay  %in% c(1,2), ]
# export list for biomasse
bio.dw.whole.kg.list <- vector("list", length = nrow(  DW_data_whole))
# export list for volume
for (i in 1:nrow( DW_data_whole)){
# i = 1
# select general info about the DW item
my.plot.id <-  DW_data_whole[,"plot_ID"][i]
my.tree.id <-  DW_data_whole[,"tree_ID"][i]
my.decay.type <-  DW_data_whole[,"dec_type_BWI"][i]
my.dw.spec <-  DW_data_whole[,"dw_sp"][i]
my.CF.BL <-  DW_data_whole[,"LH_NH_stand"][i]
# select variables fot TprTrees object
# translating Species groups into TapeS codes
spp =  na.omit(as.numeric(unique( DW_data_whole$tpS_ID[DW_data_whole$plot_ID==my.plot.id & DW_data_whole$tree_ID==my.tree.id])))
Dm = na.omit(as.list(as.numeric(unique(DW_data_whole$d_cm[ DW_data_whole$plot_ID==my.plot.id & DW_data_whole$tree_ID==my.tree.id])))) # diameter in cm
Hm = as.list(as.numeric(1.3))
Ht = na.omit(as.numeric(unique(DW_data_whole$l_dm[DW_data_whole$plot_ID==my.plot.id & DW_data_whole$tree_ID==my.tree.id]))/10) # lenth in meter m
# create tapes compartiments
comp <- as.character(c("stw","stb","sw", "sb", "fwb"))
# create object
obj.dw <- tprTrees(spp, Dm, Hm, Ht, inv = 4)
# calculate biomass
bio.df <- as.data.frame(tprBiomass(obj = obj.dw[obj.dw@monotone == TRUE], component = comp)) %>%
pivot_longer(cols = stw:fwb,
names_to = "compartiment",
values_to = "B_kg_tree") %>%
# apply the biomass reduction factor to the biomass of deadwoodto account for decay state
mutate(B_kg_tree = rdB_DW(B_kg_tree, my.decay.type, my.dw.spec))
# create export dataframe
bio.info.df <- as.data.frame(cbind(
"plot_ID" = c(as.integer( DW_data_whole$plot_ID[DW_data_whole$plot_ID == my.plot.id &  DW_data_whole$tree_ID == my.tree.id])),
"tree_ID" = c(as.integer( DW_data_whole$tree_ID[DW_data_whole$plot_ID == my.plot.id &  DW_data_whole$tree_ID == my.tree.id])),
"inv" = c( DW_data_whole$inv[ DW_data_whole$plot_ID == my.plot.id &  DW_data_whole$tree_ID == my.tree.id]),
"inv_year" = c(as.integer( DW_data_whole$inv_year[DW_data_whole$plot_ID == my.plot.id &  DW_data_whole$tree_ID == my.tree.id])),
"compartiment" = c(bio.df$compartiment),
"B_kg_tree" = c(as.numeric(bio.df$B_kg_tree))
))
bio.dw.whole.kg.list[[i]] <- bio.info.df
}
bio_dw_whole_kg_df <- as.data.frame(rbindlist(bio.dw.whole.kg.list))
# sum up deadwood ag compartiments
bio_dw_whole_ag_kg_df <- bio_dw_whole_kg_df %>%
select(-compartiment) %>%
mutate(compartiment = "ag") %>%
group_by(plot_ID, tree_ID, inv, inv_year, compartiment) %>%
summarise(B_kg_tree = sum(as.numeric(B_kg_tree)))
# 1.3.2. biomass broken deadwood trees (bruchstücke, 3) ------------------------------------------------------------------------
# for broken deadwood trees above 1.3 m all compartiments except foliage ("ndl" ) are calculated via TapeS
# export list for biomasse
DW_data_broken <- DW_data[DW_data$dw_type == 3  & DW_data$decay  %in% c(1,2), ]
bio.dw.broken.kg.list <- vector("list", length = nrow(DW_data_broken))
for (i in 1:nrow(DW_data_broken)){
# i = 1
# select general info about the DW item
my.plot.id <- DW_data_broken[,"plot_ID"][i]
my.tree.id <- DW_data_broken[,"tree_ID"][i]
my.decay.type <- DW_data_broken[,"dec_type_BWI"][i]
my.dw.spec <- DW_data_broken[,"dw_sp"][i]
# select variables fot TprTrees object
spp =  na.omit(as.numeric(unique(DW_data_broken$tpS_ID[DW_data_broken$plot_ID==my.plot.id & DW_data_broken$tree_ID==my.tree.id])))
Dm = na.omit(as.list(as.numeric(unique(DW_data_broken$d_cm[DW_data_broken$plot_ID==my.plot.id & DW_data_broken$tree_ID==my.tree.id])))) # diameter in cm
Hm = as.list(as.numeric(1.3))
Ht = na.omit(as.numeric(unique(DW_data_broken$l_dm[DW_data_broken$plot_ID==my.plot.id & DW_data_broken$tree_ID==my.tree.id]))/10) # lenth in meter m
# create object
obj.dw <- tprTrees(spp, Dm, Hm, Ht, inv = 4)
# create the deimitation of the stem section we want TapeS to caluculate the volume for
A <- 0 # lower limit
B <- Ht # upper limit = lenght
# calcualte volume for stem segment 0 to length
bio.df <- as.data.frame(cbind(
"vol_m3" = c((tprVolume(obj.dw[obj.dw@monotone == TRUE], bark = TRUE, AB = list(A = A, B = B), iAB = "H") - tprVolume(obj.dw[obj.dw@monotone == TRUE], bark = FALSE, AB = list(A = A, B = B), iAB = "H")),
(tprVolume(obj.dw[obj.dw@monotone == TRUE], bark = FALSE, AB = list(A = A, B = B), iAB = "H")),
(tprVolume(obj.dw[obj.dw@monotone == TRUE], bark = TRUE, AB = list(A = A, B = B), iAB = "H"))),
"compartiment" = c("sb", "sw", "ag"))) %>%
# calculate biomass
mutate(B_kg_tree = B_DW(as.numeric(vol_m3), my.decay.type, my.dw.spec))
bio.info.df <- as.data.frame(cbind(
"plot_ID" = c(my.plot.id),
"tree_ID" = c(my.tree.id),
"inv" = c(DW_data_broken$inv[DW_data_broken$plot_ID == my.plot.id & DW_data_broken$tree_ID == my.tree.id]),
"inv_year" = c(as.integer(DW_data_broken$inv_year[DW_data_broken$plot_ID == my.plot.id & DW_data_broken$tree_ID == my.tree.id])),
"compartiment" = c(bio.df$compartiment),
"B_kg_tree" = c(as.numeric(bio.df$B_kg_tree))
) )
bio.dw.broken.kg.list[[i]] <- bio.info.df
}
bio_dw_broken_kg_df <- as.data.frame(rbindlist(bio.dw.broken.kg.list))
# 1.3.3. biomass for stumps -----------------------------------------------
DW_data_stump <- DW_data[DW_data$dw_type == 4 & DW_data$decay  %in% c(1,2),]
bio.dw.stump.kg.list <- vector("list", length = nrow(DW_data_stump))
for (i in 1:nrow(DW_data_stump)){
# i = 3
# select general info about the DW item
my.plot.id <- DW_data_stump[,"plot_ID"][i]
my.tree.id <- DW_data_stump[,"tree_ID"][i]
my.decay.type <- DW_data_stump[,"dec_type_BWI"][i]
my.dw.spec <- DW_data_stump[,"dw_sp"][i]
# select variables fot TprTrees object
spp =  na.omit(as.numeric(unique(DW_data_stump$tpS_ID[DW_data_stump$plot_ID==my.plot.id & DW_data_stump$tree_ID==my.tree.id])))
# calculate the DBH: diameter a tree with the measured stump diameter would have at 1.3m height
bwi.spp = na.omit((unique(DW_data_stump$BWI[DW_data_stump$plot_ID==my.plot.id & DW_data_stump$tree_ID==my.tree.id])))
d.cm = as.numeric(unique(DW_data_stump$d_cm[DW_data_stump$plot_ID==my.plot.id & DW_data_stump$tree_ID==my.tree.id])) # diameter in cm
l.m = as.numeric(unique(DW_data_stump$l_dm[DW_data_stump$plot_ID==my.plot.id & DW_data_stump$tree_ID==my.tree.id]))/10
Dm = as.list(DBH_Dahm(my.plot.id, as.numeric(d.cm)*10, l.m, bwi.spp))
# estimate height a tree with the estimated DBH diameter would have
Hm = as.list(as.numeric(1.3))
Ht = (as.numeric(estHeight(d13 = as.numeric(Dm), sp = spp))) # lenth in meter m
# compartiments
comp <- c("stw", "stb")
# create object with estimated DBH and height
obj.dw <- tprTrees(spp, Dm, Hm, Ht, inv = 4)
## calcualte biomass and bark-stump ratio for the "pseudo" tree
# deal with error for small trees: # https://stackoverflow.com/questions/2158780/catching-an-error-and-then-branching-logic
t <- try(tprBiomass(obj = obj.dw[obj.dw@monotone == T], component = comp))
if("try-error" %in% class(t)){
ratio.df <- as.data.frame(
tprBiomass(obj = obj.dw[obj.dw@monotone == F], component = comp)
) %>% # momo = F if heigh low, mono = T if height normal
mutate(ag = stw + stb) %>%
#apply the biomass reduction factor to the biomass of deadwoodto account for decay state
mutate(across(stw:ag, ~rdB_DW( .x, my.decay.type, my.dw.spec) )) %>%
# calcualte bark:total stump biomass
mutate(bark_ag_ratio = stb/ag,
wood_ag_ratio = stw/ag)
}else{
ratio.df <- as.data.frame(
tprBiomass(obj = obj.dw[obj.dw@monotone == T], component = comp)
) %>% # momo = F if heigh low, mono = T if height normal
mutate(ag = stw + stb) %>%
#apply the biomass reduction factor to the biomass of deadwoodto account for decay state
mutate(across(stw:ag, ~rdB_DW( .x, my.decay.type, my.dw.spec) )) %>%
# calcualte bark:total stump biomass
mutate(bark_ag_ratio = stb/ag,
wood_ag_ratio = stw/ag)
}
# calcualte Biomass vie Volume cylinder function and wood density
ag.B.kg = as.data.frame(B_DW(V_DW_cylinder(as.numeric(d.cm)/100, as.numeric(l.m)), my.decay.type, my.dw.spec))[,1]
# claculate komaprtimetn biomass with ratios and ag
bio.df <- as.data.frame(cbind(
"compartiment" = c("ag", "stw", "stb"),
"B_kg_tree" = c(ag.B.kg, # ag biomass
ag.B.kg*as.numeric(ratio.df$wood_ag_ratio), # stump wood biomass
ag.B.kg*as.numeric(ratio.df$bark_ag_ratio)) # stump bark biomass
))
bio.info.df <- as.data.frame(cbind(
"plot_ID" = c(my.plot.id),
"tree_ID" = c(my.tree.id),
"inv" = c(DW_data_stump$inv[DW_data_stump$plot_ID == my.plot.id & DW_data_stump$tree_ID == my.tree.id]),
"inv_year" = c(as.integer(DW_data_stump$inv_year[DW_data_stump$plot_ID == my.plot.id & DW_data_stump$tree_ID == my.tree.id])),
"compartiment" = c(bio.df$compartiment),
"B_kg_tree" = c(as.numeric(bio.df$B_kg_tree))
) )
bio.dw.stump.kg.list[[i]] <- bio.info.df
}
bio_dw_stump_kg_df <- as.data.frame(rbindlist(bio.dw.stump.kg.list))
# 1.3.4. biomass for deadwood pieces --------------------------------------------------------
bio_dw_pieces_kg_df <- DW_data %>%
filter(dw_type %in% c(1, 6) |
dw_type %in% c(2, 5, 3, 4) & decay > 2) %>%
mutate(
compartiment =  "ag",
V_m3_tree = V_DW_cylinder(as.numeric(d_cm)/100, as.numeric(l_dm/10)),
B_kg_tree = B_DW(V_m3_tree, dec_type_BWI, dw_sp)) %>%
select("plot_ID", "tree_ID", "inv", "inv_year", "compartiment", "B_kg_tree")
# 1.3.4. add biomass to DW dataframe -----------------------------
# harmonise strings
all_dw_bio_df <- rbind(
bio_dw_whole_kg_df,
bio_dw_whole_ag_kg_df,
bio_dw_broken_kg_df,
bio_dw_stump_kg_df,
bio_dw_pieces_kg_df)
all_dw_bio_df[,c(1,2, 4, 6)] <- lapply(all_dw_bio_df[,c(1,2,4, 6)], as.numeric)
# join biomass in deadwood
DW_data <- DW_data %>%
left_join(., all_dw_bio_df,
by = c("plot_ID", "tree_ID", "inv", "inv_year"),
multiple = "all")
# 1.4. Nitrogen stock -----------------------------------------------------
# for the sums we shoud ldecide iwf we want to give them the compartiment "ag"
# because that´s what they actually are
# or the compartiment "total" because that way it will be easier to link the total available
# deadwood biomass, nitrogen and carbon stock with the total stocks of trees and RG
# 1.4.1. Nitrogen stock in compartiments -----------------------------------------
N_dw_ag_comps_kg_df <- DW_data %>%
# compartitioned deadwood trees
filter(dw_type %in% c(2, 5, 3, 4) & decay <=2 & compartiment != "ag" | # deselect summed up compartiments for whole trees, stumps and broken trees
# deadwood trees that could have been compartitioned if htey would´t be to decayed
# --> biomass is always "ag"
dw_type %in% c(2, 5, 3, 4) & decay > 2|
# uncompartionable deadwood trees --> biomass is always "ag"
dw_type %in% c(1, 6)) %>%
mutate(N_kg_tree = case_when(dw_type %in% c(2, 5, 3, 4) & compartiment != "ag" ~ N_all_com(B_kg_tree, N_SP_group, N_f_SP_group_MoMoK, N_bg_SP_group, compartiment),
# for all trees that are not copmartioned (meaning all trees that don´t have )
dw_type %in% c(1, 6) & compartiment == "ag" | dw_type %in% c(2, 5, 3, 4) & decay > 2 & compartiment =="ag" ~ N_all_com(B_kg_tree, N_SP_group, N_f_SP_group_MoMoK, N_bg_SP_group,"sb"),
TRUE ~ NA)) %>%
select(plot_ID, tree_ID, inv, inv_year, dw_type, compartiment, N_kg_tree)
# 1.4.2. total nitrogen stocks: sum up Nitrogen stock in compartiments -----------------------------------------
# summ up the aboveground compartiments
N_dw_ag_kg_df <- N_dw_ag_comps_kg_df %>%
# select only compartitionated trees
filter(dw_type %in% c(2, 5, 3, 4) & compartiment != "ag" )%>%
group_by(plot_ID, tree_ID, inv, inv_year, dw_type) %>%
summarize(N_kg_tree = sum(as.numeric(N_kg_tree))) %>%
mutate(compartiment = "ag") %>%
select("plot_ID", "tree_ID", "inv",
"inv_year", "dw_type", "compartiment", "N_kg_tree")
# 1.4.3. join Nitrogen stocks into deadwood dataset -----------------------------------
DW_data <- DW_data %>% left_join(.,
rbind(N_dw_ag_comps_kg_df ,
N_dw_ag_kg_df),
by = c("plot_ID", "tree_ID", "inv", "inv_year",
"dw_type", "compartiment"),
multiple = "all")
# 1.5 carbon stock per tree & compartiment -------------------------------------------------------
DW_data <- DW_data %>% mutate(C_kg_tree = carbon(B_kg_tree))
# 2. data export ----------------------------------------------------------
# create export dataset
DW_data_update_4 <- DW_data
write.csv2(DW_data_update_4, paste0(out.path.BZE3, paste(unique(DW_data_update_4$inv)[1], "DW_update_4", sep = "_"), ".csv"))
DW_data_update_4 %>% filter(is.na(B_kg_tree))
source(paste0(getwd(), "/scripts/01_00_functions_library.R"))
# ----- 0.2. working directory -------------------------------------------------
here::here()
getwd()
out.path.BZE3 <- ("output/out_data/out_data_BZE/")
# ----- 0.3 data import --------------------------------------------------------
# livgn trees
# this dataset contains the data of the tree inventory of the HBI (BZE2), including stand and area info,  species groups and B, C, N stocks per tree
trees_data <- read.delim(file = here(paste0(out.path.BZE3, "HBI_LT_update_4.csv")), sep = ";", dec = ",")
trees_stat_2 <- read.delim(file = here(paste0(out.path.BZE3, trees_data$inv[1], "_LT_stat_2.csv")), sep = ";", dec = ",") %>% select(-X)
# regeneration
# this dataset contains the plant specific inventory data of the regenertaion inventory of the HBI (BZE2), including stand and area info,  species groups and B, C, N stocks per tree
RG_data <- read.delim(file = here(paste0(out.path.BZE3, trees_data$inv[1], "_RG_update_4.csv")), sep = ";", dec = ",")
RG_stat_2 <- read.delim(file = here(paste0(out.path.BZE3, trees_data$inv[1], "_RG_stat_2.csv")), sep = ";", dec = ",")
# deadwood
# this dataset contains the data of the deadwood inventory of the HBI (BZE2), including info about species groups and B, C, N stocks per tree
DW_data <- read.delim(file = here(paste0(out.path.BZE3, trees_data$inv[1], "_DW_update_4.csv")), sep = ";", dec = ",")
DW_stat_2 <- read.delim(file = here(paste0(out.path.BZE3, trees_data$inv[1], "_DW_stat_2.csv")), sep = ";", dec = ",")
# ----- 0.1. packages and functions --------------------------------------------
source(paste0(getwd(), "/scripts/01_00_functions_library.R"))
# ----- 0.2. working directory -------------------------------------------------
here::here()
getwd()
out.path.BZE3 <- ("output/out_data/out_data_BZE/")
# ----- 0.3 data import --------------------------------------------------------
# livgn trees
# this dataset contains the data of the tree inventory of the HBI (BZE2), including stand and area info,  species groups and B, C, N stocks per tree
trees_data <- read.delim(file = here(paste0(out.path.BZE3, "HBI_LT_update_4.csv")), sep = ";", dec = ",")
trees_stat_2 <- read.delim(file = here(paste0(out.path.BZE3, trees_data$inv[1], "_LT_stat_2.csv")), sep = ";", dec = ",") %>% select(-X)
# regeneration
# this dataset contains the plant specific inventory data of the regenertaion inventory of the HBI (BZE2), including stand and area info,  species groups and B, C, N stocks per tree
RG_data <- read.delim(file = here(paste0(out.path.BZE3, trees_data$inv[1], "_RG_update_4.csv")), sep = ";", dec = ",")
RG_stat_2 <- read.delim(file = here(paste0(out.path.BZE3, trees_data$inv[1], "_RG_stat_2.csv")), sep = ";", dec = ",")
# deadwood
# this dataset contains the data of the deadwood inventory of the HBI (BZE2), including info about species groups and B, C, N stocks per tree
DW_data <- read.delim(file = here(paste0(out.path.BZE3, trees_data$inv[1], "_DW_update_4.csv")), sep = ";", dec = ",")
DW_stat_2 <- read.delim(file = here(paste0(out.path.BZE3, trees_data$inv[1], "_DW_stat_2.csv")), sep = ";", dec = ",")
# 3. DEADWOOD -------------------------------------------------------------
# 3.1. DW summary per plot per SP per DW type per Dec state ---------------------------------------------------------
# create one very fine grouped summary for deadwood which we sum up into different groups later on
if(exists('DW_stat_2') == TRUE && nrow(DW_stat_2)!=0){
DW_BCN_ha_SP_TY_DEC_P <- plyr::rbind.fill(DW_data %>%
group_by(plot_ID, inv_year, dw_sp, dw_type, decay, compartiment) %>%
# convert Biomass into tons per hectar and divide it by the plot area to calculate stock per hectar
reframe(B_t_ha = sum(ton(B_kg_tree))/plot_A_ha, # plot are is the area of the respecitive sampling circuit in ha
C_t_ha = sum(ton(C_kg_tree))/plot_A_ha,
N_t_ha = sum(ton(N_kg_tree))/plot_A_ha) %>%
distinct(),
DW_stat_2 %>% select(-c(X, plot_A_ha))) %>%
mutate(stand_component = "DW")}else{
DW_BCN_ha_SP_TY_DEC_P <- DW_data %>%
group_by(plot_ID, inv_year, dw_sp, dw_type, decay, compartiment, plot_A_ha) %>%
# convert Biomass into tons per hectar and divide it by the plot area to calculate stock per hectar
reframe(B_t_ha = sum(ton(B_kg_tree))/plot_A_ha, # plot are is the area of the respecitive sampling circuit in ha
C_t_ha = sum(ton(C_kg_tree))/plot_A_ha,
N_t_ha = sum(ton(N_kg_tree))/plot_A_ha) %>%
distinct()
}
DW_BCN_ha_SP_TY_DEC_P %>% filter(is.na(B_t_ha))
# 3.4.1. grouped by species, decay type, deadwoodtype, plot, compartiment, inventory ------------------------------------------------------------------
DW_summary <-
plyr::rbind.fill(
DW_BCN_ha_SP_TY_DEC_P,
# 3.4.2. grouped by species, deadwoodtype, plot, compartiment, inventory. not by decay type anymore------------------------------------------------------------------
summarize_data(DW_BCN_ha_SP_TY_DEC_P,
c("plot_ID", "inv_year", "dw_sp", "dw_type", "compartiment"),
c("B_t_ha", "C_t_ha", "N_t_ha"),
operation = "sum_df") %>%
mutate(decay = "all"),
# 3.4.3. DW grouped by species, decay, plot, compartiment, inventory, not by deadwood type anymore --------------------------------------------------------------
summarize_data(DW_BCN_ha_SP_TY_DEC_P,
c("plot_ID", "inv_year", "dw_sp", "decay", "compartiment"),
c("B_t_ha", "C_t_ha", "N_t_ha"),
operation = "sum_df") %>%
mutate(dw_type = "all") ,
# 3.4.4. DW grouped by deadwoodtype, decay, plot, compartiment, inventory, not by species type anymore ---------------------------------------------------------------
summarize_data(DW_BCN_ha_SP_TY_DEC_P,
c("plot_ID", "inv_year", "dw_type", "decay", "compartiment"),
c("B_t_ha", "C_t_ha", "N_t_ha"),
operation = "sum_df") %>%
mutate(dw_sp = "all"),
# 3.4.5. DW grouped by deadwoodtype, plot, compartiment, inventory, not by species and decay type anymore ---------------------------------------------------------------
summarize_data(DW_BCN_ha_SP_TY_DEC_P,
c("plot_ID", "inv_year", "dw_type", "compartiment"),
c("B_t_ha", "C_t_ha", "N_t_ha"),
operation = "sum_df") %>%
left_join(., DW_data %>%
filter(compartiment == "ag") %>%
distinct() %>%
group_by(plot_ID, inv_year, ST_LY_type, dw_type) %>%
summarise(mean_d_cm = mean(d_cm),
sd_d_cm = sd(d_cm),
mean_l_m = mean(l_dm/10),
sd_l_m = sd(l_dm/10)),
by = c("plot_ID", "inv_year", "dw_type"),
multiple = "all") %>%
mutate(dw_sp = "all",
decay = "all"),
# 3.4.6. DW grouped by decay, plot, compartiment, inventory, not by species and deadwood type anymore ---------------------------------------------------------------
summarize_data(DW_BCN_ha_SP_TY_DEC_P,
c("plot_ID", "inv_year", "decay", "compartiment"),
c("B_t_ha", "C_t_ha", "N_t_ha"),
operation = "sum_df") %>%
left_join(., DW_data %>%
filter(compartiment == "ag") %>%
distinct() %>%
group_by(plot_ID, inv_year, decay) %>%
summarise(mean_d_cm = mean(d_cm),
sd_d_cm = sd(d_cm),
mean_l_m = mean(l_dm/10),
sd_l_m = sd(l_dm/10)),
by = c("plot_ID", "inv_year", "decay"),
multiple = "all") %>%
mutate(dw_sp = "all",
dw_type = "all") ,
# 3.4.7. DW grouped by species group, plot, compartiment, inventory, not by decay and deadwood type anymore ---------------------------------------------------------------
summarize_data(DW_BCN_ha_SP_TY_DEC_P,
c("plot_ID", "inv_year", "dw_sp", "compartiment"),
c("B_t_ha", "C_t_ha", "N_t_ha"),
operation = "sum_df") %>%
# mean and sd of length and diameter of deadwood
left_join(., DW_data %>%
filter(compartiment == "ag") %>%
distinct() %>%
group_by(plot_ID, inv_year, dw_sp) %>%
summarise(mean_d_cm = mean(d_cm),
sd_d_cm = sd(d_cm),
mean_l_m = mean(l_dm/10),
sd_l_m = sd(l_dm/10)),
by = c("plot_ID", "inv_year", "dw_sp"),
multiple = "all") %>%
mutate(decay = "all",
dw_type = "all") ,
# 3.4.8.DW grouped by species group, plot, compartiment, inventory, not by decay, species and deadwood type anymore ----------------------------------------------------------------
summarize_data(DW_BCN_ha_SP_TY_DEC_P,
c("plot_ID", "inv_year", "compartiment"),
c("B_t_ha", "C_t_ha", "N_t_ha"),
operation = "sum_df") %>%
distinct() %>%
# number of DW items per ha
left_join(., DW_data %>%
filter(compartiment == "ag") %>%
group_by(plot_ID, inv_year) %>%
reframe(n_ha = n()/plot_A_ha) %>%
distinct(),
multiple = "all",
by = c("plot_ID", "inv_year")) %>%
# number of decay types per plot
left_join(DW_data %>%
filter(compartiment == "ag") %>%
select(plot_ID, inv_year, decay) %>%
distinct() %>%
group_by(plot_ID, inv_year) %>%
summarise(n_dec = n()),
multiple = "all",
by = c("plot_ID", "inv_year")) %>%
# number of deadwood types per plot
left_join(DW_data %>%
filter(compartiment == "ag") %>%
select(plot_ID, inv_year, dw_type) %>%
distinct() %>%
group_by(plot_ID, inv_year) %>%
summarise(n_dw_TY = n()),
multiple = "all",
by = c("plot_ID", "inv_year")) %>%
mutate(decay = "all",
dw_type = "all",
dw_sp = "all")%>% filter(is.na(B_t_ha))
) %>%  # close rbind
# add stand component for those datasets where it´s not included yet
mutate(stand_component = "DW") %>%
distinct() %>%
arrange(plot_ID)
DW_summary
DW_summary %>% filter(is.na(B_t_ha))
con <-dbConnect(RPostgres::Postgres())
# 0.SETUP --------------------------------------------------------------------------------------------------------------------
# 0.1. packages and functions -------------------------------------------------------------------------------------------------
source(paste0(getwd(), "/scripts/01_00_functions_library.R"))
con <-dbConnect(RPostgres::Postgres())
#  1.2. PostgreSQL credentials --------------------------------------------------
# name of database
db <- 'bze3_altdaten'  #provide the name of your db
# host of database: thuenen server --> VPN proably need to be activated
host_db <- '134.110.100.88'   # i.e. 'ec2-54-83-201-96.compute-1.amazonaws.com'
# database port or any other port specified by the DBA
db_port <- '5432'  # this info you can find in the PGadmin properties of the server
# database username
db_user <- 'hgercken'  # 'henriette.gercken@thuenen.de'
# database password
db_password <-  'Ao1ieDahthaheoPh' # 'Jette$Thuenen_2024' #
# estabish connection
con <- dbConnect(RPostgres::Postgres(), dbname = db, host=host_db, port=db_port, user=db_user, password=db_password)
# database password
db_password <-  'Jette$Thuenen_2024' #'Ao1ieDahthaheoPh' #
# estabish connection
con <- dbConnect(RPostgres::Postgres(), dbname = db, host=host_db, port=db_port, user=db_user, password=db_password)
# estabish connection
con <- dbConnect(RPostgres::Postgres(), dbname = db, host=host_db, port=db_port, user=db_user, password=db_password)
# database password
db_password <-  'Ao1ieDahthaheoPh' # 'Jette$Thuenen_2024' #
# estabish connection
con <- dbConnect(RPostgres::Postgres(), dbname = db, host=host_db, port=db_port, user=db_user, password=db_password)
# 2. data -----------------------------------------------------------------
# now we call for the tables in the database that we need
# as we ahve nested tables/ databases we have to add the server, database, sheme and table
#  https://stackoverflow.com/questions/58289494/how-do-i-access-nested-sql-tables-in-r
dbListTables(con)
# 2. data -----------------------------------------------------------------
# now we call for the tables in the database that we need
# as we ahve nested tables/ databases we have to add the server, database, sheme and table
#  https://stackoverflow.com/questions/58289494/how-do-i-access-nested-sql-tables-in-r
dbListTables(con,  bze3_altdaten.data.beab )
# 2. data -----------------------------------------------------------------
# now we call for the tables in the database that we need
# as we ahve nested tables/ databases we have to add the server, database, sheme and table
#  https://stackoverflow.com/questions/58289494/how-do-i-access-nested-sql-tables-in-r
dbListTables(con,  bze3_altdaten.data )
# 2. data -----------------------------------------------------------------
# now we call for the tables in the database that we need
# as we ahve nested tables/ databases we have to add the server, database, sheme and table
#  https://stackoverflow.com/questions/58289494/how-do-i-access-nested-sql-tables-in-r
dbListTables(con,  "bze3_altdaten.data" )
res <- dbSendQuery(con, "SELECT * FROM bze3_altdaten.data.beab")
dbSendQuery(con, "GRANT ALL PRIVILEGES ON DATABASE bze3_altdaten IN SCHEMA data TO hgercken;")
dbSendQuery(con, "GRANT ALL PRIVILEGES ON ALL TABLES in SCHEMA data TO hgercken;")
res <- dbSendQuery(con, "SELECT * FROM bze3_altdaten.data.beab")
res <- dbSendQuery(con, "SELECT * FROM data.beab")
res <- dbSendQuery(con, "SELECT * FROM data.beab;")
res
dbFetch(res)
# https://stackoverflow.com/questions/15520361/permission-denied-for-relation-in-postgresql
dbSendQuery(con, "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA data TO hgercken;")
# https://stackoverflow.com/questions/15520361/permission-denied-for-relation-in-postgresql
dbSendQuery(con, "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO hgercken;")
# https://stackoverflow.com/questions/15520361/permission-denied-for-relation-in-postgresql
dbSendQuery(con, "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA Data TO hgercken;")
# https://stackoverflow.com/questions/15520361/permission-denied-for-relation-in-postgresql
dbSendQuery(con, "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA data TO hgercken;")
res <- dbSendQuery(con, "SELECT * FROM data.beab;")
dbGetQuery(con, "SELECT * FROM data.beab;")
# https://stackoverflow.com/questions/15520361/permission-denied-for-relation-in-postgresql
dbGetQuery(con, "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA data TO hgercken;")
DBI::dbGetQuery(con, "SELECT * FROM data.beab;")

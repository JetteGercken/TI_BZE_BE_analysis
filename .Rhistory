tree.status.two.edges.list.nogeo[[i]] <- as.data.frame(cbind(
"plot_ID" = c(as.integer(my.plot.id)),
"tree_ID" = c(as.integer(my.tree.id)),
"inv_year" = c(my.inv.year),
"lon" = c(as.numeric(tree.coord.df$lon)),
"lat" = c(as.numeric(tree.coord.df$lat)),
"t_stat" = c(tree_status)))
tree.points.two.edges.list.nogeo[[i]] <- c("t_stat" = tree_status, tree.sf)
}
# save tree corodiantes and status into dataframe
tree.status.two.edges.df.nogeo <- as.data.frame(rbindlist(tree.status.two.edges.list.nogeo))
# save tree sf into dataframe
tree.points.two.edges.df.nogeo <- as.data.frame( rbindlist(tree.points.two.edges.list.nogeo))
# 3.2.2.3. binding datasets together --------------------------------------
# bind the tree point datafarmes of one and two edges plots together
two.and.one.edge.trees.points.df.nogeo <- rbind(tree.points.one.edge.df.nogeo,tree.points.two.edges.df.nogeo)
# this step i separated in case both of the rbinded dfs are empty and the mutate wouldn´t grip
two.and.one.edge.trees.points.df.nogeo <- two.and.one.edge.trees.points.df.nogeo %>% mutate(plot_ID = as.integer(plot_ID))
# 3.2.2.4 plots with no edge edge: sorting trees into circle ---------
trees.no.edge.nogeo <- anti_join(trees_data, forest_edges.man %>%
# filter only for trees that are located in plots with a forest edge
semi_join(forest_edges.man %>%
filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%
select(plot_ID) %>% distinct(), by = "plot_ID") %>%
select(plot_ID) %>%
distinct(), by = "plot_ID")%>%
##georef: remove plots that do now have a corresponding center coordiante in the HBI loc document
semi_join(geo_loc %>% filter(!is.na( RW_MED) & !is.na(HW_MED)) %>%  select(plot_ID)  %>% distinct(), by = "plot_ID")
tree.status.no.edge.list.nogeo <- vector("list", length = length(trees.no.edge.nogeo$tree_ID))
tree.points.no.edge.list.nogeo <- vector("list", length = length(trees.no.edge.nogeo$tree_ID))
for (i in 1:length(trees.no.edge.nogeo$tree_ID)){
#i = 2173
#i = which(grepl(50124, unique(trees.no.edge.nogeo$plot_ID)))
# select plot ID accordint to positioin in the list
my.plot.id <- trees.no.edge.nogeo[i, "plot_ID"]
my.tree.id <- trees.no.edge.nogeo[i, "tree_ID"]
my.inv.year <- trees.no.edge.nogeo[i, "inv_year"]
## georeference
## georef: select UTM corrdinates of the plot center
my.center.easting <- geo_loc[geo_loc$plot_ID == my.plot.id, "RW_MED"]
my.center.northing <- geo_loc[geo_loc$plot_ID == my.plot.id, "HW_MED"]
##georef: select crs
my.utm.epsg <-  paste0("+proj=utm +zone=", pick_utm(my.center.easting)," ", "+datum=WGS84 +units=m +no_defs +type=crs")
# extract polar coordiantes of forest edge
# point A
dist.tree <- trees.no.edge.nogeo[i, "dist_cm"]/100
azi.tree <- trees.no.edge.nogeo[i, "azi_gon"]
x.tree <- dist.tree*sin(azi.tree)   # longitude, easting, RW, X
y.tree <- dist.tree*cos(azi.tree)   # latitude, northing, HW, y
# transform polar into cartesian coordiantes
tree.east <- x.tree   + my.center.easting   ##georef
tree.north <- y.tree  + my.center.northing  ##georef
# save cartesian coordiantes in dataframe
tree.coord.df <- as.data.frame(cbind(
"plot_ID" = c(as.integer(my.plot.id)),
"tree_ID" = c(as.integer(my.tree.id)),
"inv_year" = c(my.inv.year),
"lon" = c(as.numeric(tree.east)),
"lat" = c(as.numeric(tree.north))
))
# create sf point object from dataframe
#https://stackoverflow.com/questions/52551016/creating-sf-points-from-multiple-lat-longs
tree.sf <-  sf::st_as_sf(tree.coord.df, coords = c("lon", "lat"), remove = FALSE)
##georef: assing CRS to points
sf::st_crs(tree.sf) <- my.utm.epsg
#### build circle
# circle data
c.x0 = 0   + my.center.easting   ##georef
c.y0 = 0   + my.center.northing  ##georef
c.r3 = 17.84
c.r2 = 12.62
c.r1 = 5.64
# build polygon (circlular buffer) around center point
center.df<- as.data.frame(cbind("lon" = c.x0, "lat" = c.y0))
circle.pt <- sf::st_as_sf(center.df, coords = c("lon", "lat"))
##georef: assing crs to cirlce corodiantes
sf::st_crs(circle.pt) <- my.utm.epsg
circle.17 <- sf::st_buffer(circle.pt, c.r3)
circle.12 <- sf::st_buffer(circle.pt, c.r2)
circle.5 <- sf::st_buffer(circle.pt, c.r1)
inter.tree.circle.17 <- sf::st_intersection(tree.sf, circle.17)
# if a tree is not intersecting with the circle or its exactly at the edge of the cirlce the inter.tree.circle.17 will be empty,
# however, trees that are exactly 17.84 meters apart from the circle center would still be part of the plot, tho the polygones won´t detect and intersection
# which is why trees only receive the status "warning" if they are acturally situated outside of the circle
tree_status <- ifelse(nrow(inter.tree.circle.17) == 0 & dist.tree > 17.84,  "warning", "A")                                                                                            # if tree is nowhere
tree.status.no.edge.list.nogeo[[i]] <- as.data.frame(cbind(
"plot_ID" = c(as.integer(my.plot.id)),
"tree_ID" = c(as.integer(my.tree.id)),
"inv_year" = c(my.inv.year),
"lon" = c(as.numeric(tree.coord.df$lon)),
"lat" = c(as.numeric(tree.coord.df$lat)),
"t_stat" = c(tree_status))
)
tree.points.no.edge.list.nogeo[[i]] <- c("t_stat" = tree_status, tree.sf)
}
# save tree corodiantes and status into dataframe
tree.status.no.edges.df.nogeo <- as.data.frame(rbindlist(tree.status.no.edge.list.nogeo))
# save tree sf into dataframe
tree.points.no.edges.df.nogeo <- as.data.frame(rbindlist(tree.points.no.edge.list.nogeo))
# bind all tree point.sf dataframes (with & without edges together)
all.trees.points.df.nogeo <-
rbind(tree.points.one.edge.df.nogeo ,
tree.points.two.edges.df.nogeo,
tree.points.no.edges.df.nogeo) %>%
mutate(across(plot_ID:tree_ID, ~ as.integer(.x))) %>%
left_join(., trees_data %>%
select(plot_ID, tree_ID, inv_year, DBH_cm),
by = c("plot_ID", "tree_ID", "inv_year"),
multiple = "all")
# bind all tree status dataframes together (one edge, two edges, no edge plots)
all.trees.status.df <-
rbind(tree.status.no.edges.df.nogeo,
tree.status.one.edge.df.nogeo,
tree.status.two.edges.df.nogeo)
# 3.3. data export ---------------------------------------------------------------------------------------------------------
# 3.3.1. data prep for export -----------------------------------------------------------------------------------------------
# 3.3.1.1. harmonzing strings for join --------------------------------------------------------
# harmonize strings of all.trees.status.df and
# https://stackoverflow.com/questions/20637360/convert-all-data-frame-character-columns-to-factors
all.trees.status.df[,c(1,2,3, 4, 5)] <- lapply(all.trees.status.df[,c(1,2, 3, 4, 5)], as.numeric)
all.edges.area.df.nogeo[,c(1,2, 3,4, 6)] <- lapply(all.edges.area.df.nogeo[,c(1,2, 3, 4, 6)], as.numeric)
# 3.3.1.2. join tree stand status and plot areas into trees dataset  --------------------------------------------------------
trees_update_1 <-trees_data%>%
# join in stand of each tree
left_join(., all.trees.status.df %>%
select(plot_ID, tree_ID, inv_year, t_stat) %>%
distinct(),
by = c("plot_ID", "tree_ID", "inv_year")) %>%
rename(stand = t_stat) %>%
# join in the area that belongs to the tree according to the CCS the tree was measured in/ belongs to
left_join(., all.edges.area.df.nogeo %>%
select(plot_ID, inter_stat, CCS_r_m, stand, area_m2),
by = c("plot_ID", "CCS_r_m", "stand")) %>%
# if there was no plot area claualted due to the fact that there is no edger at the plot,
# we calcualte the area from the sampling circuit diameter assign under CCD_r_m
mutate(area_m2 = ifelse(is.na(e_ID) & is.na(area_m2) |
# for trees alloceted to a in a cirlce without intersections wil not run throuhg the loops
# thus they do  have an edge ID but no calcualted areas or assigned intersection status
# therefore we have to calculate their area manually subsequently
# trees with the status "warning" will not have any stand and area from the dataset "all.edges.area.df.nogeo" assigned
# as this stand category doesn´t exist
# trees with the status "warning" will be excluded from the analysis
stand == "A" & inter_stat != "partly intersecting" & is.na(area_m2) |
stand == "A" & is.na(inter_stat) & is.na(area_m2), c_A(CCS_r_m), area_m2),
# this column is for stand-wise analysis and contains the plot area per tree according to the stand and the sampling circuit it is located in according to its diameter
stand_plot_A_ha = as.numeric(area_m2)/10000,# dividedd by 10 000 to transform m2 into hectar
# this column is for not stand wise analysis and contains the plot area per ptree according to the sampling circiont it is located in according to its diameter
plot_A_ha = c_A(CCS_r_m)/10000)# %>%   # dividedd by 10 000 to transform m2 into hectar
# left_join(geo_loc %>% select(plot_ID, RW_MED, HW_MED), by = "plot_ID") %>%
# mutate(east_tree =  X_tree + RW_MED,
#        north_tree = Y_tree + HW_MED)
# 3.3.1.3. sort trees into remove and process on datasets by status "warning" --------------------------------------------------------
trees_removed_1 <- trees_update_1 %>% filter(stand == "warning")
trees_update_1 <- trees_update_1 %>% filter(stand != "warning")
# 3.3.1.4.  binding datasets together ----------------------------------------------------------
all.triangle.polys.df.nogeo <- rbind(triangle.e1.poly.df.nogeo, triangle.e2.poly.df.nogeo)
all.edge.intersections.poly  <- rbind(inter.poly.one.edge.df.nogeo , inter.poly.two.edges.df.nogeo)#%>% nest("geometry" = geometry)
all.remaning.circles.poly <- rbind(rem.circle.one.edge.df.nogeo, rem.circle.two.edges.df.nogeo) #%>% nest("geometry" = geometry)
all.triangle.coords.df.nogeo <- rbind(triangle.e1.coords.df.nogeo, triangle.e2.coords.df.nogeo) %>%
# the exportet polygones only include the widest cirlce intersection at 17.84m radius
mutate(CCS_r_m = 17.84) %>%
# join in the stand info by plot_ID, e_ID, CCS_r_M
left_join(., all.edges.area.df.nogeo %>% select(plot_ID, e_ID, CCS_r_m, stand),
by = c("plot_ID", "e_ID", "CCS_r_m"))
# 3.3.2. exporting data ---------------------------------------------------
# exporting tree and edge/ plot area data
# one should consider, that in the trees data only those trees are properly sorted in stand s whols plots are georefferenced,
# plots that were not georefferences and by that not processed by the loop are treated like plots without edges though they may have edges
write.csv2(trees_update_1, paste0(out.path.BZE3, paste(unique(trees_update_1$inv)[1], "LT_update_1", sep = "_"), ".csv"))
if(nrow(trees_removed_1)!=0){write.csv2(trees_removed_1, paste0(out.path.BZE3, paste(unique(trees_removed_1$inv)[1], "LT_removed_1", sep = "_"), ".csv"))}
# export tree stand status of all trees nomatter if they have one, two or no forest edges at their plot
write.csv2(all.trees.status.df, paste0(out.path.BZE3, paste(unique(trees_update_1$inv)[1], "all_LT_stand_georef", sep = "_"), ".csv"))
# export areas and stand info of all sampling circuits, edges and remaining circles
write.csv2(all.edges.area.df.nogeo,  paste0(out.path.BZE3, paste(unique(trees_update_1$inv)[1], "all_edges_rem_circles_georef", sep = "_"), ".csv"))
# export list of plots where the both edge polygones intersect within the 17.84 radius
write.csv2(intersection.two.edges.warning.df.nogeo,  paste0(out.path.BZE3, paste(unique(trees_update_1$inv)[1], "edges_intersecting_warning_georef", sep = "_"), ".csv"))
# exporting edge triangle polygones
write.csv2(all.triangle.polys.df.nogeo, paste0(out.path.BZE3, paste(unique(trees_update_1$inv)[1], "all_edges_triangle_poly_georef", sep = "_"), ".csv"))
# exporting edge triangle coordiantes
write.csv2(all.triangle.coords.df.nogeo, paste0(out.path.BZE3, paste(unique(trees_update_1$inv)[1], "all_edges_triangle_coords_georef", sep = "_"), ".csv"))
# exporting edge intersection polygones
#write.csv2(all.edge.intersections.poly, paste0(out.path.BZE3, paste(unique(trees_update_1$inv)[1], "all_edges_intersection_poly", sep = "_"), ".csv"))
# to export the dataframes with long geometries and keep the geometries in list format for better processing later
# thus we export them with the following function, that enables to save the whole geometry list in 1 Table
# https://stackoverflow.com/questions/48024266/save-a-data-frame-with-list-columns-as-csv-file
tibble_with_lists_to_csv(all.edge.intersections.poly %>% nest("geometry" = geometry), paste0(out.path.BZE3, paste(unique(trees_update_1$inv)[1], "all_edges_intersection_poly_georef", sep = "_"), ".csv"))
# exporting all remaining circles polygones
tibble_with_lists_to_csv(all.remaning.circles.poly %>% nest("geometry" = geometry), paste0(out.path.BZE3, paste(unique(trees_update_1$inv)[1], "all_edges_rem_circles_poly_georef", sep = "_"), ".csv"))
## export coordiantes of all edge-triangle-circle-intersections polygones  to  dataframes
all.edge.intersections.coords.list <- vector("list", length = nrow(unique(all.edge.intersections.poly[, c("plot_ID", "e_ID")])))
for (i in 1:nrow(unique(all.edge.intersections.poly[, c("plot_ID", "e_ID")]))) {
# i = 1
all.edge.intersections.coords.list[[i]] <- as.data.frame(cbind(
"plot_ID" = c(all.edge.intersections.poly$plot_ID[i]),
"e_ID" = c(all.edge.intersections.poly$e_ID[i]),
"e_form" = c(all.edge.intersections.poly$e_form[i]),
"lon" = (as_tibble(st_coordinates(all.edge.intersections.poly$geometry[i])) %>% select("X", -c( "L1", "L2"))),
"lat" = (as_tibble(st_coordinates(all.edge.intersections.poly$geometry[i])) %>% select("Y", -c( "L1", "L2")))
))
}
all.edge.intersections.coords.list.final <- rbindlist(all.edge.intersections.coords.list)
all.edge.intersections.coords.df <- as.data.frame(all.edge.intersections.coords.list.final) %>%
# the exportet polygones only include the widest cirlce intersection at 17.84m radius
mutate(CCS_r_m = 17.84) %>%
# join in the stand info by plot_ID, e_ID, CCS_r_M
left_join(., all.edges.area.df.nogeo %>% select(plot_ID, e_ID, CCS_r_m, stand),
by = c("plot_ID", "e_ID", "CCS_r_m"))
write.csv2(all.edge.intersections.coords.df,  paste0(out.path.BZE3, paste(unique(trees_update_1$inv)[1], "all_edges_intersection_coords_georef", sep = "_"), ".csv"))
## export coordiantes of all remaining polygones  to  dataframes
all.rem.circle.coords.list <- vector("list", length = nrow(unique(all.remaning.circles.poly[, c("plot_ID", "e_ID")])))
for (i in 1:nrow(unique(all.remaning.circles.poly[, c("plot_ID", "e_ID")]))) {
# i = 1
all.rem.circle.coords.list[[i]] <- as.data.frame(cbind(
"plot_ID" = c(all.remaning.circles.poly$plot_ID[i]),
"e_ID" = c(all.remaning.circles.poly$e_ID[i]),
"e_form" = c(all.remaning.circles.poly$e_form[i]),
"lon" = (as_tibble(st_coordinates(all.remaning.circles.poly$geometry[i])) %>% select("X", -c( "L1", "L2"))),
"lat" = (as_tibble(st_coordinates(all.remaning.circles.poly$geometry[i])) %>% select("Y", -c( "L1", "L2")))
))
}
all.rem.circle.coords.list.final <- rbindlist(all.rem.circle.coords.list)
all.rem.circle.coords.df <- as.data.frame(all.rem.circle.coords.list.final) %>%
# the exportet polygones only include the widest cirlce intersection at 17.84m radius
mutate(CCS_r_m = 17.84) %>%
# join in the stand info by plot_ID, e_ID, CCS_r_M
left_join(., all.edges.area.df.nogeo %>% select(plot_ID, e_ID, CCS_r_m, stand),
by = c("plot_ID", "e_ID", "CCS_r_m"))
write.csv2(all.rem.circle.coords.df,  paste0(out.path.BZE3, paste(unique(trees_update_1$inv)[1], "all_rem_circles_coords_georef", sep = "_"), ".csv"))
##### forest edges -------------------------------------------------------------------------------------------------------------------------------------------------------
## HBI forest edges
# LT
switch (geo_nogeo,
georefferenced = source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_georef_HBI.R")),
not_georefferenced = source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_HBI.R"))
)
##### forest edges -------------------------------------------------------------------------------------------------------------------------------------------------------
## HBI forest edges
# LT
switch (geo_nogeo = not_georefferenced,
georefferenced = source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_georef_HBI.R")),
not_georefferenced = source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_HBI.R"))
)
##### forest edges -------------------------------------------------------------------------------------------------------------------------------------------------------
## HBI forest edges
# LT
switch (not_georefferenced,
georefferenced = source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_georef_HBI.R")),
not_georefferenced = source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_HBI.R"))
)
##### forest edges -------------------------------------------------------------------------------------------------------------------------------------------------------
## HBI forest edges
# LT
switch (not_georefferenced,
"georefferenced" = source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_georef_HBI.R")),
"not_georefferenced" = source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_HBI.R"))
)
# this function will enable to run a greorefferenced version of a script or not
georef_on_off <- function(path.script.nogeo, path.script.geo, georefference){
switch(georefference,
"georefferenced" = source(path.script.geo),
"not_georefferenced" = source(path.script.nogeo))
}
##### forest edges -------------------------------------------------------------------------------------------------------------------------------------------------------
## HBI forest edges
# LT
georef_on_off(source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_HBI.R")),
source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_georef_HBI.R"))
, georefference = "not_georefferenced")
##### forest edges -------------------------------------------------------------------------------------------------------------------------------------------------------
## HBI forest edges
# LT
georef_on_off(source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_HBI.R")),
source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_georef_HBI.R"))
, georefference = "not_georefferenced")
#### common/ general operations -------------------------------------------------------------------------------------------------------------------------------------------------------------------
# functions & packages
source(paste0(here(), "/scripts/01_00_functions_library.R"))
##### forest edges -------------------------------------------------------------------------------------------------------------------------------------------------------
## HBI forest edges
# LT
georef_on_off(source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_HBI.R")),
source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_georef_HBI.R"))
, georefference = "not_georefferenced")
##### forest edges -------------------------------------------------------------------------------------------------------------------------------------------------------
## HBI forest edges
# LT
georef_on_off(source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_HBI.R")),
source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_georef_HBI.R"))
, georefference = "not_georefferenced")
#### common/ general operations -------------------------------------------------------------------------------------------------------------------------------------------------------------------
# functions & packages
source(paste0(here(), "/scripts/01_00_functions_library.R"))
##### forest edges -------------------------------------------------------------------------------------------------------------------------------------------------------
## HBI forest edges
# LT
georef_on_off(source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_HBI.R")),
source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_georef_HBI.R"))
, georefference = "not_georefferenced")
# ----- 0.1. packages and functions --------------------------------------------
source(paste0(getwd(), "/scripts/01_00_functions_library.R"))
# ----- 0.2. working directory -------------------------------------------------
here::here()
getwd()
out.path.BZE3 <- ("output/out_data/out_data_BZE/")
# ----- 0.3 data import --------------------------------------------------------
# LIVING TREES
# HBI BE dataset: this dataset contains the inventory data of the tree inventory accompanying the second national soil inventory
# here one should immport the the dataset called HBI_trees_update_01.csv which includes only trees that are already sortet according to their inventory status (Baumkennzahl)
trees_data <- read.delim(file = here(paste0(out.path.BZE3, "HBI_LT_update_0.csv")), sep = ";", dec = ",")
# HBI BE locations dataset: this dataset contains the coordinates of the center point of the tree inventory accompanying the second national soil inventory
geo_loc <- read.delim(file = here(paste0("data/input/BZE2_HBI/location_",  trees_data$inv[1], ".csv")), sep = ";", dec = ",")
# HBI forest edges (Waldränder) info
forest_edges <- read.delim(file = here(paste0(out.path.BZE3, trees_data$inv[1], "_forest_edges_update_1.csv")), sep = ";", dec = ",")
# ----- 0.6 harmonising column names & structure  -------------------------
# HBI locations
geo_loc <- geo_loc %>% dplyr::select(c("ï..ToTraktId", "ToEckId", "K2_RW",
"K2_HW", "K3_RW", "K3_HW", "RW_MED",
"HW_MED",  "LAT_MED",  "LON_MED",
"LAT_MEAN", "LON_MEAN"))
colnames(geo_loc) <- c("plot_ID", "ToEckId", "K2_RW",
"K2_HW", "K3_RW", "K3_HW", "RW_MED",
"HW_MED",  "LAT_MED",  "LON_MED",
"LAT_MEAN", "LON_MEAN")
# ----- 1.1.2.1. join in edge info to tree dataset ------------------------
# ----- 1.1.2.1.1. HBI join in forest edge info per plot -----------------------------------------------
trees_data <- trees_data %>%
# calculate the coordinates of every tree
mutate(dist_m = dist_cm/100,
X_tree = coord(data_circle$x0[1], data_circle$y0[1], dist_m, azi_gon, coordinate = "x"),
Y_tree = coord(data_circle$x0[1], data_circle$y0[1], dist_m, azi_gon, coordinate = "y")) %>%
# join in the forest edge information per plot
left_join(., forest_edges %>%
select(plot_ID, e_ID, e_type, e_form),
by = "plot_ID",
multiple = "all") # this is necesarry since there are, apperently, multiple edges per plot
source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_HBI.R"))
# ----- 1.1.2.2. edge  point coordinates,  line parameters, intersections with circles -----------------------------------------------------------
# set up line from 2 points manually
forest_edges.man <- forest_edges %>%
filter(e_form %in% c("1", "2")) %>%
# convert distance from cm to m
mutate(across(c("A_dist", "B_dist", "T_dist"), ~ (.x)/100)) %>%
# find line parameters
# 1. calculate x and y coordinates for all edge points
mutate(X_A = ifelse(A_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], A_dist, A_azi, coordinate = "x"), NA), # if the value is marked -2 its equal to an NA
X_B = ifelse(B_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], B_dist, B_azi, coordinate = "x"), NA),
X_T = ifelse(T_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], T_dist, T_azi, coordinate = "x"), NA),
Y_A = ifelse(A_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], A_dist, A_azi, coordinate = "y"), NA), # if the value is marked -2 its equal to an NA
Y_B = ifelse(B_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], B_dist, B_azi, coordinate = "y"), NA),
Y_T = ifelse(T_azi != "-2", coord(data_circle$x0[1], data_circle$y0[1], T_dist, T_azi, coordinate = "y"), NA)) %>%
# 2. calcualte slope ß1 = (y2-y1)/(x2-x1) hight/width
mutate(b1_AB = ifelse(e_form == "1", slope(X_A, Y_A, X_B, Y_B), NA),
b1_AT = ifelse(e_form == "2", slope(X_T, Y_T, X_A, Y_A), NA),
b1_BT = ifelse(e_form == "2", slope(X_T, Y_T, X_B, Y_B), NA)) %>%
# 3. intercept of line with y-axis b0 : insert known point: XA YA
# Y_A = b1_AB*X_A + b0_AB -- -b1_AB*X_A --> b0_AB =  Y_A - b1_AB*X_A
mutate(b0_AB = ifelse(e_form == "1", intercept(X_A, Y_A,  X_B, Y_B), NA),
b0_AT = ifelse(e_form == "2", intercept(X_T, Y_T, X_A, Y_A), NA),
b0_BT = ifelse(e_form == "2", intercept(X_T, Y_T, X_B, Y_B), NA)) %>%
### 17m circle --> used for tree status also
# find x coordinate of the interception between line and 17.84m circle: insert line equation in circle equation (function: intersection_line_circle)
# for AB line
mutate(X1_inter_AB_17 = intersection_line_circle(b0_AB, b1_AB,  data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x1"),
X2_inter_AB_17 = intersection_line_circle(b0_AB, b1_AB, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x2"),
inter_status_AB_17 = intersection.status(intersection_line_circle(b0_AB, b1_AB,  data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x1"),
intersection_line_circle(b0_AB, b1_AB, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x2")),
# for AT line
X1_inter_AT_17 = intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x1"),
X2_inter_AT_17 = intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x2"),
inter_status_AT_17 = intersection.status(intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x1"),
intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="x2")),
# for BT line
X1_inter_BT_17 = intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x1"),
X2_inter_BT_17 = intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x2"),
inter_status_BT_17 = intersection.status(intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x1"),
intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="x2"))) %>%
# y intersection with 17m circle: insert x of intercept with circle in equation of line
# AB line
mutate(Y1_inter_AB_17 = intersection_line_circle(b0_AB, b1_AB,  data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="y1"),
Y2_inter_AB_17 = intersection_line_circle(b0_AB, b1_AB,  data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="y2"),
# AT line
Y1_inter_AT_17 = intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="y1"),
Y2_inter_AT_17 = intersection_line_circle(b0_AT, b1_AT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3], coordinate="y2"),
# BT line
Y1_inter_BT_17 = intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="y1"),
Y2_inter_BT_17 = intersection_line_circle(b0_BT, b1_BT, data_circle$y0[3], data_circle$x0[3], data_circle$r0[3],  coordinate="y2")) %>%
# distance interception centre --> to see if points are actually placed on the rim of the circle
mutate(inter_1_dist = distance(X1_inter_AB_17, Y1_inter_AB_17, 0, 0)) %>%     # this is just to control if the whole thing worked and
# selecting intersections on the "right" side to check if point lies within triangle
# to calculate the triangles Barycentric coordinates we need 3 points: A, B, C = centre point
# in case T lies within the circle, we want R to select A and B from the intersection with the circle.
# Whereby we have to use a wider radius, to make sure that trees located the halfmoon of the circle cut by the triangle (Kreisbogen) are selected too.
# when t lies inside the circle (so both lines reach outside) ue only intersception point where direction between inter_AT and AT is equal choose this x, we need a buffer tho
# the following statement says:  check if the slope of x_inter_1  or the slope of x_inter_2 is equal to the slope of AT,
#                                choose the x which has the same slope (x_inter_1 or x_inter_2)as the second point on the line (A or B)
#                                but with a buffer of 60m radius, which is why it has to be newly calculated
# find the intercept of circle and line that prolonges the line between a and t or B and T via inter.for.triangle function
# if azimut T to A  identical to azimut T to intercept 1 A and circle use this intercept (inter_AT_1) for the triable, if azimut T to A identical to azimute T to intercept 2 between A and  circle use this intercept (inter_AT_2),
mutate(X_inter_AT_triangle_60 = inter.for.triangle(b0_AT, b1_AT, 0, 0, data_circle$rmax[3]*2, X_A, Y_A, X_T, Y_T, coordinate = "x"),
X_inter_BT_triangle_60 = inter.for.triangle(b0_BT, b1_BT, 0, 0, data_circle$rmax[3]*2, X_B, Y_B, X_T, Y_T, coordinate = "x"),
# calcualte y to the x that lie in the same direction then the second point on the line, if turning points lies witin circle and lines "reach out"
Y_inter_AT_triangle_60 = inter.for.triangle(b0_AT, b1_AT, 0, 0, data_circle$rmax[3]*2, X_A, Y_A, X_T, Y_T, coordinate = "y"),
Y_inter_BT_triangle_60 = inter.for.triangle(b0_BT, b1_BT, 0, 0, data_circle$rmax[3]*2, X_B, Y_B, X_T, Y_T, coordinate = "y"))
# Thuenen Institute - Bodenschutz und Waldzustand
# Analysis of the forest inventory accompanying the  national soil inventory
# forest edges
# ----- 0. SETUP ---------------------------------------------------------------
# ----- 0.1. packages and functions --------------------------------------------
source(paste0(getwd(), "/scripts/01_00_functions_library.R"))
# ----- 0.2. working directory -------------------------------------------------
here::here()
getwd()
out.path.BZE3 <- ("output/out_data/out_data_BZE/")
# ----- 0.3 data import --------------------------------------------------------
# LIVING TREES
# HBI BE dataset: this dataset contains the inventory data of the tree inventory accompanying the second national soil inventory
# here one should immport the the dataset called HBI_trees_update_01.csv which includes only trees that are already sortet according to their inventory status (Baumkennzahl)
trees_data <- read.delim(file = here(paste0(out.path.BZE3, "HBI_LT_update_0.csv")), sep = ";", dec = ",")
# HBI BE locations dataset: this dataset contains the coordinates of the center point of the tree inventory accompanying the second national soil inventory
geo_loc <- read.delim(file = here(paste0("data/input/BZE2_HBI/location_",  trees_data$inv[1], ".csv")), sep = ";", dec = ",")
# HBI forest edges (Waldränder) info
forest_edges <- read.delim(file = here(paste0(out.path.BZE3, trees_data$inv[1], "_forest_edges_update_1.csv")), sep = ";", dec = ",")
# ----- 0.6 harmonising column names & structure  -------------------------
# HBI locations
geo_loc <- geo_loc %>% dplyr::select(c("ï..ToTraktId", "ToEckId", "K2_RW",
"K2_HW", "K3_RW", "K3_HW", "RW_MED",
"HW_MED",  "LAT_MED",  "LON_MED",
"LAT_MEAN", "LON_MEAN"))
colnames(geo_loc) <- c("plot_ID", "ToEckId", "K2_RW",
"K2_HW", "K3_RW", "K3_HW", "RW_MED",
"HW_MED",  "LAT_MED",  "LON_MED",
"LAT_MEAN", "LON_MEAN")
# ----- 1. joining in external info  --------------------------------------
# ----- 1.1. LIVING TREES -------------------------------------------------
# ----- 1.1.1. forest edges -----------------------------------------------
# filter for Waldrandform that imply that we have to do something about it
# Edge form:
# 1 =	L = 	Linie
# 2 =	E	 = Eck
# filter for waldrandtyp that imply that we have to do something about it
# Edge type:
# 1	WA	Waldaußenrand
# L> there shoulnd´t be trees beyond and we have to calculate the area of the cut-out to exclude from calculating the hectar values
# 2	WI	Waldinnenrand
# L> there shoulnd´t be trees beyond and we have to calculate the area of the cut-out to exclude from calculating the hectar values
# 3	BE	Bestandesgrenze
# L> no idea. I think it doesn´t matter because we calculate everything per hecktar
# but we can also try to split the stand by calculating the area behind and before the edge and treat them as two different plots s
# 4	sBE	sonst. Bestandesgrenze
# 1a) for waldrandfrom == 1
# create 1 lm function for forest edge
# through  X|Y of intersection with sampling circuit
# 1b) for waldrandform == 2 we have a turning point in the graph, for WFR == 1 we don´t
#     --> build two lin models (1) X|Y anfang, X|Y Knickpunkt, (2) (1) X|Y ende, X|Y Knickpunkt,
# 2) calculate X|Y of each tree
# y tree = y centre + distance * (sin(Azimut between centre and point)
# 3a) filter for trees with x between x anfang and x Knickpunkt and x ende and x knickpunkt
#     check if y at respeective x is higher then y andfang or y ende
# 3b) filter for trees with Y < Y forest edge function at given X
# ----- 1.1.2.1. join in edge info to tree dataset ------------------------
# ----- 1.1.2.1.1. HBI join in forest edge info per plot -----------------------------------------------
trees_data <- trees_data %>%
# calculate the coordinates of every tree
mutate(dist_m = dist_cm/100,
X_tree = coord(data_circle$x0[1], data_circle$y0[1], dist_m, azi_gon, coordinate = "x"),
Y_tree = coord(data_circle$x0[1], data_circle$y0[1], dist_m, azi_gon, coordinate = "y")) %>%
# join in the forest edge information per plot
left_join(., forest_edges %>%
select(plot_ID, e_ID, e_type, e_form),
by = "plot_ID",
multiple = "all") # this is necesarry since there are, apperently, multiple edges per plot
# ----- 1.1.2.2. edge  point coordinates,  line parameters, intersections with circles -----------------------------------------------------------
# set up line fr
geo_loc
# ----- 0.1. packages and functions --------------------------------------------
source(paste0(getwd(), "/scripts/01_00_functions_library.R"))
# ----- 0.2. working directory -------------------------------------------------
here::here()
getwd()
out.path.BZE3 <- ("output/out_data/out_data_BZE/")
# ----- 0.3 data import --------------------------------------------------------
# LIVING TREES
# HBI BE dataset: this dataset contains the inventory data of the tree inventory accompanying the second national soil inventory
# here one should immport the the dataset called HBI_trees_update_01.csv which includes only trees that are already sortet according to their inventory status (Baumkennzahl)
trees_data <- read.delim(file = here(paste0(out.path.BZE3, "HBI_LT_update_0.csv")), sep = ";", dec = ",")
# HBI BE locations dataset: this dataset contains the coordinates of the center point of the tree inventory accompanying the second national soil inventory
geo_loc <- read.delim(file = here(paste0("data/input/BZE2_HBI/location_",  trees_data$inv[1], ".csv")), sep = ";", dec = ",")
# HBI forest edges (Waldränder) info
forest_edges <- read.delim(file = here(paste0(out.path.BZE3, trees_data$inv[1], "_forest_edges_update_1.csv")), sep = ";", dec = ",")
# ----- 0.6 harmonising column names & structure  -------------------------
# HBI locations
geo_loc <- geo_loc %>% dplyr::select(c("ï..ToTraktId", "ToEckId", "K2_RW",
"K2_HW", "K3_RW", "K3_HW", "RW_MED",
"HW_MED",  "LAT_MED",  "LON_MED",
"LAT_MEAN", "LON_MEAN"))
colnames(geo_loc) <- c("plot_ID", "ToEckId", "K2_RW",
"K2_HW", "K3_RW", "K3_HW", "RW_MED",
"HW_MED",  "LAT_MED",  "LON_MED",
"LAT_MEAN", "LON_MEAN")
source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_HBI.R"))
# ----- 0.6 harmonising column names & structure  -------------------------
# HBI locations
geo_loc <- geo_loc %>% dplyr::select(c("ToTraktId", "ToEckId", "K2_RW",
"K2_HW", "K3_RW", "K3_HW", "RW_MED",
"HW_MED",  "LAT_MED",  "LON_MED",
"LAT_MEAN", "LON_MEAN"))
# HBI BE locations dataset: this dataset contains the coordinates of the center point of the tree inventory accompanying the second national soil inventory
geo_loc <- read.delim(file = here(paste0("data/input/BZE2_HBI/location_",  trees_data$inv[1], ".csv")), sep = ";", dec = ",")
geo_loc
geo_loc[1:10]
source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_HBI.R"))
source(paste0(here(), "/scripts/BZE_III/01_01_LT_forest_edges_HBI.R"))

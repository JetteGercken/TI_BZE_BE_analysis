y.AT.inter.triangle.60 = inter.for.triangle(l.AT.b0, l.AT.b1,  c.x0, c.y0, c.r060, x.a, y.a, x.t, y.t, coordinate = "y" );
#BT
# select the intersection coordinates for the triangle on BT line
x.BT.inter.triangle.60 = inter.for.triangle(l.BT.b0, l.BT.b1,  c.x0, c.y0, c.r060, x.b, y.b, x.t, y.t, coordinate = "x" );
# calculate y for BT triangle
y.BT.inter.triangle.60 = inter.for.triangle(l.BT.b0, l.BT.b1,  c.x0, c.y0, c.r060, x.b, y.b, x.t, y.t, coordinate = "y" );
## For edge form == 1 & for edge form == 2when there are only 2 intersections instead of 4  --> straight line
# assigne tree status depending on shorter/ longer side of circle for edge for 1
# assigning tree status depending on inside/ outside triangle for edge side 2
tree_status_AB_line = ifelse(edge_form == "1", p.site.line(x1.inter.AB, x2.inter.AB, y1.inter.AB, y2.inter.AB, c.x0, c.y0, c.r017, l.AB.b0, l.AB.b1, x.tree, y.tree, output = "tree_stat"),NA);
tree_status_AT_line = p.site.triangle(x1.inter.AT, x2.inter.AT, y1.inter.AT, y2.inter.AT,
c.x0, c.y0, c.r017,
l.AT.b0, l.AT.b1,
x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t,
y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t,
x.tree, y.tree,
output = "tree_stat");
tree_status_BT_line = p.site.triangle(x1.inter.BT, x2.inter.BT, y1.inter.BT, y2.inter.BT,
c.x0, c.y0, c.r017,
l.BT.b0, l.BT.b1,
x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t,
y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t,
x.tree, y.tree,
output = "tree_stat");
## for edge form 2
# check if tree is located inside triangle: Beyericentrig triangle function
tree_stat_triangle = p.in.triangle(x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t, y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t, x.tree, y.tree);
# B = out = point is inside triangle, so outside plot
# A = in =  point is outside triangle, so inside plot
tree_status = ifelse(edge_form == "2" & i_status.AT == "two I" & i_status.BT == "two I", tree_stat_triangle,
# if only one arm of the triangle crosses the circle/ has two intersections with the circle, use the respective arm as a line and assign tree status according to line procedure
ifelse(edge_form == "2" & i_status.AT != "two I" & i_status.BT == "two I", tree_status_BT_line,
ifelse(edge_form == "2" & i_status.AT == "two I" & i_status.BT != "two I", tree_status_AT_line,
# for edge form 1 the selection of the tree status according to the inter status is carried out within the p.site.line function so it doest have to happen here
ifelse(edge_form == "1", tree_status_AB_line,
# if non of the arms or lines touches the circle, assign all trees inside the circle to one group
ifelse(edge_form == "2" & i_status.AT != "two I" & i_status.BT != "two I", "A", NA)))));
return(tree_status)
}
# ----- 1.8. edge area -------------------------------------------------------------------------------------------------------
# ----- 1.8.1. assign correct area to trees according to their category (A/B)  ----------
# to select which area we have assign to the edge and which we have to asssign to the main stand
# we have to find out on which side of the line the "B" and on which side the "A" trees are located
# as we know if the result of the implicit function has to be positive or negative for the tree to lie
# outside the plot, we can calcualte the intersections of a line through the center of the edge line
# and the center of the plot.
# Following we check which of the intersections is element of the triangle or if the result of the implicit function
# of the intersection comlies with the result the implicitf function nee to have for atree to be outside (middle.point.to.line)
# this function should eable us to skip the part where we have to calcualte the intersections etc. for each circle and line
# this way we´ll just return the area per sampling circle
# ----- 1.8.1.1. geometrical forms areas  ----------------------------------------------------------------------------
# new way to calculate circle segment that doesn't rely on comparing the distance of the center point of the line to the intersections of
# a line through the center of the line to the circle center
# developed by Alexandr Chepowskii
CircleSegmnent <- function(x1,y1,x2,y2,r){
# standart line equation parameters: onmicalculator.com
A = y2-y1
B = x2 - x1
C = y1*B - A*x1
# calcualte height of circle segment if edge form is 1 and height can be calculated from shortest distance
# shortest distance between center and AB line: chilimath.com
# center is always 0|0
d = abs(C)/sqrt(A^2+B^2)
# height of the cirlce regment between line and circle perimeter
h = ifelse(d<=r, r-d, 0)
# calculate area of cirlce segment with heigth and radius : wikipedia.de
area = r^2*acos(1-(h/r))-(r-h)*sqrt(r^2-(r-h)^2)
return(area)
}
cone.area <- function(x.0, y.0, x1, y1, x2, y2, r){
angle.between.lines = angle.vectors(x.0, y.0, x1, y1, x2, y2, unit = "degrees")
cone.A = (pi*r^2)*angle.between.lines/360
return(cone.A)
}
triangle.area <- function(x.0, y.0, x1, y1, x2, y2, method){
# standart line equation parameters: onmicalculator.com
A = y2-y1
B = x2 - x1
C = y1*B - A*x1
# shortest distance between center and AB line: chilimath.com
h.triangle  = abs(A*x.0 + B*y.0 + C)/sqrt(A^2+B^2)
g.triangle = distance(x1,y1,x2,y2)
switch(method,
shortest.dist = (h.triangle/2)*g.triangle,
# https://en.wikipedia.org/wiki/Area_of_a_triangle
three.points = 0.5*abs((x1*(y2-y.0) + x2*(y.0 - y1) + x.0*(y.0-y2)))
)
}
# ----- 1.8.1.2. triangle cirlce intersection area via polygone  ----------------------------------------------------------------------------
# new approach to calcualte intersection area developed by Alexandr Chepowskii
triangle.circle.poly.intersection <- function(x1,y1,x2,y2,x3,y3,r){
# center point of circle
pt.circle <- sf::st_point(c(0,0))
circle.poly <- sf::st_buffer(pt.circle, dist = r)
# triangle polygone
poly.data = matrix(c(x1,y1,x2,y2,x3,y3,x1,y1), ncol = 2, byrow = TRUE)
triangle.poly <- sf::st_polygon(list(poly.data))
# intersection between circle and triangle
intersection.circle.trianlge <- sf::st_intersection(circle.poly, triangle.poly)
#calculate area of intersection if intersection is not empty
area.intresection <- sf::st_area(intersection.circle.trianlge)
return(area.intresection)
}
# ----- 1.8.2. final dge area  ----------------------------------------------------------------------------
edge.A <- function(e.form, dbh.cm, x.a, x.b, x.t, y.a, y.b, y.t, t.dist, tree_status, output){
# x1| y1 and x2|y2 belong to the intersections of the line or two points on a line
# c.x0, c.y0 are the center coordinates of the circle
# c.r0 is the radius of the circle
# l.b0, l.b1 are the parameters of the line we assign the edges for
#  xa, xb, xc, ya, yb, yc are the coordinates of the triangle corners that were used to identiy the "out" / "B" trees
# c.seg.a means the area of the cirle segment (circle bow) or the circle segmetns per CCS, c.a means the area if the whole circle
# p_id = 50112
# e.form = forest_edges_HBI.man$e_form[forest_edges_HBI.man$plot_ID == p_id]
# dbh.cm = 35
# x.a = forest_edges_HBI.man$X_A[forest_edges_HBI.man$plot_ID == p_id]
# x.b = forest_edges_HBI.man$X_B[forest_edges_HBI.man$plot_ID == p_id]
# x.t = forest_edges_HBI.man$X_T[forest_edges_HBI.man$plot_ID == p_id]
# y.a = forest_edges_HBI.man$Y_A[forest_edges_HBI.man$plot_ID == p_id]
# y.b = forest_edges_HBI.man$Y_B[forest_edges_HBI.man$plot_ID == p_id]
# y.t = forest_edges_HBI.man$Y_T[forest_edges_HBI.man$plot_ID == p_id]
# t.dist= forest_edges_HBI.man$T_dist[forest_edges_HBI.man$plot_ID == p_id]
# tree_status= "B"
# select the diameter of the circle depending on the trees diameter
c.x0 = 0;
c.y0 = 0;
c.r0 =   ifelse(dbh.cm >= 7 & dbh.cm < 10, 5.64,
ifelse(dbh.cm >= 10 & dbh.cm < 30,  12.62,
ifelse(dbh.cm >= 30, 17.84, NA)))
#
## calcualte slope and intercept of AT and BT line to calcualte intersections
l.AB.b0 = ifelse(e.form == "1", intercept(x.a, y.a, x.b, y.b), NA);
l.AB.b1 = ifelse(e.form == "1", slope(x.a, y.a, x.b, y.b), NA);
l.AT.b0 = ifelse(e.form == "2", intercept(x.t, y.t, x.a, y.a), NA);
l.AT.b1 = ifelse(e.form == "2", slope(x.t, y.t, x.a, y.a), NA);
l.BT.b0 = ifelse(e.form == "2", intercept(x.t, y.t, x.b, y.b), NA);
l.BT.b1 = ifelse(e.form == "2", slope(x.t, y.t, x.b, y.b), NA);
# y = y-achsenabschnitt (intercept) + steigung (slope) * x
## calculate intersections between AB, AT and BT line with respective sampling circle
# AB line
x1.inter.AB <- intersection_line_circle(l.AB.b0, l.AB.b1, c.x0, c.y0, c.r0, coordinate = "x1");
x2.inter.AB <- intersection_line_circle(l.AB.b0, l.AB.b1, c.x0, c.y0, c.r0, coordinate = "x2");
y1.inter.AB <- intersection_line_circle(l.AB.b0, l.AB.b1, c.x0, c.y0, c.r0, coordinate = "y1");
y2.inter.AB <- intersection_line_circle(l.AB.b0, l.AB.b1, c.x0, c.y0, c.r0, coordinate = "y2");
# AT line
x1.inter.AT <- intersection_line_circle(l.AT.b0, l.AT.b1, c.x0, c.y0, c.r0, coordinate = "x1");
x2.inter.AT <- intersection_line_circle(l.AT.b0, l.AT.b1, c.x0, c.y0, c.r0, coordinate = "x2");
y1.inter.AT <- intersection_line_circle(l.AT.b0, l.AT.b1, c.x0, c.y0, c.r0, coordinate = "y1");
y2.inter.AT <- intersection_line_circle(l.AT.b0, l.AT.b1, c.x0, c.y0, c.r0, coordinate = "y2");
# BT line
x1.inter.BT <- intersection_line_circle(l.BT.b0, l.BT.b1, c.x0, c.y0, c.r0, coordinate = "x1");
x2.inter.BT <- intersection_line_circle(l.BT.b0, l.BT.b1, c.x0, c.y0, c.r0, coordinate = "x2");
y1.inter.BT <- intersection_line_circle(l.BT.b0, l.BT.b1, c.x0, c.y0, c.r0, coordinate = "y1");
y2.inter.BT <- intersection_line_circle(l.BT.b0, l.BT.b1, c.x0, c.y0, c.r0, coordinate = "y2");
## assign intersection status of AB, AT and BT lines with respective sampling circle
i_status.AB <-   ifelse(is.na(x1.inter.AB) & is.na(x2.inter.AB), " no I",      # if 0 solutions
ifelse(!is.na(x1.inter.AB) & !is.na(x2.inter.AB) & x1.inter.AB == x2.inter.AB, "one I",            # if 1 solution
ifelse(x1.inter.AB != x2.inter.AB, "two I")));      # so if the edge for is 1 and there are 2 interseections of the line with the respective circle
i_status.AT <-   ifelse(is.na(x1.inter.AT) & is.na(x2.inter.AT), " no I",      # if 0 solutions
ifelse(!is.na(x1.inter.AT) & !is.na(x2.inter.AT) & x1.inter.AT == x2.inter.AT, "one I",            # if 1 solution
ifelse(x1.inter.AT != x2.inter.AT, "two I")));      # so if the edge for is 1 and there are 2 interseections of the line with the respective circle
i_status.BT <-   ifelse(is.na(x1.inter.BT) & is.na(x2.inter.BT), " no I",      # if 0 solutions
ifelse(!is.na(x1.inter.BT) & !is.na(x2.inter.BT) & x1.inter.BT == x2.inter.BT, "one I",            # if 1 solution
ifelse(x1.inter.BT != x2.inter.BT, "two I")));      # so if the edge for is 1 and there are 2 interseections of the line with the respective circle
## build triangle with 60 circle to test if MC lies inside or not
# select the intersection coordinates for the triangle on AT line
x.AT.inter.triangle.60 = inter.for.triangle(l.AT.b0, l.AT.b1,  c.x0, c.y0, 300, x.a, y.a, x.t, y.t, coordinate = "x" );
# calculate y for AT triangle
y.AT.inter.triangle.60 = inter.for.triangle(l.AT.b0, l.AT.b1,  c.x0, c.y0, 300, x.a, y.a, x.t, y.t, coordinate = "y" );
#BT
# select the intersection coordinates for the triangle on BT line
x.BT.inter.triangle.60 = inter.for.triangle(l.BT.b0, l.BT.b1,  c.x0, c.y0, 300, x.b, y.b, x.t, y.t, coordinate = "x" );
# calculate y for BT triangle
y.BT.inter.triangle.60 = inter.for.triangle(l.BT.b0, l.BT.b1,  c.x0, c.y0, 300, x.b, y.b, x.t, y.t, coordinate = "y" );
## build circle segment
# calculate intersections with sampling circle (17,12,5m)
# if AT intersects the cirlce twice, but BT doesnt, x1 = AT_inter_1 and x2 = AT_inter_2
# if AT intersects the cirlce twice, but BT doesnt, l.b0 = l.AT.b0 and l.b1 = l.AT.b1
# if BT intersects the circle twice but AT doesn´t, x1 = BT_inter_1 and x2 = BT_inter_2
# if BT intersects the cirlce twice, but BT doesnt, l.b0 = l.BT.b0 and l.b1 = l.BT.b1
# if AB intersects the circle twice , x1 = AB_inter_1 and x2 = AB_inter_2, l.b0 = l.AB.b0 and l.b1 = l.AB.b1
# if AT and BT intersect the cirlce twise we have to put B in a second variable
# if T lies inside the circle, interA with the same direction as A to T is x1 and inter B with the same direction (azimute) as B to T is x2
x1 = ifelse(e.form == "1" & i_status.AB == "two I", x1.inter.AB,
ifelse(e.form == "2" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT != "two I", x1.inter.AT,
ifelse(e.form == "2" & t.dist > c.r0 & i_status.BT == "two I" & i_status.AT != "two I", x1.inter.BT,
ifelse(e.form == "2" & t.dist <= c.r0 & i_status.AT == "two I" & i_status.BT == "two I", inter.for.triangle(l.AT.b0, l.AT.b1,  c.x0, c.y0, 300, x.a, y.a, x.t, y.t, coordinate = "x" ),
ifelse(e.form == "2" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT == "two I", x1.inter.AT,
NA)))));
x2 = ifelse(e.form == "1" & i_status.AB == "two I", x2.inter.AB,
ifelse(e.form == "2" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT != "two I", x2.inter.AT,
ifelse(e.form == "2" & t.dist > c.r0 & i_status.BT == "two I" & i_status.AT != "two I", x2.inter.BT,
ifelse(e.form == "2" & t.dist <= c.r0 & i_status.AT == "two I" & i_status.BT == "two I", inter.for.triangle(l.BT.b0, l.BT.b1,  c.x0, c.y0, 300, x.b, y.b, x.t, y.t, coordinate = "x" ),
ifelse(e.form == "2" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT == "two I", x2.inter.AT,
NA)))));
y1 = ifelse(e.form == "1" & i_status.AB == "two I", y1.inter.AB,
ifelse(e.form == "2" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT != "two I", y1.inter.AT,
ifelse(e.form == "2" & t.dist > c.r0 & i_status.BT == "two I" & i_status.AT != "two I", y1.inter.BT,
ifelse(e.form == "2" & t.dist <= c.r0 & i_status.AT == "two I" & i_status.BT == "two I", inter.for.triangle(l.AT.b0, l.AT.b1,  c.x0, c.y0, 300, x.a, y.a, x.t, y.t, coordinate = "y" ),
ifelse(e.form == "2" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT == "two I", y1.inter.AT,
NA)))));
y2 = ifelse(e.form == "1" & i_status.AB == "two I", y2.inter.AB,
ifelse(e.form == "2" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT != "two I", y2.inter.AT,
ifelse(e.form == "2" & t.dist > c.r0 & i_status.BT == "two I" & i_status.AT != "two I", y2.inter.BT,
ifelse(e.form == "2" & t.dist <= c.r0 & i_status.AT == "two I" & i_status.BT == "two I", inter.for.triangle(l.BT.b0, l.BT.b1,  c.x0, c.y0, 300, x.b, y.b, x.t, y.t, coordinate = "y" ),
ifelse(e.form == "2" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT == "two I", y2.inter.AT,
NA)))));
# create another intersection pair for circles that are intersected by both arms of the triangle
x.1.bsite = ifelse(e.form == "2" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT == "two I", x1.inter.BT, NA);
x.2.bsite = ifelse(e.form == "2" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT == "two I", x2.inter.BT, NA);
y.1.bsite = ifelse(e.form == "2" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT == "two I", y1.inter.BT, NA);
y.2.bsite = ifelse(e.form == "2" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT == "two I", y2.inter.BT, NA);
# circle segment on AB or AT or BT side
# calculate angle between the lines from sampling cirlce intersections to center
# calcualte circle segment area:
# if t is inside the circle we have to fraw a ne circle around T and the intersections by deductin tht distance between T to the center from the total radius of the circle
c.cone.A = ifelse(e.form == 2 & t.dist <= c.r0, triangle.circle.poly.intersection(x1, y1, x2, y2, x.t, y.t, c.r0),
ifelse(e.form == 2 & t.dist > c.r0, cone.area(c.x0, c.y0, x1, y1, x2, y2, c.r0), NA));
c.cone.A.bsite = ifelse(e.form == 2 & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT == "two I",
cone.area(c.x0, c.y0,  x.1.bsite, y.1.bsite, x.2.bsite, y.2.bsite, c.r0), NA)
# calcualte triangle between turning point or center of circle and the intersection with the respective cricle
triangle.A.asite = ifelse(e.form == 2 &  t.dist > c.r0, triangle.area(c.x0, c.y0, x1, y1, x2, y2, method = "three.points"), NA)
triangle.A.bsite = ifelse(e.form == 2 &  t.dist > c.r0  & i_status.AT == "two I" & i_status.BT == "two I", triangle.area(c.x0, c.y0, x.1.bsite, y.1.bsite, x.2.bsite, y.2.bsite, method = "three.points"), NA)
# calculate circle segment trough withdrawing triangle from cone for edge form 2 where
circle.seg.A.asite = ifelse(e.form == 2 &  t.dist > c.r0, c.cone.A - triangle.A.asite, NA)
circle.seg.A.bsite = ifelse(e.form == 2 &  t.dist > c.r0  & i_status.AT == "two I" & i_status.BT == "two I", c.cone.A.bsite -triangle.A.bsite, NA)
circle.seg.A.e1 = ifelse(e.form == 1 & i_status.AB == "two I", CircleSegmnent(x1, y1, x2, y2, c.r0), 0)
# calcualte circle area
c.A = pi*c.r0^2;
## calculate coordiantes of the middle of thie line between
x_m_line = (x1 + x2)/2;
y_m_line = (y1 + y2)/2;
# calculate the parameters of the equation between the middle of the line and the centre of the circle
b1_MC = slope(c.x0, c.y0, x_m_line, y_m_line);
b0_MC = intercept(c.x0, c.y0, x_m_line, y_m_line);
# calcualte the x corrdiante of the interception of the line between M and the centre of the cirle and the circle at the given radio
X1_inter_MC = intersection_line_circle(b0_MC, b1_MC, c.x0, c.y0, c.r0, coordinate = "x1");
X2_inter_MC = intersection_line_circle(b0_MC, b1_MC, c.x0, c.y0, c.r0, coordinate = "x2");
# insert the intersection x corodinate in the line function to get the respective y coordinate
y1_inter_MC = intersection_line_circle(b0_MC, b1_MC, c.x0, c.y0, c.r0, coordinate = "y1");
y2_inter_MC = intersection_line_circle(b0_MC, b1_MC, c.x0, c.y0, c.r0, coordinate = "y2");
# finde the x coordiante of the intersection that is within the triangle (p.in.tr)
# if inter_1_MC or inter_MC_2 is element of the triangle and the distance between the intersection
# and the middle point of the line is greater then the distanc between the intersection that is outside the triangle and by that inside the plot
# deduct the circle segment from the whole plot area (because the larger part of the plot belongs to category B)
# if the itnersection that is element to the triangle lies on the shorter side of the line, use the circle segment / circle bows area as the edge area
# edge.1.A = ifelse(e.from == "1", c.seg.A, NA);
## return the area of the bigger or smaller circle segment, depending on which one of the both lies inside the triangle for edge form == 2 and only one arm intersecting the circle
edge.2.line.A = ifelse(e.form == "2" &  t.dist > c.r0 & i_status.AT == "two I" & i_status.BT != "two I" &
p.in.triangle(x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t, y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t, X1_inter_MC, y1_inter_MC) == "B" &
distance(X1_inter_MC, y1_inter_MC, x_m_line, y_m_line) > distance(X2_inter_MC, y2_inter_MC, x_m_line, y_m_line) |
e.form == "2" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT != "two I" &
p.in.triangle(x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t, y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t, X2_inter_MC, y2_inter_MC) == "B" &
distance(X2_inter_MC, y2_inter_MC, x_m_line, y_m_line) > distance(X1_inter_MC, y1_inter_MC, x_m_line, y_m_line)|
e.form == "2" & t.dist > c.r0 & i_status.AT != "two I" & i_status.BT == "two I" &
p.in.triangle(x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t, y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t, X1_inter_MC, y1_inter_MC) == "B" &
distance(X1_inter_MC, y1_inter_MC, x_m_line, y_m_line) > distance(X2_inter_MC, y2_inter_MC, x_m_line, y_m_line) |
e.form == "2" & t.dist > c.r0 & i_status.AT != "two I" & i_status.BT == "two I" &
p.in.triangle(x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t, y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t, X2_inter_MC, y2_inter_MC) == "B" &
distance(X2_inter_MC, y2_inter_MC, x_m_line, y_m_line) > distance(X1_inter_MC, y1_inter_MC, x_m_line, y_m_line),
c.A - circle.seg.A.asite, circle.seg.A.asite);
# if the middle point is not inside the triangle, but the edge for is 2 and there are 2 intersections for both arms, while the turning point is outisde the circle,
# we have to calcualte the area on both sides of the lines and then deduct them from each other as they will both extend to the same circle segment
edge.A.e2.center.not.in.triangle = ifelse(e.form == "2" &  t.dist > c.r0 & i_status.AT == "two I" & i_status.BT == "two I" &
p.in.triangle(x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t, y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t, c.x0, c.y0) == "A",
abs(circle.seg.A.asite - circle.seg.A.bsite), NA)
# this is when the respective cirlce (could be also the inner cricle for edge type 1) doesn´t have intersections with the edge line but may still be located in the edge area
# this is, however unlikely for edge type 1 because it assigns the edge area always to the smaller side of the circle so that a whole circle is unlikely to be inside of it
# edge.whole.circle.A = ifelse(e.form == "2" & i_status.AT != "two I" & i_status.BT != "two I" & p.in.triangle(x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t, y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t, c.x0, c.y0) == "B", c.A, NA)
# for edge form == 1 it´s always the circle segment, cause the trees in
edge.area = ifelse(e.form == "1" & tree_status == "B" & i_status.AB == "two I", circle.seg.A.e1,
# if only one side of triangle is intersection
ifelse(e.form == "2" & tree_status == "B" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT != "two I"|
e.form == "2" & tree_status == "B"&  t.dist > c.r0 & i_status.BT == "two I" & i_status.AT != "two I", edge.2.line.A,
# t is inside circle so whole cone is the edge area
ifelse(e.form == "2" & tree_status == "B"&  t.dist <= c.r0 & i_status.AT == "two I" & i_status.BT == "two I", c.cone.A,
# both arms of triangle cut circle so triangle area is between the both circle segments anf center of cirlce is inside triangle
ifelse(e.form == "2" & tree_status == "B" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT == "two I" & p.in.triangle(x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t, y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t, c.x0, c.y0) == "B", c.A - (circle.seg.A.bsite + circle.seg.A.asite),
# if the middle point is not inside the triangle, but the edge for is 2 and there are 2 intersections for both arms, while the turning point is outisde the circle,
# we have to calcualte the area on both sides of the lines and then deduct them from each other as they will both extend to the same circle segment
ifelse(e.form == "2" &  t.dist > c.r0 & i_status.AT == "two I" & i_status.BT == "two I" & p.in.triangle(x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t, y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t, c.x0, c.y0) == "A", edge.A.e2.center.not.in.triangle,
# this is when the respective cirlce (could be also the inner cricle for edge type 1) doesn´t have intersections with the edge line but may still be located in the edge area
# this is, however unlikely for edge type 1 because it assigns the edge area always to the smaller side of the circle so that a whole circle is unlikely to be inside of it
ifelse(e.form == "2" & i_status.AT != "two I" & i_status.BT != "two I" &  p.in.triangle(x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t, y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t, c.x0, c.y0) == "B", c.A,
#ifelse(e.form == "1" & tree_status == "B" & i_status.AB != "two I", c.A,
0))))));
rem.circle.area = c.A - edge.area;
# there is a problem here because for plot with two edges, the remaining circle area will be reduced by the area of both edges, which the function cannot provide for now
# thus it could be smarter to just get the edge area returned per plot and circle and then reduce the remaining area by the area of the respective edges
area = ifelse(tree_status == "A" | is.na(e.form), rem.circle.area, edge.area);
edge.method = ifelse(e.form == "1" & tree_status == "B" & i_status.AB == "two I", "CircleSeg_e1",
# if only one side of triangle is intersection
ifelse(e.form == "2" & tree_status == "B" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT != "two I"|
e.form == "2" & tree_status == "B"&  t.dist > c.r0 & i_status.BT == "two I" & i_status.AT != "two I", "e2_line_CirSeg_in_triangle",
# t is inside circle so whole cone is the edge area
ifelse(e.form == "2" & tree_status == "B"&  t.dist <= c.r0 & i_status.AT == "two I" & i_status.BT == "two I", "e2_cone",
# both arms of triangle cut circle so triangle area is between the both circle segments anf center of cirlce is inside triangle
ifelse(e.form == "2" & tree_status == "B" & t.dist > c.r0 & i_status.AT == "two I" & i_status.BT == "two I" & p.in.triangle(x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t, y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t, c.x0, c.y0) == "B", "e2_aside_bside_minus_whole_cirlce",
# if the middle point is not inside the triangle, but the edge for is 2 and there are 2 intersections for both arms, while the turning point is outisde the circle,
# we have to calcualte the area on both sides of the lines and then deduct them from each other as they will both extend to the same circle segment
ifelse(e.form == "2" &  t.dist > c.r0 & i_status.AT == "two I" & i_status.BT == "two I" & p.in.triangle(x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t, y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t, c.x0, c.y0) == "A", "e2.center.not.in.triangle_aside_minus_bside",
# this is when the respective cirlce (could be also the inner cricle for edge type 1) doesn´t have intersections with the edge line but may still be located in the edge area
# this is, however unlikely for edge type 1 because it assigns the edge area always to the smaller side of the circle so that a whole circle is unlikely to be inside of it
ifelse(e.form == "2" & i_status.AT != "two I" & i_status.BT != "two I" &  p.in.triangle(x.AT.inter.triangle.60, x.BT.inter.triangle.60, x.t, y.AT.inter.triangle.60, y.BT.inter.triangle.60, y.t, c.x0, c.y0) == "B", "whole_circle",
#ifelse(e.form == "1" & tree_status == "B" & i_status.AB != "two I", c.A,
"no edge area"))))))
area.method =  ifelse(tree_status == "A" | is.na(e.form), "rem.circle.area", edge.method);
switch(output,
"edge.only" = edge.area,
"edge.method.only" = edge.method,
"area_m2" = area,
"method" = area.method)
}
# ---- 1.9. HEIGHTS ------------------------------------------------------
# ---- 1.9.1. height coefficient selection ------------------------------------------------------
# this function is used to select the coefficients of the height models depending on the R2
# for x, y,a, b (can be whatever)
f = function(x,y,a,b){
# do the following: if x is na, or x is smaller then y, then use a, if not use b
answer <- ifelse(is.na(x)| x < y, a, b)
return(answer)}
# ---- 1.9.2. einheitshoehenkurve------------------------------------------------------
# ---- 1.9.2.1. Sloboda ------------------------------------------------------
ehk_sloboda <- function(spec, d_i, d_mean, d_g, h_g) { #, id_broken) {
k0 <- c(fi = 0.183, ta = 0.079, dgl = 0.24, ki = 0.29, lae = 0.074, bu = 0.032, ei = 0.102, alh = 0.122, aln = 0.032)
k1 <- c(fi = 5.688, ta = 3.992, dgl = 6.033, ki = 1.607, lae = 3.692, bu = 6.04, ei = 3.387, alh = 5.04, aln = 4.24)
k2 <- c(fi = 0.29, ta = 0.317, dgl = 0.33, ki = 0.388, lae = 0.342, bu = 0.367, ei = 0.488, alh = 0.47, aln = 0.461)
h_mean <- (h_g - 1.3)/(exp(k0[tolower(spec)]*(1 - d_mean/d_g))*exp(k1[tolower(spec)]*(1/d_mean - 1/d_g))) + 1.3;
h_pred <- ((1.3 + (h_mean - 1.3)*exp(k0[tolower(spec)]*(1 - d_mean/d_i))*exp(k1[tolower(spec)]*(1/d_mean - 1/d_i)))/10); # divide by 10 to get height in m
# this part is silenced, because there is no Hoehenkennzahl documented for MoMoK
# and BZE because they dont do a Winkelzähprobe
# Reduction factor depending on whether crown or stem is broken or not
# if (length(id_broken) == length(d_i)) {
#   f_red <- rep(1.0, length(d_i));
#   f_red[which(id_broken == 0)] <- 1.0;
#   f_red[which(id_broken == 1)] <- 1 - 2/h_pred[which(id_broken == 1)];
#   f_red[which(id_broken == 2)] <- 1 - k2[tolower(spec[which(id_broken == 2)])];
# } else if (length(id_broken) == 1) {
#   if (id_broken == 0) f_red <-  1.0
#   else if (id_broken == 1) f_red <- 1 - 2/h_pred
#   else if (id_broken == 2) f_red <- 1 - k2[tolower(spec)]
# }
return(h_pred)#*f_red)
}
# ---- 1.9.2.2. Curtis ------------------------------------------------------
# --> this one is only applied when there is literally not information to calculate the height,
# except of the diameter
h_curtis <- function(spec, d) {
# spec = species group
# diameter in mm
b0 <- c(fi = 434.1235, bu = 382.0202, ta = 453.5538, ki = 359.7162, lae = 421.4473, dgl = 481.5531, ei = 348.3262);
b1 <- c(fi = -65586.6915, bu = -51800.9382, ta = -81132.5221, ki = -42967.9947, lae = -60241.2948, dgl = -81754.2523, ei = -46547.3645);
b2 <- c(fi = 3074967.1738, bu = 2374368.3254, ta = 4285801.5636, ki = 1763359.9972, lae = 2895409.6245, dgl = 4193121.2406, ei = 2119420.9444);
return((b0[tolower(spec)] + b1[tolower(spec)]*1/d + b2[tolower(spec)]*1/d^2)/10)   # divide by 10 to transform dm into meters
}
# ---- 1.9.3. self-fitted nls height models ------------------------------------------------------
# ---- 1.9.3.1. species- & plot-wise self-fitted nls models ------------------------------------------------------
# self made nls models for heights per species across all plots
h_nls_SP <- function(spec, d){
# https://statisticsglobe.com/convert-data-frame-column-to-a-vector-in-r
b0 <- dplyr::pull(coeff_H_SP, b0, SP_code);
b1 <- dplyr::pull(coeff_H_SP, b1, SP_code);
b2 <- dplyr::pull(coeff_H_SP, b2, SP_code);
return(b0[spec] * (1 - exp( -b1[spec] * d))^b2[spec])
}
# ---- 1.9.3.2. species-wise self-fitted nls models ------------------------------------------------------
# self mase nls models for heights per species per plot
h_nls_SP_P <- function(plot_spec, d) {
# because I cannot combine 3 variabels in one vector,
b0 <- coeff_H_SP_P %>% unite(SP_P_ID, plot_ID, SP_code, sep = "", remove = FALSE) %>% dplyr::pull(b0, SP_P_ID);
b1 <- coeff_H_SP_P %>% unite(SP_P_ID, plot_ID, SP_code, sep = "", remove = FALSE) %>% dplyr::pull(b1, SP_P_ID);
b2 <- coeff_H_SP_P %>% unite(SP_P_ID, plot_ID, SP_code, sep = "", remove = FALSE) %>% dplyr::pull(b2, SP_P_ID);
return(b0[plot_spec] * (1 - exp( -b1[plot_spec] * d))^b2[plot_spec])
}
# 1.10. select the correct inventory name -------------------------------------------------------------------
# https://www.geeksforgeeks.org/check-if-a-numeric-value-falls-between-a-range-in-r-programming-between-function/
inv_name <- function(inv.year){
inv <- ifelse(between(inv.year, 2011, 2013), "HBI",
ifelse(between(inv.year, 2023, 2025), "BZE3",
ifelse(between(inv.year, 2033, 2035) , "BZE4", "BZE5"
)));
return(inv)
}
# 1.11. Biomass functions -------------------------------------------------
# reference:
# Wutzler, Thomas & Wirth, Christian & Schumacher, Jens. (2008).
# Generic biomass functions for Common beech (Fagus sylvatica) in Central Europe:
# Predictions and components of uncertainty.
# Canadian Journal of Forest Research - Journal Canadien de la Recherche Forestiere,
# v.38, 1661-1675 (2008). 38. 10.1139/X07-194.
### foliage of broadleaved trees according to Wutzler et al. 2008
# to aply this function the Oberhoehe and the elevation above sea level are required
# DHC 4c model
Wutzler_fB_L <- function(d, h, alt, si){   # DHC 4c model
b = 0;
b0 = 0.0561;
b1 = 2.07;
b2 = (-1.09);
bssi = 0.0137;
bsalt = (-0.00000329);
# from marks file: ((b0 + bsalt*alt) * DBH^(b1+bsi*SI) * H^b2
# from Wutzler 2008, Annex 3:
#         biomass = (b0 + 0+ bssi*si+ bsalt*atitude)*(DBH^b1)*(H^b2)
return(# so its either this: (b0 + 0 + bssi*SI + bsalt*alt)*d^b1*h^b2)
# or this from Mark:
(b0+bsalt*alt)*d^(b1+bssi*si)*h^b2)
}
#DH3, 4a Model, table: 4
Wutzler_fB_L1 <- function(d, h){  #DH3 4a Model
b0 = 0.0377;
b1 = 2.43;
b2 = (-0.913);
return(b0*d^b1*h^b2)
}
## belowground phytomass GHGI
GHGI_bB <- function(spec, d){
# function for soft hard woods requires DBH in mm,
# thus we have to transform input DBH in cm into DBH in mm by dividing by 10
dbh <- ifelse(spec != "shw", d, d*10);
b0 <- c(fi = 0.003720, ki = 0.006089, bu = 0.018256, ei= 0.028000, shw = 0.000010);#shwr =0.000010, shwrs = 0.000116);
b1 <- c(fi = 2.792465, ki = 2.739073, bu = 2.321997, ei= 2.440000, shw = 2.529000); #shwr =2.529000, shwrs = 2.290300);
# this would return the root + stump biomas for soft hardwoods but only the root biomass for all other species groups
# ifelse(spec != "shw", b0[spec]*d^b1[spec], (b0[spec]*d^b1[spec])+(0.000116*d^2.290300))
return(b0[spec]*d^b1[spec])
}
# ----- 1.12. Nitrogen stock  --------------------------------------------
# nitrogen stock for woody compartiments
N_all_com <- function(B, N_spec_w_rumpf, N_spec_f_BZE, N_spec_bg_Jacobsen, comp.trees){
n_con_w <- N_con_w  %>%  filter(compartiment != "ndl") %>% unite("SP_com", SP_BWI:compartiment, remove = FALSE)%>% dplyr::pull(N_con, SP_com);
n_con_f <- N_con_f %>% dplyr::pull(N_con, N_f_SP_group_MoMoK)
# this function may have to be be adapted to the new dataset of the NSI which provides accurate N cocntents for all species and foliage
# proably I will also have to assign new species groups to acces the foliage dataset correctly
n_con_bg <- c(EI = 3.71, BU = 3.03, FI = 4.14, KI = 1.77, KIN = 1.76, BI = 3.7, LA = 2.8)/1000;# divide concentration in mg per g by 1000 to get concentration in percent/ decimal number of percent
# unite the compartiment and species to select the correct nitrogen content
SP_compart_Rumpf <- paste0(N_spec_w_rumpf, "_", comp.trees);
# calculate nitrogen content in the aboveground and belowground compartiments but without sums (total or total aboveground N)
N <- case_when(
comp.trees == "ndl" ~ as.numeric(B)*as.numeric(n_con_f[N_spec_f_BZE]),
comp.trees == "bg" ~ as.numeric(B)*as.numeric(n_con_bg[N_spec_bg_Jacobsen]),
!(comp.trees %in% ("ag, total, ndl, bg")) ~ as.numeric(B)*as.numeric(n_con_w[SP_compart_Rumpf]),
TRUE ~ NA)
return(N)
}
# 1.13. carbon stock ------------------------------------------------------
carbon <- function(B){
C <- B*0.5;
return(C)
}
# Thuenen Institute - Bodenschutz und Waldzustand
# Analysis of the forest inventory accompanying the  national soil inventory
# forest edges
# ----- 0. SETUP ---------------------------------------------------------------
# ----- 0.1. packages and functions --------------------------------------------
source(paste0(getwd(), "/scripts/00_functions_library.R"))
# ----- 0.2. working directory -------------------------------------------------
here::here()
getwd()
out.path.BZE3 <- ("output/out_data/out_data_BZE/")
# ----- 0.3 data import --------------------------------------------------------
# LIVING TREES
# HBI BE dataset: this dataset contains the inventory data of the tree inventory accompanying the second national soil inventory
# here one should immport the the dataset called HBI_trees_update_01.csv which includes only trees that are already sortet according to their inventory status (Baumkennzahl)
HBI_trees <- read.delim(file = here("data/input/BZE2_HBI/beab.csv"), sep = ",", dec = ",")
# HBI BE locations dataset: this dataset contains the coordinates of the center point of the tree inventory accompanying the second national soil inventory
HBI_loc <- read.delim(file = here("data/input/BZE2_HBI/location_HBI.csv"), sep = ";", dec = ",")
# HBI point info
HBI_inv_info <- read.delim(file = here("data/input/BZE2_HBI/be.csv"), sep = ",", dec = ",", stringsAsFactors=FALSE)
# HBI forest edges (Waldränder) info
forest_edges_HBI <- read.delim(file = here("data/input/BZE2_HBI/be_waldraender.csv"), sep = ";", dec = ",")
# creating dataset with information about the concentric sampling circles
data_circle <- data.frame(x0 = c(0,0,0),       # x of centre point of all 3 circles is 0
y0 = c(0,0,0),       # y of centre point of all 3 circles is 0
r0 = c(5.64, 12.62, 17.84), # darius in m
rmax = c(30.00, 30.00, 30.00)) # these are the radi of the sampling circuits in m
# ----- 0.6 harmonising column names & structure  -------------------------
# HBI trees
colnames(HBI_trees) <- c("multi_stem", "D_mm", "DBH_class", "DBH_h_cm", "H_dm",
"azi_gon", "SP_code", "tree_ID", "plot_ID", "tree_inventory_status",
"DBH_cm", "age", "C_layer", "C_h_dm", "Kraft", "Dist_cm", "age_meth")
HBI_trees <- HBI_trees %>% dplyr::select(plot_ID,  tree_ID ,  tree_inventory_status ,  multi_stem ,
Dist_cm ,  azi_gon ,age ,  age_meth ,  SP_code , DBH_class ,  Kraft ,
C_layer , H_dm ,  C_h_dm , D_mm ,   DBH_h_cm ,  DBH_cm )
# HBI locations
HBI_loc <- HBI_loc %>% dplyr::select("ï..ToTraktId", "ToEckId", "K2_RW",
"K2_HW", "K3_RW", "K3_HW", "RW_MED",
"HW_MED",  "LAT_MED",  "LON_MED",
"LAT_MEAN", "LON_MEAN")
colnames(HBI_loc) <- c("plot_ID", "ToEckId", "K2_RW",
"K2_HW", "K3_RW", "K3_HW", "RW_MED",
"HW_MED",  "LAT_MED",  "LON_MED",
"LAT_MEAN", "LON_MEAN")
# HBI point/ inventory info
HBI_inv_info <- HBI_inv_info %>% dplyr::select(bund_nr, datum, hbi_status )
colnames(HBI_inv_info) <- c("plot_ID", "date", "plot_inventory_status")
# create column that just contains year of inventory: https://www.geeksforgeeks.org/how-to-extract-year-from-date-in-r/
HBI_inv_info$date <- as.Date(HBI_inv_info$date)
HBI_inv_info$inv_year <- as.numeric(format(HBI_inv_info$date, "%Y"))
# this line can be removed later
HBI_inv_info <- HBI_inv_info %>% mutate(inv_year = ifelse(inv_year < 2012, 2012,inv_year),
inv = inv_name(inv_year))
# Forest edges
colnames(forest_edges_HBI) <- c("plot_ID", "e_ID", "e_type", "e_form",
"A_dist", "A_azi",  "B_dist", "B_azi",
"T_dist", "T_azi") # t = turning point
# ----- 1. joining in external info  --------------------------------------
# ----- 1.1. LIVING TREES -------------------------------------------------
# ----- 1.1.1. species & inventory names ----------------------------------------------
# ----- 1.1.1.1. HBI species & inventory ----------------------------------------------
HBI_trees <- HBI_trees %>%
left_join(., HBI_inv_info %>% dplyr::select("plot_ID", "plot_inventory_status", "inv_year", "inv"),
by = "plot_ID") %>%
mutate(inv = inv_name(inv_year),
DBH_cm = ifelse(DBH_h_cm == 130, D_mm/10, DBH_Dahm(plot_ID, D_mm, DBH_h_cm, SP_code)))

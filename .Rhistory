bio.ag.kg.list <- vector("list", length = nrow(unique(trees_harvested[, c("plot_ID", "tree_ID")])))
for (i in 1:nrow(unique(trees_harvested[, c("plot_ID", "tree_ID")]))) {
# i = 60
# i = trees_harvested %>%  select(plot_ID, tree_ID, LH_NH) %>% distinct() %>% mutate(r_no = row_number()) %>% filter(LH_NH == "LB") %>%slice(1)%>% pull(r_no)
# basic tree info
# select one tree ID and plot ID for each individual tree per plot through unique(trees_harvested[, c("plot_ID", "tree_ID")])
my.plot.id <- unique(trees_harvested[, c("plot_ID", "tree_ID")])[,"plot_ID"][i]
my.tree.id <- unique(trees_harvested[, c("plot_ID", "tree_ID")])[,"tree_ID"][i]
BL.or.CF <- unique(trees_harvested$LH_NH[trees_harvested$plot_ID==my.plot.id & trees_harvested$tree_ID==my.tree.id])
# select variales for tree object: tapes species, diameter, diameter measuring height, tree height
spp = na.omit(unique(trees_harvested$tpS_ID[trees_harvested$plot_ID==my.plot.id & trees_harvested$tree_ID==my.tree.id]))
Dm = na.omit(as.list(as.numeric(unique(trees_harvested$DBH_cm[trees_harvested$plot_ID==my.plot.id & trees_harvested$tree_ID==my.tree.id]))))
Hm = na.omit(as.list(as.numeric(unique(trees_harvested$DBH_h_cm[trees_harvested$plot_ID==my.plot.id & trees_harvested$tree_ID==my.tree.id])/100)))
Ht = na.omit(as.numeric(unique(trees_harvested$H_m[trees_harvested$plot_ID==my.plot.id & trees_harvested$tree_ID==my.tree.id])))
# create tapes compartiments
comp <- as.character(c("stw","stb","sw", "sb", "fwb", "ndl" ))
# create object
obj.trees <- tprTrees(spp, Dm, Hm, Ht, inv = 4)
# calculate biomass per compartiment
bio.df <- as.data.frame(tprBiomass(obj = obj.trees, component = comp)) %>%
pivot_longer(cols = stw:ndl,
names_to = "compartiment",
values_to = "B_kg_tree")
bio.info.df <- as.data.frame(cbind(
"plot_ID" = c(as.integer(trees_harvested$plot_ID[trees_harvested$plot_ID == my.plot.id & trees_harvested$tree_ID == my.tree.id])),
"tree_ID" = c(as.integer(trees_harvested$tree_ID[trees_harvested$plot_ID == my.plot.id & trees_harvested$tree_ID == my.tree.id])),
"inv" = c(trees_harvested$inv[trees_harvested$plot_ID == my.plot.id & trees_harvested$tree_ID == my.tree.id]),
"inv_year" = c(as.integer(trees_harvested$inv_year[trees_harvested$plot_ID == my.plot.id & trees_harvested$tree_ID == my.tree.id])),
"LH_NH" = c(trees_harvested$LH_NH[trees_harvested$plot_ID == my.plot.id & trees_harvested$tree_ID == my.tree.id]),
"compartiment" = c(bio.df$compartiment),
"B_kg_tree" = c(as.numeric(bio.df$B_kg_tree))
) ) %>%
# if the tree is a broadleafed tree Tapes cannot calculate the foliage mass,
# thus we calculate this subsequently trough the biomass function by Wutzler (2008)
mutate(B_kg_tree = ifelse(compartiment == "ndl" & LH_NH == "LB",
Wutzler_fB_L1(as.numeric(Dm), as.numeric(Ht)),
B_kg_tree)) %>%
dplyr::select(-c("LH_NH"))
bio.ag.kg.list[[i]] <- bio.info.df
}
bio_ag_kg_df <- as.data.frame(rbindlist(bio.ag.kg.list))
# 1.1.2. biomass belowground compartiments ----------------------------------
bio.bg.kg.list <- vector("list", length = nrow(unique(trees_harvested[, c("plot_ID", "tree_ID")])))
for (i in 1:nrow(unique(trees_harvested[, c("plot_ID", "tree_ID")]))) {
# i = 60
# i = trees_harvested %>%  select(plot_ID, tree_ID, LH_NH) %>% distinct() %>% mutate(r_no = row_number()) %>% filter(LH_NH == "LB") %>%slice(1)%>% pull(r_no)
# basic tree info
my.plot.id <- unique(trees_harvested[, c("plot_ID", "tree_ID")])[,"plot_ID"][i]
my.tree.id <- unique(trees_harvested[, c("plot_ID", "tree_ID")])[,"tree_ID"][i]
#my.inv <-  unique(trees_harvested[, c("plot_ID", "tree_ID")])[,"inv"][i]
BL.or.CF <- unique(trees_harvested$LH_NH[trees_harvested$plot_ID==my.plot.id & trees_harvested$tree_ID==my.tree.id])
# select variales for tree object
spp = unique(trees_harvested$Bio_SP_group[trees_harvested$plot_ID==my.plot.id & trees_harvested$tree_ID==my.tree.id])
dbh.cm = as.numeric(unique(trees_harvested$DBH_cm[trees_harvested$plot_ID==my.plot.id & trees_harvested$tree_ID==my.tree.id]))
# calculate biomass per compartiment
B_kg_tree <- as.data.frame(GHGI_bB(spp, dbh.cm))[,1]
bio.info.df <- as.data.frame(cbind(
"plot_ID" = c(as.integer(my.plot.id)),
"tree_ID" = c(as.integer(my.tree.id)),
"inv" = unique(trees_harvested$inv[trees_harvested$plot_ID==my.plot.id & trees_harvested$tree_ID==my.tree.id]),
"inv_year" = c(as.integer(unique(trees_harvested$inv_year[trees_harvested$plot_ID==my.plot.id & trees_harvested$tree_ID==my.tree.id]))),
"compartiment" = c("bg"),
"B_kg_tree" = c(as.numeric(B_kg_tree))
) )
bio.bg.kg.list[[i]] <- bio.info.df
}
bio_bg_kg_df <- as.data.frame(rbindlist(bio.bg.kg.list))
# 1.1.3. biomass all compartiments - total ----------------------------------
bio_total_kg_df <-
rbind(
# calculate total biomass (aboveground + belowground) by summing up biomass in kg per tree in all compartiments
rbind(
bio_ag_kg_df, bio_bg_kg_df) %>%
group_by(plot_ID, tree_ID, inv, inv_year) %>%
summarize(B_kg_tree = sum(as.numeric(B_kg_tree))) %>%
mutate(compartiment = "total") %>%
select("plot_ID", "tree_ID", "inv",
"inv_year", "compartiment", "B_kg_tree"),
# calculate total aboveground biomass by summing up biomass in kg per tree in all aboveground compartiments
bio_ag_kg_df%>%
group_by(plot_ID, tree_ID, inv, inv_year) %>%
summarize(B_kg_tree = sum(as.numeric(B_kg_tree))) %>%
mutate(compartiment = "ag")%>%
select("plot_ID", "tree_ID", "inv",
"inv_year", "compartiment", "B_kg_tree"))
# 1.1.4. harmonizing biomass strings and compartiment names ---------------
#  harmonize strings of bio_total_kg_df
# https://stackoverflow.com/questions/20637360/convert-all-data-frame-character-columns-to-factors
bio_total_kg_df[,c(1,2, 4, 6)] <- lapply(bio_total_kg_df[,c(1,2,4, 6)], as.numeric)
bio_ag_kg_df[,c(1,2, 4, 6)] <- lapply(bio_ag_kg_df[,c(1,2,4, 6)], as.numeric)
bio_bg_kg_df[,c(1,2, 4, 6)] <- lapply(bio_bg_kg_df[,c(1,2,4, 6)], as.numeric)
bio_total_kg_df
bio_ag_kg_df
bio_bg_kg_df
trees_harvested %>% distinct() %>%
left_join(.,
rbind(bio_ag_kg_df ,
bio_bg_kg_df,
bio_total_kg_df) %>%
distinct(),
by = c("plot_ID", "tree_ID", "inv", "inv_year")
trees_harvested %>% distinct() %>%
trees_harvested %>% distinct() %>%
left_join(.,
rbind(bio_ag_kg_df ,
bio_bg_kg_df,
bio_total_kg_df) %>%
distinct(),
by = c("plot_ID", "tree_ID", "inv", "inv_year"),
multiple = "all")
trees_harvested <- trees_harvested %>% distinct() %>%
left_join(.,
rbind(bio_ag_kg_df ,
bio_bg_kg_df,
bio_total_kg_df) %>%
distinct(),
by = c("plot_ID", "tree_ID", "inv", "inv_year"),
multiple = "all")
# 1.2. Nitrogen calculation -----------------------------------------------
# 1.2.1. Nitrogen stock in abofeground and belowgroung compartiments-----------------------------------------------
N_ag_bg_kg_df <- trees_harvested %>%
filter(!(compartiment %in% c("ag", "total")))  %>%  # make sure the aboveground& belowground dataset doesnt include summed up compartiments like total and aboveground
mutate(N_kg_tree = N_all_com(B_kg_tree, N_SP_group, N_f_SP_group_MoMoK, N_bg_SP_group, compartiment)) %>%
select(plot_ID, tree_ID, inv, inv_year, compartiment, N_kg_tree)
# 1.2.2. Nitrogen ston in all compartiments summed up - total & aboveground  ----------------------------------
N_total_kg_df <-
rbind(
# calculate total biomass (aboveground + belowground) by summing up biomass in kg per tree in all compartiments
N_ag_bg_kg_df %>%
group_by(plot_ID, tree_ID, inv, inv_year) %>%
summarize(N_kg_tree = sum(as.numeric(N_kg_tree))) %>%
mutate(compartiment = "total") %>%
select("plot_ID", "tree_ID", "inv",
"inv_year", "compartiment", "N_kg_tree"),
# calculate total aboveground biomass by summing up biomass in kg per tree in all aboveground compartiments
N_ag_bg_kg_df%>%
filter(compartiment != "bg") %>%  # select only aboveground compartiments by exxlduing bg compartiment from N.ab.bg. dataframe
group_by(plot_ID, tree_ID, inv, inv_year) %>%
summarize(N_kg_tree = sum(as.numeric(N_kg_tree))) %>%
mutate(compartiment = "ag")%>%
select("plot_ID", "tree_ID", "inv",
"inv_year", "compartiment", "N_kg_tree"))
# 1.2.3. join Nitrogen stocks into tree dataset -----------------------------------
trees_harvested <- trees_harvested %>% left_join(.,
rbind(N_ag_bg_kg_df ,
N_total_kg_df),
by = c("plot_ID", "tree_ID", "inv", "inv_year", "compartiment"),
multiple = "all")
# 1.3. carbon stock per tree & compartiment -------------------------------------------------------
trees_harvested <- trees_harvested %>% mutate(C_kg_tree = carbon(B_kg_tree))
# HBI dataset including estimated heights (use write.csv2 to make ";" as separator between columns)
write.csv(trees_harvested, paste0(out.path.BZE3, paste(unique(trees_harvested$inv)[1], unique(BZE3_trees_removed$inv)[1], "LT_stock_removed", sep = "_"), ".csv"), row.names = FALSE, fileEncoding = "UTF-8")
#### common/ general operations -------------------------------------------------------------------------------------------------------------------------------------------------------------------
# functions & packages
source(paste0(getwd(), "/scripts/01_00_functions_library.R"))
# extraced wood mass
source(paste0(here(), "/scripts/BZE_III/08_01_LT_extracted_wood_mass_HBI_BZE3.R"))
##DEADWOOD
# deadwood inventory info
DW_inv_info <- read.delim(file = here("data/input/BZE3/be_totholz_punkt.csv"), sep = ",", dec = ".", stringsAsFactors=FALSE)
# ----- 0.1. packages and functions --------------------------------------------
source(paste0(getwd(), "/scripts/01_00_functions_library.R"))
##DEADWOOD
# deadwood inventory info
DW_inv_info <- read.delim(file = here("data/input/BZE3/be_totholz_punkt.csv"), sep = ",", dec = ".", stringsAsFactors=FALSE)
##DEADWOOD
# deadwood inventory info
DW_inv_info <- read.delim(file = here("data/input/BZE3/be_totholz_punkt.csv"), sep = ",", dec = ".", stringsAsFactors=FALSE)
colnames(DW_inv_info) <- c("plot_ID", "CCS_DW_inv_status",  "dist_cm", "azi")
DW_inv_info
# deadwood single item data
DW_data <- read.delim(file = here("data/input/BZE3/be_totholz_liste.csv"), sep = ",", dec = ".") %>%
select( bund_nr, lfd_nr, typ, baumgruppe, anzahl,  durchmesser, laenge, zersetzung)
#  bund_nr lfd_nr typ      baumgruppe anzahl  durchmesser laenge zersetzung
colnames(DW_data) <- c("plot_ID", "tree_ID", "dw_type", "dw_sp", "count", "d_cm", "l_dm", "decay")
DW_data
out.path.BZE3 <- ("output/out_data/out_data_BZE/")
# ----- 0.4 importing data -----------------------------------------------------
## BZE 2
# this dataset contains the BZE file tit_1 which displays info about the BZE inventory in general
# so info that´s base of all sub inventories like trees, deadwood, regeneration
# as we don´t have a  dataset for the current inventory BZE3, we have to use a tit_1 of the previous years. This however, leads to problems with the sortinmg of the plots by plot_status
inv_info <- read.delim(file = here("data/input/BZE2_HBI/tit_1.csv"), sep = ",", dec = ".", stringsAsFactors=FALSE) %>% ##changebacklater BZE3 folder
select(-c("re_form", "re_lage", "neigung", "exposition", "anmerkung"))
colnames(inv_info) <- c("plot_ID", "team", "date", "plot_inv_status")
# create column that just contains year of inventory: https://www.geeksforgeeks.org/how-to-extract-year-from-date-in-r/
inv_info$date <- as.Date(inv_info$date)
inv_info$inv_year <- as.numeric(format(inv_info$date, "%Y"))
inv_info$inv <- inv_name(inv_info$inv_year)
## LIVING TREES
# this dataset contains information about the inventory of the respective individual sampling circuits as well as stand realted info like stand type & - structure
tree_inv_info <-  read.delim(file = here("data/input/BZE3/be.csv"), sep = ",", dec = ".", stringsAsFactors=FALSE) %>% # be
select(bund_nr, team,  datum,  beart, besttyp, struktur,  pk1_aufnahme,   pk2_aufnahme, pk3_aufnahme, hbi_status)
colnames(tree_inv_info) <- c("plot_ID", "team", "date", "stand_spec", "stand_type", "structure", "CCS_5_inv_status",  "CCS_12_inv_status",  "CCS_17_inv_status", "hbi_status")
# create column that just contains year of inventory: https://www.geeksforgeeks.org/how-to-extract-year-from-date-in-r/
tree_inv_info$date <- as.Date(tree_inv_info$date)
tree_inv_info$inv_year <- as.numeric(format(tree_inv_info$date, "%Y"))
# this line can be removed later
tree_inv_info <- tree_inv_info %>% mutate(inv = inv_name(inv_year))
# BZE3 BE dataset: this dataset contains the inventory data of the tree inventory accompanying the second national soil inventory
trees_data <- read.delim(file = here("data/input/BZE3/beab.csv"), sep = ",", dec = ".") %>%
select(bund_nr, lfd_nr, baumkennzahl,zwiesel,bart, alter,alter_methode, d_mess, bhd_hoehe,  hoehe, kransatz, azi, hori, kraft,  schi       )
# BZE3 trees
colnames(trees_data) <- c("plot_ID", "tree_ID", "tree_inventory_status", "multi_stem",  "SP_code", "age", "age_meth", "D_mm", "DBH_h_cm", "H_dm", "C_h_dm", "azi_gon", "dist_cm", "Kraft",  "C_layer")
trees_data <- trees_data %>% dplyr::select(plot_ID,  tree_ID ,  tree_inventory_status ,  multi_stem , dist_cm ,  azi_gon ,
age ,  age_meth ,  SP_code ,  Kraft , C_layer , H_dm ,  C_h_dm , D_mm ,   DBH_h_cm )
# HBI/ BZE2 BEAB dataset
trees_HBI <- read.delim(file = here("data/input/BZE2_HBI/beab.csv"), sep = ",", dec = ".")
# BZE3 trees
colnames(trees_HBI) <- c("plot_ID", "tree_ID", "tree_inventory_status", "multi_stem",  "SP_code", "age", "age_meth", "D_mm", "DBH_h_cm", "H_dm", "C_h_dm", "azi_gon", "dist_cm", "Kraft",  "C_layer")
trees_HBI <- trees_HBI %>% dplyr::select(plot_ID,  tree_ID ,  tree_inventory_status ,  multi_stem , dist_cm ,  azi_gon ,
age ,  age_meth ,  SP_code ,  Kraft , C_layer , H_dm ,  C_h_dm , D_mm ,   DBH_h_cm )
# BZE3 forest edges
forest_edges <- read.delim(file = here("data/input/BZE3/be_waldraender.csv"), sep = ",", dec = ".")
colnames(forest_edges) <- c("plot_ID", "e_ID", "e_type", "e_form", "A_dist", "A_azi",  "B_dist", "B_azi", "T_dist", "T_azi") # t = turning point
## REGENERATION
# this dataset contains the inventory status, position and extend of the sampling circle satelites of the regeneration inventory of the BZE3
RG_loc_info <- read.delim(file = here("data/input/BZE3/bej.csv"), sep = ",", dec = ".", stringsAsFactors=FALSE)
# assign column names    # bund_nr     pk_nr      pk_richtung     pk_dist     pk_aufnahme      pk_maxdist
colnames(RG_loc_info) <- c("plot_ID", "CCS_nr", "CCS_position",  "CCS_dist", "CCS_RG_inv_status", "CCS_max_dist_cm")
# this dataset contains the plant specific inventory data of the regenertaion inventory of the BZE3, including stand and area info
RG_data <- read.delim(file = here("data/input/BZE3/bejb.csv"), sep = ",", dec = "-")
#  "bund_nr"  "pk_nr"  "lfd_nr"   "bart"  "hoehe"    "grklasse"
colnames(RG_data) <- c("plot_ID", "CCS_nr", "tree_ID", "SP_code", "H_cm", "D_class_cm")
##DEADWOOD
# deadwood inventory info
DW_inv_info <- read.delim(file = here("data/input/BZE3/be_totholz_punkt.csv"), sep = ",", dec = ".", stringsAsFactors=FALSE)
colnames(DW_inv_info) <- c("plot_ID", "CCS_DW_inv_status",  "dist_cm", "azi")
# deadwood single item data
DW_data <- read.delim(file = here("data/input/BZE3/be_totholz_liste.csv"), sep = ",", dec = ".") %>%
select( bund_nr, lfd_nr, typ, baumgruppe, anzahl,  durchmesser, laenge, zersetzung)
#  bund_nr lfd_nr typ      baumgruppe anzahl  durchmesser laenge zersetzung
colnames(DW_data) <- c("plot_ID", "tree_ID", "dw_type", "dw_sp", "count", "d_cm", "l_dm", "decay")
# 1. data prep  --------------------------------------
# 1.1. ALL - all plots & stand components ------------------------------------------------------------------------------------------------------------------------
# create a list with the BZE plots that should be excluded -----------------
# select plots that have a "Punktstatus (x_plotstatus_bze)"
plots_to_exclude <- inv_info %>%
filter(plot_inv_status >= 21 | plot_inv_status <0) %>%
select(plot_ID)
plots_to_exclude
# 1.2.1. prepare tree data: add old data to removed trees for stock calculations later ----------------------------------------------------------------
#### this is only for post inventory data, so BZE3 it´s only here in the code to keep the scripts equal
# there may be trees that are labelled as "lost" (removed or died of but for further processing we) by their tree inventory status and by that do not have
# we still need their data from the previous inventory to calcualte their sampling circuit and assing ther species groups etc.
#  dist_cm azi_gon age age_meth SP_code Kraft C_layer H_dm C_h_dm D_mm
if(exists('trees_HBI')== TRUE){
BZE3_trees_old_data <- trees_data %>%
# selectonly trees with inventory status indicating the tree was lost or the status is unknown (eversthing other then 0 or 1)
filter(!(tree_inventory_status %in% c(0,1)))%>%
# then filter for those rows that do not contain the old data of the respective tree that was passed on from the previous inventory
# https://stackoverflow.com/questions/33520854/filtering-data-frame-based-on-na-on-multiple-columns
filter_at(vars(multi_stem:DBH_h_cm),any_vars(is.na(.))) %>%
#replace cells with NA by values from HBI for the respective plot_ID und tree_ID: https://stackoverflow.com/questions/32899580/update-rows-of-data-frame-in-r
rows_patch(trees_HBI %>%
# filter for HBI trees that have the same plot and tree ID as those trees in BZE3 with
# status != c(0, 1) and no old data passed on from HBI by semi_join
semi_join(.,
trees_data %>%
filter(!(tree_inventory_status %in% c(0,1)))%>%
filter_at(vars(multi_stem:DBH_h_cm),any_vars(is.na(.))),
by = c("plot_ID", "tree_ID")) %>%
select(-tree_inventory_status),
by = c("plot_ID", "tree_ID"))
# add trees with "removed" status for which old data was found in HBI to BZE3 trees_data
trees_data <-
trees_data %>%
# 1. remove trees that have a tree_inv_stat indicates they were lost from the trees dataset but have replacement data in
anti_join(., BZE3_trees_old_data, by = c("plot_ID", "tree_ID")) %>%
# 2. add trees that have a "tree was lost" inventory status in BZE3 but have data in: https://dplyr.tidyverse.org/reference/rows.html
rows_insert(., BZE3_trees_old_data, by = c("plot_ID", "tree_ID")) %>%
arrange(plot_ID, tree_ID)
}
# 1.2.2. prepare tree data:species & inventory names -------------------------------------------------------------------------------------------------------------------------------------
trees_data <- trees_data %>%
# join in inventory info
left_join(., tree_inv_info %>% dplyr::select("plot_ID", "inv_year", "inv"), by = "plot_ID")  %>%
# join in the species names from x_bart to ensure the Dahm DBH correction function
left_join(., SP_names_com_ID_tapeS %>%
mutate(char_code_ger_lowcase = tolower(Chr_code_ger)),
by = c("SP_code" = "char_code_ger_lowcase")) %>%
mutate(DBH_h_cm = ifelse(is.na(DBH_h_cm), 130, DBH_h_cm),        # assign DBH measuring height of 130cm when missing
# calculate corrected BDH if measuringheight != 1.3m
DBH_cm = ifelse(DBH_h_cm == 130, as.numeric(D_mm)/10, DBH_Dahm(plot_ID, D_mm, DBH_h_cm, BWI))) %>%
# asssing corect samling circle diameter according to DBH of the tree to be able to join in the right plot area
mutate(CCS_r_m = case_when(DBH_cm >= 7  & DBH_cm < 10 ~ 5.64,
DBH_cm >= 10 & DBH_cm < 30 ~ 12.62,
DBH_cm >= 30 ~ 17.84,
TRUE ~ NA)) %>%
arrange(plot_ID, tree_ID)
# check if there are no trees left that don´t have a SP_code in xBart/ SP_names_com_ID_tapeS
SP_NAs <- trees_data %>%
anti_join(SP_names_com_ID_tapeS %>%
mutate(char_code_ger_lowcase = tolower(Chr_code_ger)),
by = c("SP_code" = "char_code_ger_lowcase"))
if(nrow(SP_NAs) != 0){print("There are species names or codes in the trees dataset that do not match
the species names and codes listed in x_bart")}else{"all fine"}
# save trees to be removed in other dataset
trees_removed <- trees_data %>%
# trees that don´t have a species code or are outside the widest CCS
filter(is.na(SP_code) | is.na(plot_ID) | dist_cm > 1784)
trees_removed
# remove trees without species code or plot ID from the dataset
trees_data <- trees_data %>%
# exclude those trees that don´t have a species code
filter(!(is.na(SP_code)) & !(is.na(plot_ID) ))%>%
# exclude trees outside the widest CCS
filter(dist_cm <= 1784)
# 1.2.3. forest edges dataset ---------------------------------------------
forest_edges <- forest_edges %>%
# join in inventory info
left_join(., tree_inv_info %>% dplyr::select("plot_ID", "inv_year", "inv"), by = "plot_ID")
# 1.3. REGENRATION --------------------------------------------------------
RG_data <- RG_data %>%
# join  in inventory info
left_join(., tree_inv_info %>% select(plot_ID, inv_year, inv), by = "plot_ID") %>%
arrange(plot_ID, CCS_nr, tree_ID)
RG_loc_info <- RG_loc_info %>%
# join  in inventory info
left_join(., tree_inv_info %>% select(plot_ID, inv_year, inv), by = "plot_ID") %>%
arrange(plot_ID, CCS_nr)
# 1.4. DEADWOOD -----------------------------------------------------------
DW_data <- DW_data %>%
# join in inventory info
left_join(., tree_inv_info %>% dplyr::select("plot_ID", "inv_year", "inv"),
by = "plot_ID")
# 2. data processing ------------------------------------------------------------------------------------------------------------------------------------------------------
# 2.2. LIVING TREES -------------------------------------------------------------------------------------------------------------------------------------------------------
# 2.2.1. remove not preocessable plots and sampling circuits form tree_inventory_info dataset ------------------------------------------------------------
tree_inv_info <- tree_inv_info %>%
# remove plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
anti_join(., plots_to_exclude, by = "plot_ID") %>%
# pivoting B, C: https://stackoverflow.com/questions/70700654/pivot-longer-with-names-pattern-and-pairs-of-columns
pivot_longer(., "CCS_5_inv_status":"CCS_17_inv_status", names_to = "CCS_r_m", values_to = "CCS_LT_inv_status") %>%
mutate(CCS_r_m = as.numeric(case_when(CCS_r_m == "CCS_5_inv_status" ~ 5.64,
CCS_r_m == "CCS_12_inv_status" ~ 12.62,
CCS_r_m == "CCS_17_inv_status" ~ 17.84,
TRUE~ NA))) %>%
distinct() %>%
arrange(plot_ID)
# 2.2.2. create dataset with LT CCS to remove from trees data df ------------------------------------------------------------------------------------------------------------------------------------------------------------
# remove CCS that were not inventorable from the trees df and filter NFI (BWI) plots as well
LT_CCS_to_exclude <- tree_inv_info %>% filter(!(CCS_LT_inv_status %in% c(1, 2)) | !(hbi_status %in% c(1,2)) )
LT_CCS_to_exclude
LT_CCS_to_exclude
#  2.2.3. correct CCS_inv_status == 2 if necesarry -------------------------------------------------------------------------------------------------------------------------
# check if CCS_LT_inv_status is actually accurate:
# this means if there is a CCS with status 2 there shouldn´t be any tree in that circuit
tree_inv_info <- tree_inv_info %>%
# remove plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
anti_join(., plots_to_exclude, by = "plot_ID") %>%
# remove plots where one of the three sampling circuits was not inventorable (status == 3)
anti_join(., LT_CCS_to_exclude, by = c("plot_ID", "CCS_r_m", "inv_year", "inv"))
#  2.2.4. creating "empty" LT CCS for status 2 circuits -------------------------------------------------------------------------------------------------------------
#  plot_ID inv_year compartiment  B_t_ha C_t_ha  N_t_ha
# here i create a dataset with DW plots that have status 2
# which only contains info we can catually give so the plot area , the plot ID and the stocks which are set to 0
trees_stat_2 <- as.data.frame(tree_inv_info[tree_inv_info$CCS_LT_inv_status == 2, ])
LT.data.stat.2.list <- vector("list", length = nrow(trees_stat_2))
for (i in 1:nrow(trees_stat_2)) {
# i = 2
my.plot.id <- trees_stat_2[, "plot_ID"][i]
my.ccs.r <- trees_stat_2[, "CCS_r_m"][i]
my.plot.area <- c_A(my.ccs.r)/10000
my.inv.year <- trees_stat_2[, "inv_year"][i]
if(nrow(trees_stat_2) != 0){
LT.staus.2.df <- as.data.frame(cbind(
plot_ID = c(my.plot.id),
CCS_r_m = c(my.ccs.r),
plot_A_ha = c(my.plot.area),
inv_year = c(my.inv.year),
compartiment = c("ag", "bg", "total"),
B_CCS_t_ha = c(0, 0, 0),
C_CCS_t_ha = c(0, 0, 0),
N_CCS_t_ha = c(0, 0, 0),
BA_CCS_m2_ha = c(0, 0, 0),
n_trees_CCS_ha = c(0, 0, 0)))}else{
LT.staus.2.df =  as.data.frame(cbind(
plot_ID = NA,
CCS_r_m = NA,
plot_A_ha = NA,
inv_year = NA,
compartiment = NA,
B_CCS_t_ha = NA,
C_CCS_t_ha = NA,
N_CCS_t_ha = NA,
BA_CCS_m2_ha = NA,
n_trees_CCS_ha = NA))
}
LT.data.stat.2.list[[i]] <- LT.staus.2.df
}
LT_data_stat_2 <- as.data.frame(rbindlist(LT.data.stat.2.list))
#  2.2.5. clearing tree data and prepare for export (beab) ---------------------------------------------------------------------------------------
# by this step we create a dataset that is going to only contain inventorable/ procesabble trees from CCS and plots that are inventorable
trees_update_0 <- trees_data %>%
# select only trees in CCSs that are assigned status 1
# and are already sorted for uninventorable plots (Plotstatus >= 21)
semi_join(., tree_inv_info %>% filter(CCS_LT_inv_status == 1),
by = c("plot_ID", "CCS_r_m", "inv_year", "inv"))
# update trees removed dataset by those trees lost after sorting out CCS status != 1
trees_removed <-
plyr::rbind.fill(
trees_removed,
trees_data %>%
semi_join(., tree_inv_info %>% filter(CCS_LT_inv_status != 1),
by = c("plot_ID", "CCS_r_m", "inv_year", "inv"))
)
#  2.2.6. clearing forest edges dataset and prepare for export (waldraender.csv) ---------------------------------------------------------------------------------------
forest_edges_update_1 <- forest_edges %>%
# here we remove those plots from the edges dataset that are not analysed for the HBI/ BZE3
# we cannot sort for LT_CCS_inv_status in trees_inv_info because there may be plots that have RG (which can be alllocated to stands) but no LT yet
anti_join(., plots_to_exclude,  by = c("plot_ID")) %>%
# remove plots with inv_name "waring" as they are not suitable for further processing
filter(inv != "warning")
# 2.2.7. create dataset with NFI plots/ BWI plots -------------------------
trees_BWI <- trees_data %>%
semi_join(LT_CCS_to_exclude %>% filter(hbi_status == 3),
by = c("plot_ID", "CCS_r_m", "inv_year", "inv"))
# 2.3.1. create dataset with RG CCS that are not processable  ------------------------------------------------------------
RG_CCS_to_exclude <- RG_loc_info %>%
# remove plots where one of the four sampling circuits was not inventorable
filter(!(CCS_RG_inv_status %in% c(1, 2)))
# 2.3.2. remove not processable plots and sampling circuits form RG_loc_info dataset ------------------------------------------------------------
RG_loc_info <- RG_loc_info %>%
distinct() %>%
# remove plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
anti_join(., plots_to_exclude, by = "plot_ID") %>%
# exclude non inventoryble RG CCS
anti_join(., RG_CCS_to_exclude, by = c("plot_ID", "CCS_nr", "inv_year", "inv")) %>%
arrange(plot_ID, CCS_nr) %>%
# change the maximum distance to the default setting of 500cm if its NA or -9
mutate(CCS_max_dist_cm = ifelse(is.na(CCS_max_dist_cm) |
CCS_max_dist_cm == -9 |
CCS_RG_inv_status == 2, 500, CCS_max_dist_cm))
RG_CCS_to_exclude
#  2.3.4. creating "empty" RG CCS for status 2 circuits ----------------------
# here i create a dataset with RG plots that have status 2
# which only contains info we can catually give so the plot area , the plot ID and the stocks which are set to 0
RG_stat_2 <- RG_loc_info[RG_loc_info$CCS_RG_inv_status == 2, ]
RG.data.stat.2.list <- vector("list", length = nrow(RG_stat_2))
for (i in 1:nrow(RG_stat_2)) {
# i = 1
my.plot.id <- RG_stat_2[, "plot_ID"][i]
my.ccs.no <- RG_stat_2[, "CCS_nr"][i]
my.plot.area <- (c_A(as.numeric(RG_stat_2[, "CCS_max_dist_cm"][i])/100))/10000 # plot are in hectar
my.inv.year <- RG_stat_2[, "inv_year"][i]
if(nrow(RG_stat_2) != 0){
RG.status.2.df <- as.data.frame(cbind(
plot_ID = c(my.plot.id),
CCS_nr = c(my.ccs.no),
plot_A_ha = c(my.plot.area),
inv_year = c(my.inv.year),
compartiment = c("ag", "bg", "total"),
B_t_ha = c(0, 0, 0),
C_t_ha = c(0, 0, 0),
N_t_ha = c(0, 0, 0)))
}else{
RG.status.2.df = as.data.frame(cbind(
plot_ID = NA,
CCS_nr = NA,
plot_A_ha = NA,
inv_year = NA,
compartiment = NA,
B_t_ha = NA,
C_t_ha = NA,
N_t_ha = NA))
}
RG.data.stat.2.list[[i]] <- RG.status.2.df
}
RG_data_stat_2 <- as.data.frame(rbindlist(RG.data.stat.2.list))
#  2.3.5. clearing tree data and prepare for export (beab) ---------------------------------------------------------------------------------------
# after this step there are only RG plants remaining which are locate in inventorable and processable CCS
RG_removed <- RG_data %>% # select only RG plants in circles remove plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
semi_join(., RG_loc_info %>% filter(CCS_RG_inv_status != 1), by = c("plot_ID", "CCS_nr"))
RG_update_1 <- RG_data %>%
# select only RG plants in circles remove plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
semi_join(., RG_loc_info %>% filter(CCS_RG_inv_status == 1), by = c("plot_ID", "CCS_nr", "inv_year", "inv"))
# 2.4. DW dataset --------------------------------------------------------------------------------------------------------------------------------
# 2.4.1. remove not process able plots and sampling circuits form DW_inv_info data set ------------------------------------------------------------
DW_inv_info <- DW_inv_info %>%
# join  in inventory info
left_join(., tree_inv_info %>% select(plot_ID, inv_year, inv), by = c("plot_ID"), multiple = "all" ) %>%
# remove plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
anti_join(., plots_to_exclude, by = "plot_ID") %>%
mutate(plot_A_ha = case_when(CCS_DW_inv_status == 4 ~ (c_A(data_circle$r0[2])/10000)*0.5,
CCS_DW_inv_status == 5 ~ (c_A(data_circle$r0[2])/10000)*0.25,
TRUE ~  (c_A(data_circle$r0[2])/10000)))
# 2.4.2. create dataset with CCS that are not  ------------------------------------------------------------
DW_CCS_to_exclude <- DW_inv_info %>%
# remove plots where one of the four sampling circuits was not inventorable: so status -9. -1, 4
filter(!(CCS_DW_inv_status %in% c(1,2, 4, 5)))
# 2.4.3. correcting status 2 circles that actually have trees ------------------------------------------------------------------
DW_inv_info <-  DW_inv_info%>%
# remove plots from dataset where non of the inventories was carried out at the NSI (BZE) inventory ("Ausfall")
anti_join(., plots_to_exclude, by = "plot_ID") %>%
# remove CCS with inv status 3
anti_join(., DW_CCS_to_exclude, by = c("plot_ID", "inv_year", "inv")) %>%
distinct()
DW_CCS_to_exclude
# ----- 0.1. packages and functions --------------------------------------------
source(paste0(getwd(), "/scripts/01_00_functions_library.R"))
##DEADWOOD
# deadwood inventory info
DW_inv_info <- read.delim(file = here("data/input/BZE2_HBI/be_totholz_punkt.csv"), sep = ",", dec = ".", stringsAsFactors=FALSE)
colnames(DW_inv_info) <- c("plot_ID", "CCS_DW_inv_status",  "dist_cm", "azi")
DW_inv_info
# deadwood single item data
DW_data <- read.delim(file = here("data/input/BZE2_HBI/be_totholz_liste.csv"), sep = ",", dec = ".") %>%
select( bund_nr, lfd_nr, typ, baumgruppe, anzahl,  durchmesser, laenge, zersetzung)
#  bund_nr lfd_nr typ      baumgruppe anzahl  durchmesser laenge zersetzung
colnames(DW_data) <- c("plot_ID", "tree_ID", "dw_type", "dw_sp", "count", "d_cm", "l_dm", "decay")
DW_data

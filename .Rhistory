c.rmax = 300
# extract polar coordiantes of forest edge
# point A
dist.A <- forest_edges_HBI.man.sub.e2.nogeo[i, "A_dist"]
azi.A <- forest_edges_HBI.man.sub.e2.nogeo[i, "A_azi"]
x.A <- dist.A*sin(azi.A)   # longitude, easting, RW, X
y.A <- dist.A*cos(azi.A)   # latitude, northing, HW, y
# point B
dist.B <- forest_edges_HBI.man.sub.e2.nogeo[i, "B_dist"]
azi.B <- forest_edges_HBI.man.sub.e2.nogeo[i, "B_azi"]
x.B <- dist.B*sin(azi.B)   # longitude, easting, RW, X
y.B <- dist.B*cos(azi.B)   # latitude, northing, HW, y
# point T
dist.T <- forest_edges_HBI.man.sub.e2.nogeo[i, "T_dist"]
azi.T <- forest_edges_HBI.man.sub.e2.nogeo[i, "T_azi"]
x.T <- dist.T*sin(azi.T)   # longitude, easting, RW, X
y.T <- dist.T*cos(azi.T)   # latitude, northing, HW, y
b0.AT = intercept(x.T, y.T, x.A, y.A)
b1.AT = slope(x.T, y.T, x.A, y.A)
b0.BT = intercept(x.T, y.T, x.B, y.B)
b1.BT = slope(x.T, y.T, x.B, y.B)
# select polar coordiantes of the points of the triangle corners via "inter_for_triangle"-function
# for AT side
AT.x <- inter.for.triangle(b0.AT, b1.AT,c.x0, c.y0, c.rmax, x.A, y.A, x.T, y.T, coordinate = "x")                              # longitude, easting, RW, X
AT.y <- inter.for.triangle(b0.AT, b1.AT, c.x0, c.y0, c.rmax, x.A, y.A, x.T, y.T, coordinate = "y")                              # latitude, northing, HW, y
# for BT side
BT.x <- inter.for.triangle(b0.BT, b1.BT, c.x0, c.y0, c.rmax, x.B, y.B, x.T, y.T, coordinate = "x")                              # longitude, easting, RW, X
BT.y <- inter.for.triangle(b0.BT, b1.BT, c.x0, c.y0, c.rmax, x.B, y.B, x.T, y.T, coordinate = "y")                              # latitude, northing, HW, y
#calculate UTM coordiantes of triangle corners
T.east <- x.T        + my.center.easting                             # longitude, easting, RW, X
T.north <- y.T       + my.center.northing                           # latitude, northing, HW, y
AT.x.east <-  AT.x   + my.center.easting                        # longitude, easting, RW, X
AT.y.north <- AT.y   + my.center.northing                       # latitude, northing, HW, y
BT.x.east <- BT.x    + my.center.easting                        # longitude, easting, RW, X
BT.y.north <- BT.y   + my.center.northing                       # latitude, northing, HW, y
# create dataframe with triangle corner UTM coordiantes
triangle.e2.df <- as.data.frame(cbind("lon" = c(T.east, AT.x.east, BT.x.east, T.east),       # longitude, easting, RW, X
"lat" = c(T.north, AT.y.north, BT.y.north, T.north),   # latitude, northing, HW, y
"plot_ID" =  c(my.plot.id, my.plot.id, my.plot.id, my.plot.id),
"e_ID" = c(my.e.id, my.e.id, my.e.id, my.e.id )))
# createa polygone with triangle corners via sf package: https://r-spatial.github.io/sf/reference/st.html
triangle.e2.poly <- sfheaders::sf_polygon(obj = triangle.e2.df
, x = "lon"
, y = "lat"
, polygon_id = "e_ID")
## select crs
my.utm.epsg <-  paste0("+proj=utm +zone=", pick_utm(my.center.easting)," ", "+datum=WGS84 +units=m +no_defs +type=crs")
# assing crs
sf::st_crs(triangle.e2.poly) <- my.utm.epsg
# print triangle
print(plot(triangle.e2.poly$geometry, main = my.plot.id))
# save polygones in list
triangle.e2.list.nogeo[[i]] <- c("plot_ID" = my.plot.id, triangle.e2.poly)
# save coordiantes of polygones in list
triangle.e2.coords.nogeo[[i]] <- triangle.e2.df
}
# list of polygones
triangle.e2.list.final.nogeo <- rbindlist(triangle.e2.list.nogeo)
triangle.e2.poly.df.nogeo <- as.data.frame(triangle.e2.list.final.nogeo) %>% mutate("e_form" = 2)
#list of coordiantes of triangle.e2 polygones
triangle.e2.coords.list.nogeo <- rbindlist(triangle.e2.coords.nogeo)
triangle.e2.coords.df.nogeo <- as.data.frame(triangle.e2.coords.list.nogeo) %>%  mutate("e_form" = 2)
triangle.e2.poly.df.nogeo
# dataprep for loop
# bind polygone dataframes together
edge.poly.df.nogeo <- rbind(triangle.e1.poly.df.nogeo, triangle.e2.poly.df.nogeo) # rows: 83
# createa dataframe with plots that have only one forest edges
forest_edges_HBI.man.sub.1.edge.nogeo <- forest_edges_HBI.man %>% # rows:84
# select only plots with a known edge form and for edge 2 only those that actually intersect the 17m circle
filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%  # rows:81
# remove plots that have two edges
anti_join(forest_edges_HBI.man %>%  filter(e_form == 1 | e_form == 2 & inter_status_AT_17 == "two I" | e_form == 2 & inter_status_BT_17 == "two I") %>%
group_by(plot_ID) %>% summarise(n = n()) %>% filter(n > 1) %>% select(plot_ID), by = "plot_ID") %>% # 14 plots with 2 edges --> 28 rows -> 53 left
## remove plots that do now have a corresponding center coordiante in the HBI loc document
semi_join(HBI_loc %>% filter(!is.na( RW_MED) & !is.na(HW_MED)) %>%  select(plot_ID)  %>% distinct(), by = "plot_ID") # nrow = 52 --> there is 1 plots without corresponding
edges.list.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.1.edge.nogeo$plot_ID)))
inter.poly.list.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.1.edge.nogeo$plot_ID)))
#inter.poly.NA.list <- vector("list", length = length(unique(forest_edges_HBI.man.sub.1.edge$plot_ID)))
remaining.circle.poly.list.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.1.edge.nogeo$plot_ID)))
remaining.circle.multipoly.list.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.1.edge.nogeo$plot_ID)))
i = 4
# select plot ID of the respective circle
my.plot.id <- forest_edges_HBI.man.sub.1.edge.nogeo[i, "plot_ID"]
my.e.form <- edge.poly.df.nogeo$e_form[edge.poly.df.nogeo$plot_ID == my.plot.id]
my.e.id <- edge.poly.df.nogeo$e_ID[edge.poly.df.nogeo$plot_ID == my.plot.id]
# select UTM corrdinates of the plot center
my.center.easting <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "RW_MED"]
my.center.northing <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "HW_MED"]
my.center.easting
my.center.northing
## select crs
my.utm.epsg <-  paste0("+proj=utm +zone=", pick_utm(my.center.easting)," ", "+datum=WGS84 +units=m +no_defs +type=crs")
my.utm.epsg
# circle data
c.x0 = 0 # + my.center.easting
c.y0 = 0 # + my.center.northing
# circle data
c.x0 = 0 + my.center.easting
c.y0 = 0  + my.center.northing
c.r3 = 17.84
c.r2 = 12.62
c.r1 = 5.64
center.df<- as.data.frame(cbind("lon" = c.x0, "lat" = c.y0))
# build polygon (circlular buffer) around center point
circle.pt <- sf::st_as_sf(center.df, coords = c("lon", "lat"))
circle.17 <- sf::st_buffer(circle.pt, c.r3)
circle.12 <- sf::st_buffer(circle.pt, c.r2)
circle.5 <- sf::st_buffer(circle.pt, c.r1)
## assing crs to cirlces
sf::st_crs(circle.pt) <- my.utm.epsg
## assing crs to cirlces
sf::st_crs(circle.pt) <- my.utm.epsg
circle.pt
circle.17 <- sf::st_buffer(circle.pt, c.r3)
circle.12 <- sf::st_buffer(circle.pt, c.r2)
circle.5 <- sf::st_buffer(circle.pt, c.r1)
circle.17
## select the respective polygones the circle is intersected by
my.poly <- sf::st_as_sf(edge.poly.df.nogeo %>% filter(plot_ID == my.plot.id))
edge.poly.df.nogeo
## select the respective polygones the circle is intersected by
my.poly <- sf::st_as_sf(edge.poly.df.nogeo %>% filter(plot_ID == my.plot.id))
my.poly
# print the cirlce and edge polygone
print(plot(circle.17, main = paste0("plot:", " ", my.plot.id, ",", " ", "e_form:"," ", my.e.form)),
plot(my.poly, col = 0, add = T))
#### 17m circle
# calculate intersection for 17m circle
inter.poly.17  <- sf::st_intersection(circle.17, my.poly)
inter.poly.17
inter.status.poly.17 <- ifelse(nrow(inter.poly.17) == 0, "no intersections",
ifelse(my.e.form == 1 & inter.poly.17$geometry == circle.17$geometry,  "no intersections",
ifelse(my.e.form == 2 & inter.poly.17$geometry == circle.17$geometry, "fully covering circle",
"partly intersecting")))
inter.status.poly.17
# this is just to remove all the additional attributes from the intersection polygone
#inter.poly  <- sf::st_intersection(circle.17, st_geometry(my.poly))
# if the ednge covers all of the circle remaining, the inter.polygone its going to be set to 0 so we know there are no direct intersections
inter.poly.17 <- if(isTRUE(inter.poly.17) && inter.poly.17$geometry == circle.17$geometry){inter.poly.17 <- data.frame()}else{inter.poly.17}
inter.poly.17
# if the edge-circle intersection is equal to 0 (so there is no intersection) return the whole cirlce as remaining circle area, else calculate the remaining circle by decuctng the intersection are from the circle area
remaining.circle.poly.17  <- if(isTRUE(nrow(inter.poly.17)==0)){circle.17}else{sf::st_difference(circle.17, inter.poly.17)}
remaining.circle.poly.17
# calculate area
# intersection
inter.area.17 <- ifelse(nrow(inter.poly.17) == 0, 0, sf::st_area(inter.poly.17))
#remaining circle
remaining.circle.area.17 <- ifelse(nrow(remaining.circle.poly.17) == 0, 0, sf::st_area(remaining.circle.poly.17))
# create area dataframe for areas
inter.area.df.17 <- as.data.frame(cbind("plot_ID" = c(my.plot.id, my.plot.id), "e_ID" = c(my.e.id,  0),
# "e_form" = c(my.e.form, 0),
#"shape" = c("edge", "circle"),
"CCS_r_m" = c(c.r3, c.r3), "inter_stat" = c(inter.status.poly.17, 0),
"area_m2" = c(inter.area.17, remaining.circle.area.17)))
##### 12m circle
# calculate intersection for 17m circle
inter.poly.12  <- sf::st_intersection(circle.12, my.poly)
inter.status.poly.12 <- ifelse(nrow(inter.poly.12) == 0, "no intersections",
ifelse(my.e.form == 1 & inter.poly.12$geometry == circle.12$geometry,  "no intersections",
ifelse(my.e.form == 2 & inter.poly.12$geometry == circle.12$geometry, "fully covering circle",
"partly intersecting")))
# this is just to remove all the additional attributes from the intersection polygone
#inter.poly  <- sf::st_intersection(circle.17, st_geometry(my.poly))
# if the ednge covers all of the circle remaining, the inter.polygone its going to be set to 0 so we know there are no direct intersections
inter.poly.12 <- if(isTRUE(inter.poly.12) && inter.poly.12$geometry == circle.12$geometry){inter.poly.12 <- data.frame()}else{inter.poly.12}
# if the edge-circle intersection is equal to 0 (so there is no intersection) return the whole cirlce as remaining circle area, else calculate the remaining circle by decuctng the intersection are from the circle area
remaining.circle.poly.12  <- if(isTRUE(nrow(inter.poly.12)==0)){circle.12}else{sf::st_difference(circle.12, inter.poly.12)}
# calculate area
# intersection
inter.area.12 <- ifelse(nrow(inter.poly.12) == 0, 0, sf::st_area(inter.poly.12))
#remaining circle
remaining.circle.area.12 <- ifelse(nrow(remaining.circle.poly.12) == 0, 0, sf::st_area(remaining.circle.poly.12))
# create area dataframe for areas
inter.area.df.12 <- as.data.frame(cbind("plot_ID" = c(my.plot.id, my.plot.id), "e_ID" = c(my.e.id,  0),
# "e_form" = c(my.e.form, 0),
#"shape" = c("edge", "circle"),
"CCS_r_m" = c(c.r2, c.r2),"inter_stat" = c(inter.status.poly.12, 0),
"area_m2" = c(inter.area.12, remaining.circle.area.12)))
##### 5m circle
# calculate intersection for 17m circle
inter.poly.5  <- sf::st_intersection(circle.5, my.poly)
inter.status.poly.5 <- ifelse(nrow(inter.poly.5) == 0, "no intersections",
ifelse(my.e.form == 1 & inter.poly.5$geometry == circle.5$geometry,  "no intersections",
ifelse(my.e.form == 2 & inter.poly.5$geometry == circle.5$geometry, "fully covering circle",
"partly intersecting")))
# this is just to remove all the additional attributes from the intersection polygone
#inter.poly  <- sf::st_intersection(circle.17, st_geometry(my.poly))
# if the ednge covers all of the circle remaining, the inter.polygone its going to be set to 0 so we know there are no direct intersections
inter.poly.5 <- if(isTRUE(inter.poly.5) && inter.poly.5$geometry == circle.5$geometry){inter.poly.5 <-data.frame()}else{inter.poly.5}
# if the edge-circle intersection is equal to 0 (so there is no intersection) return the whole cirlce as remaining circle area, else calculate the remaining circle by decuctng the intersection are from the circle area
remaining.circle.poly.5  <- if(isTRUE(nrow(inter.poly.5)==0)){circle.5}else{sf::st_difference(circle.5, inter.poly.5)}
# calculate area
# intersection
inter.area.5 <- ifelse(nrow(inter.poly.5) == 0, 0, sf::st_area(inter.poly.5))
#remaining circle
remaining.circle.area.5 <- ifelse(nrow(remaining.circle.poly.5) == 0, 0, sf::st_area(remaining.circle.poly.5))
# create area dataframe for areas
inter.area.df.5 <- as.data.frame(cbind("plot_ID" = c(my.plot.id, my.plot.id), "e_ID" = c(my.e.id,  0),
# "e_form" = c(my.e.form, 0),
#"shape" = c("edge", "circle"),
"CCS_r_m" = c(c.r1, c.r1),"inter_stat" = c(inter.status.poly.5, 0),
"area_m2" = c(inter.area.5, remaining.circle.area.5)))
# bind area dataframes together
inter.area.df <- rbind(inter.area.df.17, inter.area.df.12, inter.area.df.5)
# assing stand to the edges depedning on area
stand.df <- inter.area.df%>%
filter(CCS_r_m  == 17.84) %>%
mutate(area_m2 = as.numeric(area_m2)) %>%
group_by(plot_ID) %>%
arrange(area_m2) %>%
# lowest area receives stand ID C, then B, then A
mutate(stand = case_when(
row_number()== 1 ~ "B",
row_number()== 2 ~ "A",
TRUE ~ NA)) %>%
# make stand.df joinable by only leaving plot_ID, e_ID, no matter the diameter of the CCS
select(- c(CCS_r_m, inter_stat, area_m2))
stand.df
# join in stand info based on area of the edge segment by plot and edge ID
inter.area.df <- inter.area.df %>% left_join(., stand.df,
by = c("plot_ID", "e_ID"))
inter.area.df
# testing if corect inter was saved:
i.plot <- if(isTRUE(nrow(inter.poly.17)!= 0)){c(inter.poly.17)}else{c(my.poly)}
# save remaining circles polygones into list
#plot(remaining.circle.poly.17)
remaining.circle.poly.17$plot_ID <- my.plot.id
plot(i.plot$geometry)
plot(circle.17, add = T)
# 3.2.1.3.1. loop for intersections for plots with two edges ----------------------------------------------------------------------------------------------------------------------------
# dataprep for loop
# createa dataframe with plots that have only one forest edges
forest_edges_HBI.man.sub.2.edges.nogeo <- forest_edges_HBI.man %>% # rows:84
# select only plots with a known edge form and for edge 2 only those that actually intersect the 17m circle
filter(e_form == 1 |
e_form == 2 & inter_status_AT_17 == "two I" |
e_form == 2 & inter_status_BT_17 == "two I") %>%  # rows:81
#filter(inter_status_AB_17 == "two I") %>%
# remove plots that have two edges
semi_join(forest_edges_HBI.man %>% filter(e_form == 1 |
e_form == 2 & inter_status_AT_17 == "two I" |
e_form == 2 & inter_status_BT_17 == "two I") %>%
group_by(plot_ID) %>% summarise(n = n()) %>% filter(n > 1) %>% select(plot_ID), by = "plot_ID") #%>% # 14 plots iwth 2 edges --> 28 rows
# prepare output lists
# list to save areas in
edges.list.two.edges.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.2.edges.nogeo$plot_ID)))
# list to save the first intersection polygone per plot in
inter.poly.1.list.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.2.edges.nogeo$plot_ID)))
# list to save the second intersection polygone per plot in
inter.poly.2.list.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.2.edges.nogeo$plot_ID)))
# list to save the remaining circle polygones per plot in
rem.circle.poly.2.edges.list.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.2.edges.nogeo$plot_ID)))
# list to save the remaining circle MULTIpolygones per plot in
rem.circle.multipoly.2.edges.list.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.2.edges.nogeo$plot_ID)))
# list for plop IDs of those plots where the edge lines/ polygones intersect within the 17.84m circle
intersection.warning.edges.list.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.2.edges.nogeo$plot_ID)))
# 3.2.1.3.1. loop for intersections for plots with two edges ----------------------------------------------------------------------------------------------------------------------------
# dataprep for loop
# createa dataframe with plots that have only one forest edges
forest_edges_HBI.man.sub.2.edges.nogeo <- forest_edges_HBI.man %>% # rows:84
# select only plots with a known edge form and for edge 2 only those that actually intersect the 17m circle
filter(e_form == 1 |
e_form == 2 & inter_status_AT_17 == "two I" |
e_form == 2 & inter_status_BT_17 == "two I") %>%  # rows:81
#filter(inter_status_AB_17 == "two I") %>%
# remove plots that have two edges
semi_join(forest_edges_HBI.man %>% filter(e_form == 1 |
e_form == 2 & inter_status_AT_17 == "two I" |
e_form == 2 & inter_status_BT_17 == "two I") %>%
group_by(plot_ID) %>% summarise(n = n()) %>% filter(n > 1) %>% select(plot_ID), by = "plot_ID") %>% # 14 plots iwth 2 edges --> 28 rows
# remove plots that do now have a corresponding center coordiante in the HBI loc document
semi_join(HBI_loc %>% filter(!is.na( RW_MED) & !is.na(HW_MED)) %>%  select(plot_ID)  %>% distinct(), by = "plot_ID") # nrow = 28
# prepare output lists
# list to save areas in
edges.list.two.edges.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.2.edges.nogeo$plot_ID)))
# list to save the first intersection polygone per plot in
inter.poly.1.list.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.2.edges.nogeo$plot_ID)))
# list to save the second intersection polygone per plot in
inter.poly.2.list.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.2.edges.nogeo$plot_ID)))
# list to save the remaining circle polygones per plot in
rem.circle.poly.2.edges.list.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.2.edges.nogeo$plot_ID)))
# list to save the remaining circle MULTIpolygones per plot in
rem.circle.multipoly.2.edges.list.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.2.edges.nogeo$plot_ID)))
# list for plop IDs of those plots where the edge lines/ polygones intersect within the 17.84m circle
intersection.warning.edges.list.nogeo <- vector("list", length = length(unique(forest_edges_HBI.man.sub.2.edges.nogeo$plot_ID)))
i = 1
# select plot ID of the respective circle
my.plot.id <- unique(forest_edges_HBI.man.sub.2.edges.nogeo$plot_ID)[i]
my.plot.id
# select the UTM coordiantes of the center of the cirlce corresponding with the plot ID
my.center.easting <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "RW_MED"]
my.center.northing <- HBI_loc[HBI_loc$plot_ID == my.plot.id, "HW_MED"]
#### build circle
# circle data
c.x0 = 0    + my.center.easting
c.y0 = 0   + my.center.northing
c.r3 = 17.84
c.r2 = 12.62
c.r1 = 5.64
# build polygon (circlular buffer) around center point
center.df<- as.data.frame(cbind("lon" = c.x0, "lat" = c.y0))
circle.pt <- sf::st_as_sf(center.df, coords = c("lon", "lat"))
## assing crs to cirlce corodiantes
sf::st_crs(circle.pt) <- my.utm.epsg
circle.17 <- sf::st_buffer(circle.pt, c.r3)
circle.12 <- sf::st_buffer(circle.pt, c.r2)
circle.5 <- sf::st_buffer(circle.pt, c.r1)
#### select the  polygones the circle is intersected by
# select the polygones with the same plot ID as the cirlce
my.plot.polys.df <- edge.poly.df.nogeo %>% filter(plot_ID == my.plot.id) %>% arrange(e_ID)
my.plot.polys.df
# create the polygones of the edge geometries
my.poly.1 <- sf::st_as_sf(my.plot.polys.df[1,])
my.poly.2 <- sf::st_as_sf(my.plot.polys.df[2,])
my.poly.1
my.poly.2 <- sf::st_as_sf(my.plot.polys.df[2,])
my.poly.2
# select edge ID of edge polygones
my.e.id.1 <- my.plot.polys.df$e_ID[1]
my.e.id.2 <- my.plot.polys.df$e_ID[2]
# select edge form of the respective edge polygones
my.e.form.1 <- my.plot.polys.df$e_form[1]
my.e.form.2 <- my.plot.polys.df$e_form[2]
print(plot(circle.17$geometry),
plot(my.poly.1$geometry,  add = T),
plot(my.poly.2$geometry, add = T))
#### intersections between polygones and circles
### 17m circle
my.circle = circle.17
## create poolygon of intersection for first polygon with circle
inter.poly.17.1  <- st_intersection(my.circle, my.poly.1)
inter.status.poly.17.1 <- ifelse(nrow(inter.poly.17.1) == 0, "no intersections",
ifelse(my.e.form.1 == 1 & inter.poly.17.1$geometry == my.circle$geometry,  "no intersections",
ifelse(my.e.form.1 == 2 & inter.poly.17.1$geometry == my.circle$geometry, "fully covering circle",
"partly intersecting")))
# if the first ednge covers all of the circle remaining its going to be set to 0 so we know there are no direct intersections and the circle is passed on to the next edge to calcualte the intersection
# https://www.statology.org/r-argument-is-of-length-zero/
inter.poly.17.1 <- if(isTRUE(inter.poly.17.1) && inter.poly.17.1$geometry == my.circle$geometry){inter.poly.17.1 <- data.frame()}else{inter.poly.17.1}
inter.poly.17.1
## create poolygon of remaining circle after first edge polygone is intersected
# create poly with remaining area: https://gis.stackexchange.com/questions/353633/r-spatial-erase-one-polygon-from-another-correct-use-of-st-difference
remaining.circle.17.1 <- if(nrow(inter.poly.17.1)==0){my.circle}else{sf::st_difference(my.circle, inter.poly.17.1)}
remaining.circle.17.1
## create polygone of intersecting area of second polygone with remaining circle
inter.poly.17.2 <- st_intersection(my.poly.2, st_geometry(remaining.circle.17.1))
inter.status.poly.17.2 <- ifelse(nrow(inter.poly.17.2) == 0, "no intersections",
ifelse(my.e.form.2== 1 & inter.poly.17.2$geometry == remaining.circle.17.1$geometry,  "no intersections",
ifelse(my.e.form.2 == 2 & inter.poly.17.2$geometry == remaining.circle.17.1$geometry, "fully covering circle",
"partly intersecting")))
# if the second edge covers all of the circle remaining its going to be set to 0 so we know there are no direct intersections
# https://www.statology.org/r-argument-is-of-length-zero/
inter.poly.17.2 <- if(isTRUE(inter.poly.17.2) && inter.poly.17.2$geometry == remaining.circle.17.1$geometry){inter.poly.17.2 <- data.frame()}else{inter.poly.17.2}
## create polygone of the  remaining cricle after both intersects are decucted
# so the area of the frst remining circle minus the area of the second remaining circle
remaining.circle.17.1.and.2.poly <- if(nrow(inter.poly.17.2)==0){remaining.circle.17.1}else{sf::st_difference(remaining.circle.17.1, inter.poly.17.2)}
remaining.circle.17.1.and.2.poly
inter.poly.17.2
## create polygone of the  remaining cricle after both intersects are decucted
# so the area of the frst remining circle minus the area of the second remaining circle
remaining.circle.17.1.and.2.poly <- if(nrow(inter.poly.17.2)==0){remaining.circle.17.1}else{sf::st_difference(remaining.circle.17.1, inter.poly.17.2)}
### 12m circle
my.circle = circle.12
## create poolygon of intersection for first polygon with circle
inter.poly.12.1  <- st_intersection(my.circle, my.poly.1)
inter.status.poly.12.1 <- ifelse(nrow(inter.poly.12.1) == 0, "no intersections",
ifelse(my.e.form.1 == 1 & inter.poly.12.1$geometry == my.circle$geometry,  "no intersections",
ifelse(my.e.form.1 == 2 & inter.poly.12.1$geometry == my.circle$geometry, "fully covering circle",
"partly intersecting")))
# if the first ednge covers all of the circle remaining its going to be set to 0 so we know there are no direct intersections and the circle is passed on to the next edge to calcualte the intersection
# https://www.statology.org/r-argument-is-of-length-zero/
inter.poly.12.1 <- if(isTRUE(inter.poly.12.1) && inter.poly.12.1$geometry == my.circle$geometry){inter.poly.12.1 <- data.frame()}else{inter.poly.12.1}
## create poolygon of remaining circle after first edge polygone is intersected
# create poly with remaining area: https://gis.stackexchange.com/questions/353633/r-spatial-erase-one-polygon-from-another-correct-use-of-st-difference
remaining.circle.12.1 <- if(nrow(inter.poly.12.1)==0){my.circle}else{sf::st_difference(my.circle, inter.poly.12.1)}
## create polygone of intersecting area of second polygone with remaining circle
inter.poly.12.2 <- st_intersection(my.poly.2, st_geometry(remaining.circle.12.1))
inter.status.poly.12.2 <- ifelse(nrow(inter.poly.12.2) == 0, "no intersections",
ifelse(my.e.form.2== 1 & inter.poly.12.2$geometry == remaining.circle.12.1$geometry,  "no intersections",
ifelse(my.e.form.2 == 2 & inter.poly.12.2$geometry == remaining.circle.12.1$geometry, "fully covering circle",
"partly intersecting")))
# if the second edge covers all of the circle remaining its going to be set to 0 so we know there are no direct intersections
# https://www.statology.org/r-argument-is-of-length-zero/
inter.poly.12.2 <- if(isTRUE(inter.poly.12.2) && inter.poly.12.2$geometry == remaining.circle.12.1$geometry){inter.poly.12.2 <- data.frame()}else{inter.poly.12.2}
## create polygone of the  remaining cricle after both intersects are decucted
# so the area of the frst remining circle minus the area of the second remaining circle
remaining.circle.12.1.and.2.poly <- if(nrow(inter.poly.12.2)==0){remaining.circle.12.1}else{sf::st_difference(remaining.circle.12.1, inter.poly.12.2)}
### 5m circle
my.circle = circle.5
## create poolygon of intersection for first polygon with circle
inter.poly.5.1  <- st_intersection(my.circle, my.poly.1)
inter.status.poly.5.1 <- ifelse(nrow(inter.poly.5.1) == 0, "no intersections",
ifelse(my.e.form.1 == 1 & inter.poly.5.1$geometry == my.circle$geometry,  "no intersections",
ifelse(my.e.form.1 == 2 & inter.poly.5.1$geometry == my.circle$geometry, "fully covering circle",
"partly intersecting")))
# if the first ednge covers all of the circle remaining its going to be set to 0 so we know there are no direct intersections and the circle is passed on to the next edge to calcualte the intersection
# https://www.statology.org/r-argument-is-of-length-zero/
inter.poly.5.1 <- if(isTRUE(inter.poly.5.1) && inter.poly.5.1$geometry == my.circle$geometry){inter.poly.5.1 <- data.frame()}else{inter.poly.5.1}
## create poolygon of remaining circle after first edge polygone is intersected
# create poly with remaining area: https://gis.stackexchange.com/questions/353633/r-spatial-erase-one-polygon-from-another-correct-use-of-st-difference
remaining.circle.5.1 <- if(nrow(inter.poly.5.1)==0){my.circle}else{sf::st_difference(my.circle, inter.poly.5.1)}
## create polygone of intersecting area of second polygone with remaining circle
inter.poly.5.2 <- st_intersection(my.poly.2, st_geometry(remaining.circle.5.1))
inter.status.poly.5.2 <- ifelse(nrow(inter.poly.5.2) == 0, "no intersections",
ifelse(my.e.form.2== 1 & inter.poly.5.2$geometry == remaining.circle.5.1$geometry,  "no intersections",
ifelse(my.e.form.2 == 2 & inter.poly.5.2$geometry == remaining.circle.5.1$geometry, "fully covering circle",
"partly intersecting")))
# if the second edge covers all of the circle remaining its going to be set to 0 so we know there are no direct intersections
# https://www.statology.org/r-argument-is-of-length-zero/
inter.poly.5.2 <- if(isTRUE(inter.poly.5.2) && inter.poly.5.2$geometry == remaining.circle.5.1$geometry){inter.poly.5.2 <- data.frame()}else{inter.poly.5.2}
## create polygone of the  remaining cricle after both intersects are decucted
# so the area of the frst remining circle minus the area of the second remaining circle
remaining.circle.5.1.and.2.poly <- if(nrow(inter.poly.5.2)==0){remaining.circle.5.1}else{sf::st_difference(remaining.circle.5.1, inter.poly.5.2)}
plot(remaining.circle.17.1.and.2.poly$geometry, main = paste0(my.plot.id, " - ", my.e.form.1, " - ", my.e.form.2))
plot(remaining.circle.12.1.and.2.poly$geometry, add = T)
plot(remaining.circle.5.1.and.2.poly$geometry, add = T)
#### calculate the area
## 17m cricle
# area of the intersection 1
inter.17.1.area <- ifelse(nrow(inter.poly.17.1) == 0, 0, sf::st_area(inter.poly.17.1))
inter.17.1.area
# area of the intersection polygone 2
inter.17.2.area <- ifelse(nrow(inter.poly.17.2) == 0, 0, sf::st_area(inter.poly.17.2))
#  area of the remaining circle, after both intersections are deducted
remaining.circle.area.17 <- sf::st_area(remaining.circle.17.1.and.2.poly)
# save area in dataframe
inter.area.df.17 <- as.data.frame(
cbind("plot_ID" = c(my.plot.id, my.plot.id, my.plot.id), "e_ID" = c(my.e.id.1, my.e.id.2, 0),
#"e_form" = c(my.poly.1$e_form, my.poly.2$e_form, 0),"shape" = c("edge", "edge", "circle"),
"CCS_r_m" = c(c.r3, c.r3, c.r3), "inter_stat" = c(inter.status.poly.17.1, inter.status.poly.17.2, 0),
"area_m2" = c(inter.17.1.area, inter.17.2.area, remaining.circle.area.17)
))
## 12m cricle
# area of the intersection 1
inter.12.1.area <- ifelse(nrow(inter.poly.12.1) == 0, 0, sf::st_area(inter.poly.12.1))
# area of the intersection polygone 2
inter.12.2.area <- ifelse(nrow(inter.poly.12.2) == 0, 0, sf::st_area(inter.poly.12.2))
#  area of the remaining circle, after both intersections are deducted
remaining.circle.area.12 <- sf::st_area(remaining.circle.12.1.and.2.poly)
# save area in dataframe
inter.area.df.12 <- as.data.frame(
cbind("plot_ID" = c(my.plot.id, my.plot.id, my.plot.id), "e_ID" = c(my.e.id.1, my.e.id.2, 0),
#"e_form" = c(my.poly.1$e_form, my.poly.2$e_form, 0),"shape" = c("edge", "edge", "circle"),
"CCS_r_m" = c(c.r2, c.r2, c.r2), "inter_stat" = c(inter.status.poly.12.1, inter.status.poly.12.2, 0),
"area_m2" = c(inter.12.1.area, inter.12.2.area, remaining.circle.area.12)
))
## 5m cricle
# area of the intersection 1
inter.5.1.area <- ifelse(nrow(inter.poly.5.1) == 0, 0, sf::st_area(inter.poly.5.1))
# area of the intersection polygone 2
inter.5.2.area <- ifelse(nrow(inter.poly.5.2) == 0, 0, sf::st_area(inter.poly.5.2))
#  area of the remaining circle, after both intersections are deducted
remaining.circle.area.5 <- sf::st_area(remaining.circle.5.1.and.2.poly)
# save area in dataframe
inter.area.df.5 <- as.data.frame(
cbind("plot_ID" = c(my.plot.id, my.plot.id, my.plot.id),
"e_ID" = c(my.e.id.1, my.e.id.2, 0),
#"e_form" = c(my.poly.1$e_form, my.poly.2$e_form, 0),"shape" = c("edge", "edge", "circle"),
"CCS_r_m" = c(c.r1, c.r1, c.r1),
"inter_stat" = c(inter.status.poly.5.1, inter.status.poly.5.2, 0),
"area_m2" = c(inter.5.1.area, inter.5.2.area, remaining.circle.area.5)
))
# bind area datafames of all 3 circles together
inter.area.df <- rbind(inter.area.df.17, inter.area.df.12,inter.area.df.5 )
inter.area.df
# assing stand to the edges depedning on area
stand.df <- inter.area.df%>%
filter(CCS_r_m  == 17.84) %>%
mutate(area_m2 = as.numeric(area_m2)) %>%
group_by(plot_ID) %>%
arrange(area_m2) %>%
# lowest area receives stand ID C, then B, then A
mutate(stand = case_when(
row_number()== 1 ~ "C",
row_number()== 2 ~ "B",
row_number()== 3 ~ "A",
TRUE ~ NA)) %>%
# make stand.df joinable by only leaving plot_ID, e_ID, no matter the diameter of the CCS
select(- c(CCS_r_m, inter_stat, area_m2))
# join in stand info based on area of the edge segment
inter.area.df <- inter.area.df %>% left_join(., stand.df,
by = c("plot_ID", "e_ID"))
# save datacframe per plot in list
edges.list.two.edges.nogeo[[i]] <- inter.area.df
edges.list.two.edges.nogeo[[i]]
# create list with those plot ID where the two edges intersect within the radius of 17.84m
intersection.between.edges.17 <- sf::st_intersection(
sf::st_intersection(my.poly.1, circle.17), # intersection poly 1 and cirlce 17
sf::st_intersection(my.poly.2, circle.17) # intersection poly 2 and cirlce 17
)
intersection.warning.edges <- ifelse(nrow(intersection.between.edges.17) == 0, NA, intersection.between.edges.17$plot_ID)
intersection.warning.edges.list.nogeo[[i]] <- as.data.frame(cbind("plot_ID" = c(intersection.warning.edges)))
## save intersection polygones in list
# poly.1
inter.poly.1.list.nogeo[[i]] <- if(nrow(inter.poly.17.1)!= 0){c(inter.poly.17.1)}else{c(my.poly.1)}
inter.poly.1.list.nogeo[[i]]
# poly.2
inter.poly.2.list.nogeo[[i]] <- if(nrow(inter.poly.17.2)!= 0){c(inter.poly.17.2)}else{c( my.poly.2)}
inter.poly.2.list.nogeo[[i]]
## save the reimaingf circle polygones in a list
remaining.circle.17.1.and.2.poly$plot_ID <- my.plot.id
remaining.circle.17.1.and.2.poly$e_ID <- 0
remaining.circle.17.1.and.2.poly$e_form <- 0
remaining.circle.17.1.and.2.poly$geometry <- remaining.circle.17.1.and.2.poly$geometry
# create list wit polygones of the remaining cirlce when it´s only one polygone
rem.circle.poly.2.edges.list.nogeo[[i]] <- if(st_geometry_type(remaining.circle.17.1.and.2.poly)== "POLYGON"){c(remaining.circle.17.1.and.2.poly)}else{}
# create list wit polygones of the remaining cirlce when it´s a multipoligone
rem.circle.multipoly.2.edges.list.nogeo[[i]] <- if(st_geometry_type(remaining.circle.17.1.and.2.poly)== "MULTIPOLYGON"){c(remaining.circle.17.1.and.2.poly)}else{}
em.circle.poly.2.edges.list.nogeo[[i]]
rem.circle.poly.2.edges.list.nogeo[[i]]
rem.circle.multipoly.2.edges.list.nogeo[[i]]
trees_data
HBI_loc
